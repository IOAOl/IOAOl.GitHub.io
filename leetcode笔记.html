<!DOCTYPE html>
<html lang="cn">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
  <meta name="renderer" content="webkit">
  <meta name="google-site-verification" content="Rt8zZ_wqH4uNXpajaE5Csa7QuNYnzA94RZuWB7SfQ6Q" />
  
  <title>leetcode笔记 | IOAOl的记lu</title>

  <link rel="shortcut icon" href="/images/favicon.png">
  <link rel="alternate" href="/atom.xml" title="IOAOl的记lu" type="application/atom+xml">
  <meta name="description" content="以下题目均为leetcode的题目，仅作为个人笔记，侵权必删。 栈Easy删除最外层的括号有效括号字符串为空 (“”)、”(“ + A + “)” 或 A + B，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。例如，””，”()”，”(())()” 和 “(()(()))” 都是有效的括号字符串。 如果有效字符串 S 非空，且不存在将其拆分为 S &#x3D; A+B 的方法，我们称其为原">
<meta property="og:type" content="article">
<meta property="og:title" content="leetcode笔记">
<meta property="og:url" content="http://ioaol.top/leetcode%E7%AC%94%E8%AE%B0.html">
<meta property="og:site_name" content="IOAOl的记lu">
<meta property="og:description" content="以下题目均为leetcode的题目，仅作为个人笔记，侵权必删。 栈Easy删除最外层的括号有效括号字符串为空 (“”)、”(“ + A + “)” 或 A + B，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。例如，””，”()”，”(())()” 和 “(()(()))” 都是有效的括号字符串。 如果有效字符串 S 非空，且不存在将其拆分为 S &#x3D; A+B 的方法，我们称其为原">
<meta property="og:locale">
<meta property="og:image" content="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/16/tree.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2020/09/01/e1.jpg">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/solution-static/142/142_fig1.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2020/09/02/mate1.jpg">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png">
<meta property="article:published_time" content="2021-04-21T09:01:13.000Z">
<meta property="article:modified_time" content="2021-06-04T03:40:18.772Z">
<meta property="article:author" content="IOAOl">
<meta property="article:tag" content="动态规划">
<meta property="article:tag" content="栈">
<meta property="article:tag" content="滑动窗口">
<meta property="article:tag" content="模拟">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/16/tree.png">

  <meta name="keywords" content=",动态规划,栈,滑动窗口,模拟">
  <meta name="format-detection" content="telephone=no,email=no">
  <meta name="theme-color" content="#9C27B0">

  <meta name="mobile-web-app-capable" content="yes">
  <meta name="application-name" content="IOAOl的记lu">
  <meta name="msapplication-starturl" content="http://ioaol.top/leetcode%E7%AC%94%E8%AE%B0.html">
  <meta name="msapplication-navbutton-color" content="#9C27B0">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-title" content="IOAOl的记lu">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="apple-touch-icon" href="/images/favicon.png">

  
    <link rel="canonical" href="http://ioaol.top/leetcode%E7%AC%94%E8%AE%B0.html">
  

  
  

  
  
  

  
<link rel="stylesheet" href="/css/mdui.css">
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/custom.css">

<meta name="generator" content="Hexo 5.2.0"></head>
<body class="mdui-appbar-with-toolbar mdui-drawer-body-left mdui-theme-primary-indigo mdui-theme-accent-pink">
  <script>var a=localStorage.getItem("mdui-theme-layout-dark");if(a){document.getElementsByTagName("body")[0].className+=" mdui-theme-layout-dark"};</script>
  <header id="header" class="mdui-appbar mdui-appbar-fixed mdui-appbar-scroll-hide mdui-appbar-inset">
  <div class="mdui-toolbar mdui-color-theme">
    <a href="javascript:;" class="mdui-btn mdui-btn-icon" mdui-drawer="{target: '#sidebar', swipe: true}"><i class="mdui-icon material-icons">menu</i></a>
    <a href="/" class="mdui-typo-headline">IOAOl的记lu</a>
    <div class="mdui-toolbar-spacer"></div>
    <a href="javascript:;" class="mdui-btn mdui-btn-icon" mdui-dialog="{target: '#search'}" mdui-tooltip="{content: 'Search'}"><i class="mdui-icon material-icons">search</i></a>
    <a href="/atom.xml" class="mdui-btn mdui-btn-icon" mdui-tooltip="{content: 'RSS'}"><i class="mdui-icon material-icons">rss_feed</i></a>
  </div>
</header>
<div class="mdui-dialog" id="search">
  
    <div class="search-form">
      <input type="search" class="search-form-input" placeholder="请输入关键字">
    </div>
    <div class="search-result" data-resource="/search.xml"></div>
  
</div>
  <aside id="sidebar" class="mdui-drawer mdui-drawer-full-height">
  <div class="mdui-grid-tile">
    <img src="/images/banner.png" style="height: 160px;">
    <img src="/images/avatar1.png" class="avatar-animation" style="position: absolute; top: 10%; left: 24px; width: 64px; height: 64px; border: 2px solid #fff; border-radius: 50%;">
    <div class="mdui-grid-tile-actions">
      <div class="mdui-grid-tile-text">
        <div class="mdui-grid-tile-title">IOAOl</div>
        <div class="mdui-grid-tile-subtitle"><i class="mdui-icon material-icons">art_track</i></div>
      </div>
      
        <div class="mdui-grid-tile-buttons">
          <a href="mailto:1449821178@qq.com" class="mdui-btn mdui-btn-icon" mdui-tooltip="{content: '1449821178@qq.com'}"><i class="mdui-icon material-icons">email</i></a>
        </div>
      
    </div>
  </div>

  <div class="mdui-list" mdui-collapse="{accordion: true}">
    <a href="/" class="mdui-list-item mdui-ripple">
      <i class="mdui-list-item-icon mdui-icon material-icons mdui-text-color-blue">home</i>
      <div class="mdui-list-item-content">Home</div>
    </a>
    <div class="mdui-collapse-item">
      <div class="mdui-collapse-item-header mdui-list-item mdui-ripple">
        <i class="mdui-list-item-icon mdui-icon material-icons mdui-text-color-deep-orange">inbox</i>
        <div class="mdui-list-item-content">Archive</div>
        <i class="mdui-collapse-item-arrow mdui-icon material-icons">keyboard_arrow_down</i>
      </div>
      <div class="mdui-collapse-item-body mdui-list mdui-list-dense">
        
        <a class="mdui-ripple sidebar_archives-link" href="/archives/2021/05/">May 2021<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/archives/2021/04/">April 2021<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/archives/2021/03/">March 2021<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/archives/2021/02/">February 2021<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/archives/2021/01/">January 2021<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/archives/2020/12/">December 2020<span class="mdui-ripple sidebar_archives-count">3</span></a><a class="mdui-ripple sidebar_archives-link" href="/archives/2020/08/">August 2020<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/archives/2020/06/">June 2020<span class="mdui-ripple sidebar_archives-count">2</span></a><a class="mdui-ripple sidebar_archives-link" href="/archives/2020/05/">May 2020<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/archives/2019/09/">September 2019<span class="mdui-ripple sidebar_archives-count">4</span></a><a class="mdui-ripple sidebar_archives-link" href="/archives/2019/08/">August 2019<span class="mdui-ripple sidebar_archives-count">1</span></a>
        
      </div>
    </div>
    <div class="mdui-collapse-item">
      <div class="mdui-collapse-item-header mdui-list-item mdui-ripple">
        <i class="mdui-list-item-icon mdui-icon material-icons mdui-text-color-green">chrome_reader_mode</i>
        <div class="mdui-list-item-content">Category</div>
        <i class="mdui-collapse-item-arrow mdui-icon material-icons">keyboard_arrow_down</i>
      </div>
      <div class="mdui-collapse-item-body mdui-list mdui-list-dense">
        
        <a class="mdui-ripple sidebar_archives-link" href="/categories/%E7%A8%8B%E5%BA%8F/">程序<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/%E7%AE%97%E6%B3%95/">算法<span class="mdui-ripple sidebar_archives-count">2</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/%E7%AE%97%E6%B3%95%E9%A2%98/">算法题<span class="mdui-ripple sidebar_archives-count">1</span></a>
        
      </div>
    </div>
    <div class="mdui-collapse-item">
      <div class="mdui-collapse-item-header mdui-list-item mdui-ripple">
        <i class="mdui-list-item-icon mdui-icon material-icons mdui-text-color-brown">bookmark</i>
        <div class="mdui-list-item-content">Tag</div>
        <i class="mdui-collapse-item-arrow mdui-icon material-icons">keyboard_arrow_down</i>
      </div>
      <div class="mdui-collapse-item-body mdui-list mdui-list-dense">
        
        <a class="mdui-ripple sidebar_archives-link" href="/tags/Gallery/" rel="tag">Gallery<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/Prim/" rel="tag">Prim<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/TSP/" rel="tag">TSP<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/WPF/" rel="tag">WPF<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/test/" rel="tag">test<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">动态规划<span class="mdui-ripple sidebar_archives-count">2</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" rel="tag">并查集<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/%E6%A0%88/" rel="tag">栈<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/%E6%A8%A1%E6%8B%9F/" rel="tag">模拟<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" rel="tag">滑动窗口<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/" rel="tag">表达式求值<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0/" rel="tag">计网笔记<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/%E8%BF%90%E8%BE%93%E5%B1%82/" rel="tag">运输层<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/" rel="tag">遗传算法<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/%E9%98%9F%E5%88%97/" rel="tag">队列<span class="mdui-ripple sidebar_archives-count">1</span></a>
        
      </div>
    </div>
    <a href="/about" class="mdui-list-item mdui-ripple">
      <i class="mdui-list-item-icon mdui-icon material-icons mdui-text-color-purple">person</i>
      <div class="mdui-list-item-content">About</div>
    </a>
  </div>

  <div class="mdui-divider"></div>

  <div class="mdui-list" mdui-collapse="{accordion: true}">
    
      <a href="/gallery" class="mdui-list-item mdui-ripple">Gallery</a>
    
      <a href="/Impressions" class="mdui-list-item mdui-ripple">Impressions</a>
    
    <div class="mdui-collapse-item">
      <div class="mdui-collapse-item-header mdui-list-item mdui-ripple">
        <div class="mdui-list-item-content">Links</div>
        <i class="mdui-list-item-icon mdui-icon material-icons">link</i>
      </div>
      <div class="mdui-collapse-item-body mdui-list mdui-list-dense">
        
          <a href="https://github.com/ioaol" target="_blank" class="mdui-list-item mdui-ripple mdui-p-l-2 mdui-text-color-theme-accent" style="justify-content: center;">github主页</a>
        
        
      </div>
    </div>
  </div>

    <script type="text/javascript" charset="utf-8" src="/js/tagcloud.js"></script>
    <script type="text/javascript" charset="utf-8" src="/js/tagcanvas.js"></script>
    <div class="widget-wrap">
        <h3 class="widget-title">Tag Cloud</h3>
        <div id="myCanvasContainer" class="widget tagcloud">
            <canvas width="250" height="250" id="resCanvas" style="width=100%">
                <a href="/tags/Gallery/" style="font-size: 10px;">Gallery</a> <a href="/tags/Prim/" style="font-size: 10px;">Prim</a> <a href="/tags/TSP/" style="font-size: 10px;">TSP</a> <a href="/tags/WPF/" style="font-size: 10px;">WPF</a> <a href="/tags/test/" style="font-size: 10px;">test</a> <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 20px;">动态规划</a> <a href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" style="font-size: 10px;">并查集</a> <a href="/tags/%E6%A0%88/" style="font-size: 10px;">栈</a> <a href="/tags/%E6%A8%A1%E6%8B%9F/" style="font-size: 10px;">模拟</a> <a href="/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" style="font-size: 10px;">滑动窗口</a> <a href="/tags/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/" style="font-size: 10px;">表达式求值</a> <a href="/tags/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0/" style="font-size: 10px;">计网笔记</a> <a href="/tags/%E8%BF%90%E8%BE%93%E5%B1%82/" style="font-size: 10px;">运输层</a> <a href="/tags/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/" style="font-size: 10px;">遗传算法</a> <a href="/tags/%E9%98%9F%E5%88%97/" style="font-size: 10px;">队列</a>
            </canvas>
        </div>
    </div>

</aside>


  <main id="main" class="mdui-m-t-5 fadeIn animated">
  
<link rel="stylesheet" href="https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.css">

  <style>#main article .mdui-card-content .center-block{display:block!important;margin-right:auto!important;margin-left:auto!important}</style>
  <article class="mdui-card mdui-m-b-5">
    <header class="mdui-card-media">
      <img src="/images/random/material-10.png" style="max-height: 240px;">
      <div class="mdui-card-media-covered">
        <div class="mdui-card-primary">
          <div class="mdui-card-primary-title">leetcode笔记</div>
          <div class="mdui-card-primary-subtitle"><i class="iconfont">&#xe697;</i> 2021-04-21 / <i class="iconfont">&#xe601;</i> IOAOl &nbsp;&nbsp; <span id="busuanzi_container_page_pv" style="display: none;"><i class="iconfont">&#xe7fd;</i> <span id="busuanzi_value_page_pv"></span></span></div>
        </div>
      </div>
      <div class="mdui-card-menu">
        
          <button class="mdui-btn mdui-btn-icon mdui-text-color-white" mdui-menu="{target: '#qrcode', align: 'right'}"><i class="mdui-icon material-icons">devices</i></button>
          <ul class="mdui-menu" id="qrcode">
            
              <li class="mdui-menu-item"><a class="mdui-text-center mdui-ripple">发送到手机</a></li>
            
            <li class="mdui-menu-item" disabled>
              
                <img src="https://chart.googleapis.com/chart?cht=qr&chs=246x246&chl=http://ioaol.top/leetcode%E7%AC%94%E8%AE%B0.html&chld=M|2">
              
            </li>
          </ul>
        
        
          <button class="mdui-btn mdui-btn-icon mdui-text-color-white" mdui-menu="{target: '#share_menu', align: 'right'}"><i class="mdui-icon material-icons">share</i></button>
          <ul class="mdui-menu" id="share_menu">
            <li class="mdui-menu-item">
              <a href="http://service.weibo.com/share/share.php?appkey=&title=leetcode笔记&url=http://ioaol.top/leetcode%E7%AC%94%E8%AE%B0.html&pic=http://ioaol.top/images/favicon.png&searchPic=false&style=simple" target="_blank" class="mdui-ripple">Share to Weibo</a>
            </li>
            <li class="mdui-menu-item">
              <a href="https://twitter.com/intent/tweet?text=leetcode笔记&url=http://ioaol.top/leetcode%E7%AC%94%E8%AE%B0.html&via=IOAOl" target="_blank" class="mdui-ripple">Share to Twitter</a>
            </li>
            <li class="mdui-menu-item">
              <a href="https://www.facebook.com/sharer/sharer.php?u=http://ioaol.top/leetcode%E7%AC%94%E8%AE%B0.html" target="_blank" class="mdui-ripple">Share to Facebook</a>
            </li>
            <li class="mdui-menu-item">
              <a href="https://plus.google.com/share?url=http://ioaol.top/leetcode%E7%AC%94%E8%AE%B0.html" target="_blank" class="mdui-ripple">Share to Google+</a>
            </li>
            <li class="mdui-menu-item">
              <a href="https://www.linkedin.com/shareArticle?mini=true&url=http://ioaol.top/leetcode%E7%AC%94%E8%AE%B0.html&title=leetcode笔记" target="_blank" class="mdui-ripple">Share to LinkedIn</a>
            </li>
            <li class="mdui-menu-item">
              <a href="http://connect.qq.com/widget/shareqq/index.html?site=IOAOl的记lu&title=leetcode笔记&pics=http://ioaol.top/images/favicon.png&url=http://ioaol.top/leetcode%E7%AC%94%E8%AE%B0.html" target="_blank" class="mdui-ripple">Share to QQ</a>
            </li>
            <li class="mdui-menu-item">
              <a href="https://telegram.me/share/url?url=http://ioaol.top/leetcode%E7%AC%94%E8%AE%B0.html&text=leetcode笔记" target="_blank" class="mdui-ripple">Share to Telegram</a>
            </li>
          </ul>
        
      </div>
    </header>
    <div class="mdui-card-content mdui-typo">
      <p><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"></p>
<p><meta name="referrer" content="no-referrer"><br><strong>以下题目均为leetcode的题目，仅作为个人笔记，侵权必删。</strong></p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="Easy"><a href="#Easy" class="headerlink" title="Easy"></a>Easy</h3><h4 id="删除最外层的括号"><a href="#删除最外层的括号" class="headerlink" title="删除最外层的括号"></a><a href="https://leetcode-cn.com/problems/remove-outermost-parentheses">删除最外层的括号</a></h4><p>有效括号字符串为空 (“”)、”(“ + A + “)” 或 A + B，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。例如，””，”()”，”(())()” 和 “(()(()))” 都是有效的括号字符串。</p>
<p>如果有效字符串 S 非空，且不存在将其拆分为 S = A+B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。</p>
<p>给出一个非空有效字符串 S，考虑将其进行原语化分解，使得：S = P_1 + P_2 + … + P_k，其中 P_i 是有效括号字符串原语。</p>
<p>对 S 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 S 。</p>
<p><strong>思路：栈判断是否组成完整的原语，直接substr消除最外层的符号。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeOuterParentheses</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> stackint=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;S.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(S[i]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                stackint++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stackint--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(stackint==<span class="number">0</span>)&#123;</span><br><span class="line">               res=res+S.substr(left+<span class="number">1</span>,i-left<span class="number">-1</span>);</span><br><span class="line">               left=i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a><a href="https://leetcode-cn.com/problems/min-stack">最小栈</a></h4><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p>
<p>push(x) —— 将元素 x 推入栈中。<br>pop() —— 删除栈顶的元素。<br>top() —— 获取栈顶元素。<br>getMin() —— 检索栈中的最小元素。</p>
<p><strong>思路：设计一个辅助栈，给每个元素都配上一个当前最小值，跟随原来栈来增减.</strong></p>
<p>$\textcolor{red}{注意点:辅助栈要先放入一个最大值，在第一个元素放入的时候方便更新。}$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    Deque&lt;Integer&gt; MainStack;</span><br><span class="line">    Deque&lt;Integer&gt; assistStack;	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MainStack=<span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        assistStack=<span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        assistStack.push(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        MainStack.push(x);</span><br><span class="line">        <span class="keyword">if</span>(x&lt;assistStack.peek())</span><br><span class="line">            assistStack.push(x);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            assistStack.push(assistStack.peek());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MainStack.pop();</span><br><span class="line">        assistStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> MainStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> assistStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="比较含退格的字符串"><a href="#比较含退格的字符串" class="headerlink" title="比较含退格的字符串"></a><a href="https://leetcode-cn.com/problems/backspace-string-compare">比较含退格的字符串</a></h4><p>给定 S 和 T 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 # 代表退格字符。</p>
<p>注意：如果对空文本输入退格字符，文本继续为空。</p>
<p>示例 1：</p>
<p>输入：S = “ab#c”, T = “ad#c”<br>输出：true<br>解释：S 和 T 都会变成 “ac”。</p>
<p>思路：模拟，遇到‘#’就判断栈是否为空，不空则弹出，遇到其他符号就入栈。</p>
<p>时间复杂度O(n+m)</p>
<p>空间复杂度O(n+m)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">backspaceCompare</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; s1;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; s2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!s1.empty())</span><br><span class="line">                    s1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> s1.push(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;t.size();k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t[k]==<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!s2.empty())</span><br><span class="line">                    s2.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> s2.push(t[k]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s1==s2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>思路2：从后往前遍历，每次都先jump到有效位置，进行比较。</p>
<p>注意：①跳过的时候要看跳的时候是否有‘#’。</p>
<p>​            ②要两个字符串分析完才能结束。</p>
<p>时间复杂度O(n+m)</p>
<p>空间复杂度O(1)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">string</span> &amp; str ,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i]==<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                count++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(count)</span><br><span class="line">                --count;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">backspaceCompare</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=s.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> j=t.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>||j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            i=jump(s,i);</span><br><span class="line">            j=jump(t,j);</span><br><span class="line">            <span class="keyword">if</span>(i&lt;<span class="number">0</span>||j&lt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(s[i--]!=t[j--])<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i&lt;<span class="number">0</span>&amp;&amp;j&lt;<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="整理字符串"><a href="#整理字符串" class="headerlink" title="整理字符串"></a><a href="https://leetcode-cn.com/problems/make-the-string-great/">整理字符串</a></h4><p>一个整理好的字符串中，两个相邻字符 s[i] 和 s[i+1]，其中 0&lt;= i &lt;= s.length-2 ，要满足如下条件:</p>
<p>若 s[i] 是小写字符，则 s[i+1] 不可以是相同的大写字符。<br>若 s[i] 是大写字符，则 s[i+1] 不可以是相同的小写字符。</p>
<p>思路用栈保存要保留的字符，遇到相同的（不同大小写的）就弹出，否则加入。</p>
<p>时间复杂度O(n)</p>
<p>空间复杂度O(n)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">makeGood</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size()&lt;<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=s.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st.empty())</span><br><span class="line">                st.push(s[i]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]-<span class="string">&#x27;a&#x27;</span>==st.top()-<span class="string">&#x27;A&#x27;</span>||s[i]-<span class="string">&#x27;A&#x27;</span>==st.top()-<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">                st.pop();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                st.push(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">while</span>(!st.empty())&#123;</span><br><span class="line">            ans+=st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>优化后的 string当st用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">makeGood</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!ans.empty()&amp;&amp;((<span class="keyword">char</span>)(ans.back()) ^ s[i]) == <span class="number">32</span>)</span><br><span class="line">                ans.pop_back();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ans.push_back(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="二叉树的后序遍历"><a href="#二叉树的后序遍历" class="headerlink" title="二叉树的后序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal">二叉树的后序遍历</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode* prev=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="literal">nullptr</span>||!st.empty())&#123;	<span class="comment">//栈中还有节点或者根节点不为空可以继续遍历</span></span><br><span class="line">            <span class="keyword">while</span>(root)&#123;</span><br><span class="line">                st.emplace(root);	<span class="comment">//先存所有左孩子</span></span><br><span class="line">                root=root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root=st.top();	<span class="comment">//取出最后的左孩子或者是root本身</span></span><br><span class="line">            st.pop();</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right==<span class="literal">nullptr</span>||root-&gt;right==prev)&#123;	<span class="comment">//右孩子为空或者右树已经访问完毕</span></span><br><span class="line">                ans.emplace_back(root-&gt;val);<span class="comment">//访问根节点</span></span><br><span class="line">                prev=root;</span><br><span class="line">                root=<span class="literal">nullptr</span>;	<span class="comment">//取下一个栈中的节点</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                st.emplace(root);	<span class="comment">//存放根节点</span></span><br><span class="line">                root=root-&gt;right;	<span class="comment">//访问右树</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">二叉树的中序遍历</a></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="literal">nullptr</span>||!st.empty())&#123;		<span class="comment">//栈中还有节点或者根节点不为空可以继续遍历</span></span><br><span class="line">            <span class="keyword">while</span>(root)&#123;</span><br><span class="line">                st.emplace(root);		<span class="comment">//先存所有左孩子</span></span><br><span class="line">                root=root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root=st.top();	<span class="comment">//取出最后的左孩子或者是root本身</span></span><br><span class="line">            st.pop();</span><br><span class="line">            ans.emplace_back(root-&gt;val);	<span class="comment">//访问根节点</span></span><br><span class="line">            root=root-&gt;right;    <span class="comment">//访问右树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="二叉树的前序遍历"><a href="#二叉树的前序遍历" class="headerlink" title="二叉树的前序遍历"></a>二叉树的前序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="literal">nullptr</span>||!st.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root)&#123;</span><br><span class="line">                ans.emplace_back(root-&gt;val);</span><br><span class="line">                st.emplace(root);</span><br><span class="line">                root=root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root=st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            root=root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="medium"><a href="#medium" class="headerlink" title="medium"></a>medium</h3><h4 id="反转每对括号间的子串"><a href="#反转每对括号间的子串" class="headerlink" title="反转每对括号间的子串"></a><a href="https://leetcode-cn.com/problems/reverse-substrings-between-each-pair-of-parentheses/">反转每对括号间的子串</a></h4><p>给出一个字符串 <code>s</code>（仅含有小写英文字母和括号）。</p>
<p>请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。</p>
<p>注意，您的结果中 <strong>不应</strong> 包含任何括号。</p>
<p> <strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;(ed(et(oc))el)&quot;</span><br><span class="line">输出：&quot;leetcode&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;a(bcdefghijkl(mno)p)q&quot;</span><br><span class="line">输出：&quot;apmnolkjihgfedcbq&quot;</span><br></pre></td></tr></table></figure>
<p>思路1：栈，遇到左括号进栈，右括号出栈的同时将左右括号之间的所有元素反转。</p>
<p>最后将左右括号去除。</p>
<p>时间复杂度O(<script type="math/tex">n^2</script>)</p>
<p>空间复杂度O(<script type="math/tex">n</script>)，栈空间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                st.push(i);<span class="comment">//序号进栈</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> head=st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                <span class="comment">//反转中间元素</span></span><br><span class="line">                reverse(s.begin()+head+<span class="number">1</span>,s.begin()+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> ans=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch:s)	<span class="comment">//去掉括号</span></span><br><span class="line">            <span class="keyword">if</span>(ch!=<span class="string">&#x27;(&#x27;</span>&amp;&amp;ch!=<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">                ans+=ch;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>思路2：先用栈遍历来记录每个括号对应的括号位置。然后遍历时每次遇到括号就跳转到对应括号，反方向遍历。每个括号会遍历两遍，每个元素会遍历一遍。</p>
<p>时间复杂度O(<script type="math/tex">n</script>)</p>
<p>空间复杂度O(<script type="math/tex">n</script>)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">int</span> len=s.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">pairs</span><span class="params">(len)</span></span>;		<span class="comment">//记录每个括号对应的括号位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                st.push(i);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> head=st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                pairs[i]=head;</span><br><span class="line">                pairs[head]=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dir=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">string</span> ans=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;len)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>||s[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                i=pairs[i];	<span class="comment">//跳转到对应括号</span></span><br><span class="line">                dir=-dir;	<span class="comment">//方向反转</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans+=s[i];	<span class="comment">//保存元素</span></span><br><span class="line">            &#125;</span><br><span class="line">            i+=dir;	<span class="comment">//跟着dir方向走</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><h3 id="easy"><a href="#easy" class="headerlink" title="easy"></a>easy</h3><h4 id="和为s的连续正数序列"><a href="#和为s的连续正数序列" class="headerlink" title="和为s的连续正数序列"></a><a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/">和为s的连续正数序列</a></h4><p><span id="he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof"></span></p>
<p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p>
<p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：target &#x3D; 9</span><br><span class="line">输出：[[2,3,4],[4,5]]</span><br></pre></td></tr></table></figure>
<p>思路:滑动窗口，三种情况。</p>
<p>① 当当前窗口比target小时，窗口右端点右移。</p>
<p>② 当当前窗口比target大时，窗口左端点右移。</p>
<p>③ 当当前窗口等于target时，窗口左端点右移。</p>
<p>其中要一直保持左端点小于右端点。</p>
<p>注意：右端点上界为target/2+1,超过之后两个数相加就肯定大于target。</p>
<p>时间复杂度O(target)</p>
<p>空间复杂度O(1)</p>
<p>求和公式版：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; findContinuousSequence(<span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">1</span>,r=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(r&gt;l)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum=(l+r)*(r-l+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(sum==target)&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; newlist;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=l;j&lt;=r;j++)</span><br><span class="line">                    newlist.emplace_back(j);</span><br><span class="line">                ans.emplace_back(newlist);</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;target)++r;</span><br><span class="line">            <span class="keyword">else</span> ++l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>移动窗口调整sum版</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; findContinuousSequence(<span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">1</span>,r=<span class="number">2</span>,sum=<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">while</span>(r&gt;l)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum==target)&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; newlist;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=l;j&lt;=r;++j)</span><br><span class="line">                    newlist.emplace_back(j);</span><br><span class="line">                ans.emplace_back(newlist);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum&lt;target)&#123;	<span class="comment">//注意加的顺序</span></span><br><span class="line">                ++r;</span><br><span class="line">                sum+=r;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;			<span class="comment">//注意减的顺序</span></span><br><span class="line">                sum-=l;</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="medium-1"><a href="#medium-1" class="headerlink" title="medium"></a>medium</h3><h4 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串</a></h4><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s &#x3D; &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>
<p>思路：滑动窗口，set存放窗口内的字母。 将i , j分别作为窗口的左右边界，没有遇到重复的就 j 右移，直到遇到\n或者在窗口内存放的字母。i右移直到遇到刚才j遇到重复字母。如此循环，在过程中记录窗口大小。</p>
<p>时间复杂度O(N)</p>
<p>空间复杂度O(|<script type="math/tex">\sum{Z}</script>|)字符集大小</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>,ans=<span class="number">0</span>,len=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt; st;	<span class="comment">//窗口里的字母</span></span><br><span class="line">        <span class="keyword">while</span>(r&lt;s.size())&#123;</span><br><span class="line">            <span class="comment">//窗口找不到当前右边界字母并且右边界没到字符串末尾</span></span><br><span class="line">            <span class="keyword">while</span>(r&lt;s.size()&amp;&amp;st.find(s[r])==st.end())</span><br><span class="line">                st.insert(s[r++]);	<span class="comment">//加入窗口并更新边界</span></span><br><span class="line">            ans=max(ans,r-l);	<span class="comment">//更新窗口最大值</span></span><br><span class="line">            <span class="keyword">while</span>(r&gt;=l)&#123;</span><br><span class="line">                st.erase(s[l]);</span><br><span class="line">                <span class="keyword">if</span>(s[l++]==s[r])<span class="keyword">break</span>;	<span class="comment">//刚才删掉了与有边界遇到的相同字符可以退出了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="hard"><a href="#hard" class="headerlink" title="hard"></a>hard</h3><h4 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/">最小覆盖子串</a></h4><p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</p>
<p>注意：如果 s 中存在这样的子串，我们保证它是唯一的答案。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;ADOBECODEBANC&quot;</span>, t = <span class="string">&quot;ABC&quot;</span></span><br><span class="line">输出：<span class="string">&quot;BANC&quot;</span></span><br></pre></td></tr></table></figure>
<p>思路：当没有覆盖t全部字母时，right右移，覆盖完了，left左移，记录区间长度最小值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;&amp; Scount,<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;&amp; Tcount)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it=Scount.begin();</span><br><span class="line">        <span class="keyword">while</span>(it!=Scount.end())&#123;</span><br><span class="line">            <span class="keyword">if</span>((it-&gt;second)&gt;(Tcount[it-&gt;first]))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            it++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; Scount;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; Tcount;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Scount.find(t[i])==Scount.end())&#123;</span><br><span class="line">                Scount[t[i]]=<span class="number">0</span>;</span><br><span class="line">                Tcount[t[i]]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Scount[t[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans=s.size()+<span class="number">22</span>;</span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!(right&gt;=s.size()&amp;&amp;!check(Scount,Tcount)))&#123;</span><br><span class="line">            <span class="keyword">if</span>(!check(Scount,Tcount))&#123;</span><br><span class="line">                <span class="keyword">if</span>(Scount.find(s[right])!=Scount.end())&#123;</span><br><span class="line">                   Tcount[s[right]]++;</span><br><span class="line">                &#125;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(right-left&lt;ans)&#123;</span><br><span class="line">                    index=left;</span><br><span class="line">                    ans=right-left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(Scount.find(s[left])!=Scount.end())&#123;</span><br><span class="line">                    Tcount[s[left]]--;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans==s.size()+<span class="number">22</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> s.substr(index,ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="easy-1"><a href="#easy-1" class="headerlink" title="easy"></a>easy</h3><h4 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">连续子数组的最大和</a></h4><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p>
<p>要求时间复杂度为O(n)。</p>
<p><strong>示例1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure>
<p>思路：动态规划，dp[i]等于nums[i]为末尾的子数组的和的最大值。寻找dp数组最大值，就为所求的解。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=nums[<span class="number">0</span>],pre=<span class="number">0</span>,cur=nums[<span class="number">0</span>];	<span class="comment">//pre=dp[-1] ,cur=dp[0]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>&amp; num : nums)&#123;</span><br><span class="line">            cur = max(num, pre + num);<span class="comment">//当前的子数组取自己为单个的数组，还是加前面的数组</span></span><br><span class="line">            ans = max(cur, ans);	  <span class="comment">//更新ans</span></span><br><span class="line">            pre = cur;				  <span class="comment">//更新pre</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="medium-2"><a href="#medium-2" class="headerlink" title="medium"></a>medium</h3><h4 id="解码方法"><a href="#解码方法" class="headerlink" title="解码方法"></a><a href="https://leetcode-cn.com/problems/decode-ways/">解码方法</a></h4><p>一条包含字母 <code>A-Z</code> 的消息通过以下映射进行了 <strong>编码</strong> ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#39;A&#39; -&gt; 1</span><br><span class="line">&#39;B&#39; -&gt; 2</span><br><span class="line">...</span><br><span class="line">&#39;Z&#39; -&gt; 26</span><br></pre></td></tr></table></figure>
<p>要 <strong>解码</strong> 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，<code>&quot;11106&quot;</code> 可以映射为：</p>
<ul>
<li><code>&quot;AAJF&quot;</code> ，将消息分组为 <code>(1 1 10 6)</code></li>
<li><code>&quot;KJF&quot;</code> ，将消息分组为 <code>(11 10 6)</code></li>
</ul>
<p>注意，消息不能分组为 <code>(1 11 06)</code> ，因为 <code>&quot;06&quot;</code> 不能映射为 <code>&quot;F&quot;</code> ，这是由于 <code>&quot;6&quot;</code> 和 <code>&quot;06&quot;</code> 在映射中并不等价。</p>
<p>给你一个只含数字的 <strong>非空</strong> 字符串 <code>s</code> ，请计算并返回 <strong>解码</strong> 方法的 <strong>总数</strong> 。</p>
<p>题目数据保证答案肯定是一个 <strong>32 位</strong> 的整数。</p>
<p>思路：动态规划，dp[i]表示0-(i-1)为之间的解码可能总数。第i个字符它可以跟i-1个字符合并为一个数也可以自己作为一个数。</p>
<p>注意：以上两种情况可以同时满足。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(s.size()+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;	<span class="comment">//空串</span></span><br><span class="line">        <span class="keyword">if</span>(s.size()&gt;=<span class="number">1</span>)</span><br><span class="line">            dp[<span class="number">1</span>]=(s[<span class="number">0</span>]==<span class="string">&#x27;0&#x27;</span>?<span class="number">0</span>:<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=stoi(s.substr(i<span class="number">-2</span>,<span class="number">2</span>));</span><br><span class="line">            <span class="keyword">if</span>(tmp&gt;=<span class="number">10</span>&amp;&amp;tmp&lt;=<span class="number">26</span>)	<span class="comment">//说明是两位数</span></span><br><span class="line">                dp[i]+=dp[i<span class="number">-2</span>];</span><br><span class="line">            <span class="keyword">if</span>(s[i<span class="number">-1</span>]!=<span class="string">&#x27;0&#x27;</span>)			<span class="comment">//除了自己是0以外，都可以自己作为一个数解码</span></span><br><span class="line">                dp[i]+=dp[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="股票的最大利润"><a href="#股票的最大利润" class="headerlink" title="股票的最大利润"></a><a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/">股票的最大利润</a></h4><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">买卖股票的最佳时机</a></p>
<p>与上面一道题相同。</p>
<p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？ </p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。</span><br><span class="line">     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格。</span><br></pre></td></tr></table></figure>
<p>思路：当天的最大利润=今天的价格-历史最低价。dp[i]表示前i天最多能获得的利润。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.size()&lt;<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dpnum=<span class="number">0</span>;    <span class="comment">//前0天能获得的利润</span></span><br><span class="line">        <span class="keyword">int</span> historyMinCost=prices[<span class="number">0</span>];  <span class="comment">//历史最低价</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.size();i++)&#123;</span><br><span class="line">            <span class="comment">//前i-1天最大利润和今天能获得的最大利润比较</span></span><br><span class="line">            <span class="keyword">int</span> curMax=max(dpnum,prices[i]-historyMinCost);</span><br><span class="line">            <span class="comment">//更新历史最低利润 </span></span><br><span class="line">            historyMinCost=min(historyMinCost,prices[i]);</span><br><span class="line">            <span class="comment">//更新前i-1天的记录</span></span><br><span class="line">            dpnum=curMax;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dpnum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="hard-1"><a href="#hard-1" class="headerlink" title="hard"></a>hard</h3><h4 id="最大子矩阵"><a href="#最大子矩阵" class="headerlink" title="最大子矩阵"></a><a href="https://leetcode-cn.com/problems/max-submatrix-lcci/">最大子矩阵</a></h4><p>给定一个正整数、负整数和 0 组成的 N × M 矩阵，编写代码找出元素总和最大的子矩阵。</p>
<p>返回一个数组 <code>[r1, c1, r2, c2]</code>，其中 <code>r1</code>, <code>c1</code> 分别代表子矩阵左上角的行号和列号，<code>r2</code>, <code>c2</code> 分别代表右下角的行号和列号。若有多个满足条件的子矩阵，返回任意一个均可。</p>
<p><strong>注意：</strong>本题相对书上原题稍作改动</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[</span><br><span class="line">   [-1,0],</span><br><span class="line">   [0,-1]</span><br><span class="line">]</span><br><span class="line">输出：[0,1,0,1]</span><br><span class="line">解释：输入中标粗的元素即为输出所表示的矩阵</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ul>
<li><code>1 &lt;= matrix.length, matrix[0].length &lt;= 200</code></li>
</ul>
<p>思路：压缩二维数组的列使其为一维数组，然后动态规划求一维数组的最大字序和，就可以求出该二维数组固定高（这里的高就是二维数组的高度）的子矩阵的最大值。</p>
<p>然后套两层循环来遍历所有的高，i为上高，j为下底，有了i和j就可以唯一确定矩阵的高。</p>
<p>时间复杂度O（<script type="math/tex">nm^2</script>）</p>
<p>空间复杂度O（<script type="math/tex">n</script>）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getMaxMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r1,c1,r2,c2,maxval=INT_MIN;			<span class="comment">//初始化矩阵最大值</span></span><br><span class="line">        <span class="keyword">int</span> m=matrix.size(),n=matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> tmp1,tmp2;		<span class="comment">//用于保存求一维数组最大字段和的起点。</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">colsum</span><span class="params">(n,<span class="number">0</span>)</span></span>;		<span class="comment">//压缩后的一维矩阵</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)&#123;			<span class="comment">//遍历上高</span></span><br><span class="line">            fill(colsum.begin(),colsum.end(),<span class="number">0</span>);	<span class="comment">//上高变化时，将一维数组初始化</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;m;++j)&#123;		<span class="comment">//遍历下底</span></span><br><span class="line">                <span class="keyword">int</span> sum=<span class="number">0</span>;			<span class="comment">//开始求最大字序和</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;++k)&#123;	</span><br><span class="line">                    colsum[k]+=matrix[j][k];</span><br><span class="line">                    <span class="keyword">if</span>(sum&gt;<span class="number">0</span>)&#123;		<span class="comment">//前面的+现在的 可以变得更大</span></span><br><span class="line">                        sum+=colsum[k];</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;			<span class="comment">//抛弃前面的，从现在开始重新计算</span></span><br><span class="line">                        sum=colsum[k];</span><br><span class="line">                        tmp1=i;		<span class="comment">//记录上高</span></span><br><span class="line">                        tmp2=k;		<span class="comment">//记录左边界</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(maxval&lt;sum)&#123;		<span class="comment">//更新答案</span></span><br><span class="line">                        maxval=sum;	</span><br><span class="line">                        r1=tmp1;		<span class="comment">//拿到之前记录的上高</span></span><br><span class="line">                        c1=tmp2;		<span class="comment">//拿到之前记录的左边界</span></span><br><span class="line">                        r2=j;			<span class="comment">//记录当前的下底</span></span><br><span class="line">                        c2=k;			<span class="comment">//记录当前的右边界</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;r1,c1,r2,c2&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="奇怪的打印机"><a href="#奇怪的打印机" class="headerlink" title="奇怪的打印机"></a><a href="https://leetcode-cn.com/problems/strange-printer/">奇怪的打印机</a></h4><p>有台奇怪的打印机有以下两个特殊要求：</p>
<ul>
<li>打印机每次只能打印由 <strong>同一个字符</strong> 组成的序列。</li>
<li>每次可以在任意起始和结束位置打印新字符，并且会覆盖掉原来已有的字符。</li>
</ul>
<p>给你一个字符串 <code>s</code> ，你的任务是计算这个打印机打印它需要的最少打印次数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;aaabbb&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：首先打印 &quot;aaa&quot; 然后打印 &quot;bbb&quot;。</span><br></pre></td></tr></table></figure>
<p>思路：动态规划，<code>dp[i][j]</code>代表i到j至少需要打印的次数。</p>
<p>首先压缩字符串。aaabbb等价于ab，连续相同的字符串可以看做一个字符</p>
<p>推导<code>dp[i][j]</code>，</p>
<p>当<code>i==j</code>时显然等于1</p>
<p>当<code>s[i]==s[j]</code>时在打印<code>i</code>时可以打印<code>j</code>，所以<code>dp[i][j]=dp[i][j-1]</code></p>
<p>当<code>s[i]!=s[j]</code>时，可以将<code>i-j</code>分割为 <code>i-k</code>和<code>k-j</code>(i&lt;=k&lt;j)</p>
<p>后往前推版本</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strangePrinter</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="keyword">char</span> pre=s[<span class="number">0</span>];</span><br><span class="line">        str.push_back(pre);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;s.size();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==pre)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            pre=s[i];</span><br><span class="line">            str.push_back(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(s,str);	<span class="comment">//压缩s</span></span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;	<span class="comment">//从后往前推导</span></span><br><span class="line">            dp[i][i] = <span class="number">1</span>;<span class="comment">//长度1的都为1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123; 	<span class="comment">//j往后拓展</span></span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>];	<span class="comment">//j-1在前一步推导过了</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> minn = INT_MAX;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt; j; k++) &#123;</span><br><span class="line">                        <span class="comment">//k+1&gt;i并且i&lt;k&lt;j所以都是推导过的</span></span><br><span class="line">                        <span class="comment">//分割成i-k和k+1-j的，找最小次数</span></span><br><span class="line">                        minn = min(minn, dp[i][k] + dp[k + <span class="number">1</span>][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    dp[i][j] = minn;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>向后推版本</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,INT_MAX/<span class="number">4</span>));</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;	<span class="comment">//右边界j往后推,右边界小于j的都被推导过</span></span><br><span class="line">           dp[j][j]=<span class="number">1</span>;			<span class="comment">//长度1的都为1</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=j<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)&#123;	<span class="comment">//i在j的基础上往前推，左边界小于j，大于i的都被推导过</span></span><br><span class="line">               <span class="keyword">if</span>(s[i]==s[j])	<span class="comment">//在给j打印的时候打印i</span></span><br><span class="line">                   dp[i][j]=dp[i+<span class="number">1</span>][j];	<span class="comment">//dp[i+1][j]是前一步推导</span></span><br><span class="line">               <span class="keyword">else</span>&#123;</span><br><span class="line">                   <span class="keyword">for</span>(<span class="keyword">int</span> k=j;k&gt;i;k--)</span><br><span class="line">                   	<span class="comment">//i&lt;k&lt;=j，所以k-1&lt;=j-1,dp[i][k-1]已经推导过</span></span><br><span class="line">                   	<span class="comment">//同理，i&lt;k, dp[k][j]也推导过</span></span><br><span class="line">                       dp[i][j]=min(dp[i][j],dp[i][k<span class="number">-1</span>]+dp[k][j]);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>根据长度推导</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,INT_MAX/<span class="number">4</span>));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)	<span class="comment">//长度1的都为1</span></span><br><span class="line">          dp[i][i]=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>;len&lt;=n;++len)&#123;			<span class="comment">//区间长度</span></span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=len<span class="number">-1</span>;j&lt;n;j++,i++)&#123;	<span class="comment">//保持[i,j]长度为len</span></span><br><span class="line">              <span class="keyword">if</span>(s[i]==s[j]) </span><br><span class="line">                  <span class="comment">//i可以和i+1-j的左边界一起打印或者</span></span><br><span class="line">                  <span class="comment">//j可以和i-j-1的右边界一起打印</span></span><br><span class="line">                  dp[i][j]=min(dp[i+<span class="number">1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">              <span class="keyword">else</span>&#123;</span><br><span class="line">                  dp[i][j]=INT_MAX;</span><br><span class="line">                  <span class="comment">//i-k和k+1-j的长度肯定小于i-j,所以一定被推导过</span></span><br><span class="line">                  <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;j;++k)</span><br><span class="line">                      dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+<span class="number">1</span>][j]);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>递归版</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strangePrinter</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = str.size();</span><br><span class="line">        <span class="comment">//dp[i][j]表示从第i个字符到第j个字符（包括两端）需要的打印次数</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">1</span>,n,dp,str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; dp, <span class="built_in">string</span>&amp; str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[l][r] != <span class="number">-1</span>) <span class="keyword">return</span> dp[l][r];<span class="comment">//说明已经求得直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> dp[l][r] = <span class="number">0</span>;		<span class="comment">//无效区间</span></span><br><span class="line">        <span class="comment">//求区间l到r-1,最后打印r, r自己打印</span></span><br><span class="line">        <span class="keyword">int</span> res = helper(l, r - <span class="number">1</span>, dp, str) + <span class="number">1</span>;	</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> m = l; m &lt; r; ++m) &#123;</span><br><span class="line">            <span class="comment">//r到m打印加上m-1到i打印</span></span><br><span class="line">            <span class="keyword">if</span> (str[m<span class="number">-1</span>] == str[r<span class="number">-1</span>]) &#123;</span><br><span class="line">                res = min(res, helper(l, m - <span class="number">1</span>, dp, str) + helper(m, r - <span class="number">1</span>, dp, str));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[l][r] = res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><h3 id="easy-2"><a href="#easy-2" class="headerlink" title="easy"></a>easy</h3><h4 id="整数反转"><a href="#整数反转" class="headerlink" title="整数反转"></a><a href="https://leetcode-cn.com/problems/reverse-integer/">整数反转</a></h4><p>难度简单2799</p>
<p>给你一个 32 位的有符号整数 <code>x</code> ，返回将 <code>x</code> 中的数字部分反转后的结果。</p>
<p>如果反转后整数超过 32 位的有符号整数的范围 <code>[−231, 231 − 1]</code> ，就返回 0。</p>
<p><strong>假设环境不允许存储 64 位整数（有符号或无符号）。</strong></p>
<p> <strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x &#x3D; 123</span><br><span class="line">输出：321</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x &#x3D; -123</span><br><span class="line">输出：-321</span><br></pre></td></tr></table></figure>
<p>思路：将个十百千位依次读出，然后重新组成一个反转的数。</p>
<p>注意反转后可能溢出INT范围。</p>
<p>①在组成过程中，可以判断组成前的数是不是大于INT/10，大于的话，继续组下一位的时候就会溢出</p>
<p>②由于INT_MAX的个位是7,INT_MIN的个尾是8。</p>
<p>那么当x的最高位大于7并且x是与INT_MAX有相同的位数时，反转出来就会溢出。</p>
<p>但是这种情况在本题不存在，由于x是INT范围内的数，那么x与INT_MAX有相同的位数时，x的最高位必然只有1，2两种选择。</p>
<p>所以只有情况①才可能溢出。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ans&gt;INT_MAX/<span class="number">10</span>||ans&lt;INT_MIN/<span class="number">10</span>) <span class="comment">//溢出</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            ans*=<span class="number">10</span>;	<span class="comment">//腾出个位来</span></span><br><span class="line">            ans+=x%<span class="number">10</span>;	<span class="comment">//将x的末位添加到ans</span></span><br><span class="line">            x/=<span class="number">10</span>;		<span class="comment">//删除x的末位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="mindium"><a href="#mindium" class="headerlink" title="mindium"></a>mindium</h3><h4 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">顺时针打印矩阵</a></h4><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure>
<p><strong>限制：</strong></p>
<ul>
<li><code>0 &lt;= matrix.length &lt;= 100</code></li>
<li><code>0 &lt;= matrix[i].length &lt;= 100</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> m=matrix.size();</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">int</span> n=matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dir=&#123;n,m<span class="number">-1</span>,n<span class="number">-1</span>,m<span class="number">-2</span>&#125;;<span class="comment">//初始化第一圈要跳的步数</span></span><br><span class="line">        <span class="keyword">int</span> xx[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;	<span class="comment">//x的变化方向</span></span><br><span class="line">        <span class="keyword">int</span> yy[]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;	<span class="comment">//y的变化方向</span></span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">0</span>,y=<span class="number">-1</span>;	<span class="comment">//要先从外面跳进去</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)&#123;	<span class="comment">//决定现在的方向</span></span><br><span class="line">                <span class="keyword">if</span>(!dir[i]) <span class="keyword">return</span> ans;	<span class="comment">//不需要跳了，返回答案</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;dir[i];++j)&#123;<span class="comment">//开始跳dir[i]步</span></span><br><span class="line">                    x+=xx[i];</span><br><span class="line">                    y+=yy[i];</span><br><span class="line">                    ans.emplace_back(matrix[x][y]);</span><br><span class="line">                &#125;</span><br><span class="line">                dir[i]-=<span class="number">2</span>;<span class="comment">//内层每个方向要跳的步数减少二</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="把字符串转换成整数"><a href="#把字符串转换成整数" class="headerlink" title="把字符串转换成整数"></a><a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/">把字符串转换成整数</a></h4><p>写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。</p>
<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p>
<p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p>
<p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p>
<p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p>
<p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p>
<p><strong>说明：</strong></p>
<p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p>
<p>思路：模拟遍历。</p>
<p>判断越界的时候利用<strong>已获得的前缀和当前数字</strong>去比较INT最大最小值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strToInt</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> isNagetive=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(str[i]==<span class="string">&#x27; &#x27;</span>)i++;  <span class="comment">//跳过前面的空格,这里不会越界,因为最后有\n</span></span><br><span class="line">        <span class="keyword">if</span>(str[i]==<span class="string">&#x27;-&#x27;</span>)&#123;        <span class="comment">//负数</span></span><br><span class="line">            i++;</span><br><span class="line">            isNagetive=<span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[i]==<span class="string">&#x27;+&#x27;</span>)i++;   <span class="comment">//正数</span></span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;str.size();++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=str[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(tmp&lt;=<span class="number">9</span>&amp;&amp;tmp&gt;=<span class="number">0</span>)&#123; <span class="comment">//当前是数字</span></span><br><span class="line">                <span class="comment">/*现在的前缀大于最大(小)值前缀,或者现在的前缀等于最大(小)值前缀并且</span></span><br><span class="line"><span class="comment">                最后一位大于7的时候越界*/</span></span><br><span class="line">                <span class="keyword">if</span>(ans&gt;INT_MAX/<span class="number">10</span>||ans==INT_MAX/<span class="number">10</span>&amp;&amp;tmp&gt;<span class="number">7</span>)&#123; </span><br><span class="line">                    <span class="keyword">return</span> isNagetive?INT_MIN:INT_MAX;</span><br><span class="line">                &#125;</span><br><span class="line">                ans=ans*<span class="number">10</span>+tmp;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">break</span>;    <span class="comment">//遍历到不是数字了,返回答案</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isNagetive?-ans:ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="easy-3"><a href="#easy-3" class="headerlink" title="easy"></a>easy</h3><h4 id="叶子相似的树"><a href="#叶子相似的树" class="headerlink" title="叶子相似的树"></a><a href="https://leetcode-cn.com/problems/leaf-similar-trees/">叶子相似的树</a></h4><p>请考虑一棵二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个 <em>叶值序列</em> 。</p>
<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/16/tree.png" alt="img"></p>
<p>举个例子，如上图所示，给定一棵叶值序列为 <code>(6, 7, 4, 9, 8)</code> 的树。</p>
<p>如果有两棵二叉树的叶值序列是相同，那么我们就认为它们是 <em>叶相似</em> 的。</p>
<p>如果给定的两个根结点分别为 <code>root1</code> 和 <code>root2</code> 的树是叶相似的，则返回 <code>true</code>；否则返回 <code>false</code> 。</p>
<p>思路：前序遍历可以按左到右遍历这些叶结点，判断是不是叶结点按顺序加入数组，判断两次得到的数组是否相同得出答案。</p>
<p>时间复杂度O(n+m)n,m分别为两棵树的节点数</p>
<p>空间复杂度O(max(k1+n1,k2+n2))k1，k2分别为两棵树最大深度,n1,n2为叶值序列长度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">leafSimilar</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1,v2;</span><br><span class="line">        preorder(root1,v1);</span><br><span class="line">        preorder(root2,v2);</span><br><span class="line">        <span class="keyword">return</span> v1==v2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode* root,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        preorder(root-&gt;left,v);</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left&amp;&amp;!root-&gt;right)</span><br><span class="line">            v.emplace_back(root-&gt;val);</span><br><span class="line">        preorder(root-&gt;right,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/">二叉搜索树的最近公共祖先</a></h4><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p><a href="https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>
<p>例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png" alt="img"></p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 8</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span><br></pre></td></tr></table></figure>
<p>思路：总体来说是找一个节点，它的左树或者右树不同时包括p,q。所以当满足p,q不同时小于左节点或p,q不同时大于右节点，该节点就是所求。</p>
<p>递归版：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root==<span class="literal">NULL</span>) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val&lt;q-&gt;val&amp;&amp;root-&gt;val&gt;p-&gt;val||root-&gt;val&gt;q-&gt;val&amp;&amp;root-&gt;val&lt;p-&gt;val)</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(root==q||root==p)</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            TreeNode* l=lowestCommonAncestor(root-&gt;left,p,q);</span><br><span class="line">            TreeNode* r=lowestCommonAncestor(root-&gt;right,p,q);</span><br><span class="line">            <span class="keyword">return</span> (l==<span class="literal">NULL</span>)?r:l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非递归版：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(max(p-&gt;val,q-&gt;val)&lt;root-&gt;val)</span><br><span class="line">                root=root-&gt;left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(min(p-&gt;val,q-&gt;val)&gt;root-&gt;val)</span><br><span class="line">                root=root-&gt;right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>计数版：效率最低，找左子树和右子树和自己，共有多少个p,q节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode * ans=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        dfs(root,p,q);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root, TreeNode*&amp; p, TreeNode*&amp; q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l= dfs(root-&gt;left,p,q);</span><br><span class="line">        <span class="keyword">int</span> r= dfs(root-&gt;right,p,q);</span><br><span class="line">        <span class="keyword">int</span> count=l+r;</span><br><span class="line">        <span class="keyword">if</span>(root==q) count++;</span><br><span class="line">        <span class="keyword">if</span>(root==p) count++;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;root-&gt;val&lt;&lt;&quot; &quot;&lt;&lt;count&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">2</span>&amp;&amp;ans==<span class="literal">NULL</span>) ans=root; </span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="medium-3"><a href="#medium-3" class="headerlink" title="medium"></a>medium</h3><h4 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">树的子结构</a></h4><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p>
<p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p>
<p>思路：遍历找到A树所有B树根节点相同值的节点，以A树上的节点作头节点（A‘树），同时遍历A‘树和B树判断B是不是A‘的子结构。</p>
<p>另外的思路：bfs找A树所有B树根节点相同值的节点，再判断。</p>
<p>时间复杂度：O(MN)M为A的节点数，N为B的节点数</p>
<p>空间复杂度：O(M),当树 A 和树 B 都退化为链表时，递归调用深度最大。当 M ≤N 时，遍历树 A 与递归判断的总递归深度为 M ；当 M&gt;N 时，最差情况为遍历至树 A 叶子节点，此时总递归深度为 M。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!A||!B)<span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">//因为B为空不是子结构，而且A为空时，必没有子结构</span></span><br><span class="line">        <span class="comment">//判断A，B树是不是同根的子结构或者看看A的左子树和右子树有没有B的子结构</span></span><br><span class="line">        <span class="keyword">return</span> isSame(A,B)||isSubStructure(A-&gt;left,B)||isSubStructure(A-&gt;right,B);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSame</span><span class="params">(TreeNode* a,TreeNode* b)</span></span>&#123;</span><br><span class="line">        <span class="comment">//实际是遍历B树与A对应</span></span><br><span class="line">        <span class="keyword">if</span>(b==<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//当前节点相同时，继续判断左右子树</span></span><br><span class="line">        <span class="keyword">if</span>(a&amp;&amp;b&amp;&amp;a-&gt;val==b-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> isSame(a-&gt;left,b-&gt;left)&amp;&amp;isSame(a-&gt;right,b-&gt;right);</span><br><span class="line">        <span class="comment">//当A先为空时，或者A与B不同时，返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>超级压缩版</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> A&amp;&amp;B&amp;&amp;(isSame(A,B)||isSubStructure(A-&gt;left,B)||isSubStructure(A-&gt;right,B));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSame</span><span class="params">(TreeNode* a,TreeNode* b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!b)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(a&amp;&amp;a-&gt;val==b-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> isSame(a-&gt;left,b-&gt;left)&amp;&amp;isSame(a-&gt;right,b-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">二叉树中和为某一值的路径</a></h4><p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p>
<p><strong>示例:</strong><br>给定如下二叉树，以及目标和 <code>target = 22</code>，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      5</span><br><span class="line">     &#x2F; \</span><br><span class="line">    4   8</span><br><span class="line">   &#x2F;   &#x2F; \</span><br><span class="line">  11  13  4</span><br><span class="line"> &#x2F;  \    &#x2F; \</span><br><span class="line">7    2  5   1</span><br></pre></td></tr></table></figure>
<p>返回:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">   [5,4,11,2],</span><br><span class="line">   [5,8,4,5]</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>思路：简单的回溯，记录路径累积值和路径，当target与累计值相同时，保存路径。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;ans;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pathSum(TreeNode* root, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        dfs(root,<span class="number">0</span>,target,tmp);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root,<span class="keyword">int</span> curval,<span class="keyword">int</span> target,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp)</span></span>&#123;	</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">nullptr</span>&amp;&amp;root-&gt;right==<span class="literal">nullptr</span>)&#123;		<span class="comment">//叶结点</span></span><br><span class="line">            <span class="keyword">if</span>(target==curval+root-&gt;val)&#123;</span><br><span class="line">                tmp.emplace_back(root-&gt;val);				<span class="comment">//加入叶结点</span></span><br><span class="line">                ans.emplace_back(tmp);						<span class="comment">//保存路径</span></span><br><span class="line">                tmp.pop_back();								<span class="comment">//回溯</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ; </span><br><span class="line">        &#125;</span><br><span class="line">        tmp.emplace_back(root-&gt;val);				<span class="comment">//加入当前结点</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)dfs(root-&gt;left,curval+root-&gt;val,target,tmp);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)dfs(root-&gt;right,curval+root-&gt;val,target,tmp);</span><br><span class="line">        tmp.pop_back();			<span class="comment">//回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/">二叉搜索树与双向链表</a></h4><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p>
<p>思路：中序遍历，将前一个节点的右节点指向当前遍历节点，当前遍历节点的左节点指向前一个节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        dfs(root);	中序遍历</span><br><span class="line">        <span class="keyword">if</span>(head)&#123;	<span class="comment">//如果有链表头结点</span></span><br><span class="line">            head-&gt;left=pre;	<span class="comment">//链表头结点右孩子指向最后遍历的节点</span></span><br><span class="line">            pre-&gt;right=head;<span class="comment">//最后遍历的节点左孩子指向链表头结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//pre前一个遍历的节点，head链表头结点</span></span><br><span class="line">    Node*pre =<span class="literal">nullptr</span>,*head=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> ;</span><br><span class="line">        dfs(root-&gt;left);</span><br><span class="line">        root-&gt;left=pre;	<span class="comment">//当前遍历节点的左节点指向前一个节点</span></span><br><span class="line">        <span class="comment">//前一个节点的右节点指向当前遍历节点</span></span><br><span class="line">        <span class="comment">//pre为空，root就是链表头结点</span></span><br><span class="line">        <span class="keyword">if</span>(pre)pre-&gt;right=root;</span><br><span class="line">        <span class="keyword">else</span> head=root;</span><br><span class="line">        pre=root;</span><br><span class="line">        dfs(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="最小高度树"><a href="#最小高度树" class="headerlink" title="最小高度树"></a><a href="https://leetcode-cn.com/problems/minimum-height-trees/">最小高度树</a></h4><p>难度中等332</p>
<p>树是一个无向图，其中任何两个顶点只通过一条路径连接。 换句话说，一个任何没有简单环路的连通图都是一棵树。</p>
<p>给你一棵包含 <code>n</code> 个节点的树，标记为 <code>0</code> 到 <code>n - 1</code> 。给定数字 <code>n</code> 和一个有 <code>n - 1</code> 条无向边的 <code>edges</code> 列表（每一个边都是一对标签），其中 <code>edges[i] = [ai, bi]</code> 表示树中节点 <code>ai</code> 和 <code>bi</code> 之间存在一条无向边。</p>
<p>可选择树中任何一个节点作为根。当选择节点 <code>x</code> 作为根节点时，设结果树的高度为 <code>h</code> 。在所有可能的树中，具有最小高度的树（即，<code>min(h)</code>）被称为 <strong>最小高度树</strong> 。</p>
<p>请你找到所有的 <strong>最小高度树</strong> 并按 <strong>任意顺序</strong> 返回它们的根节点标签列表。</p>
<p>树的 <strong>高度</strong> 是指根节点和叶子节点之间最长向下路径上边的数量。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/09/01/e1.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 4, edges &#x3D; [[1,0],[1,2],[1,3]]</span><br><span class="line">输出：[1]</span><br><span class="line">解释：如图所示，当根是标签为 1 的节点时，树的高度是 1 ，这是唯一的最小高度树。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 1, edges &#x3D; []</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>
<p>快速翻译一下题目就是选树中的一个节点当根节点，使得树有最小高度。</p>
<p>其实就是找树中最长路径的中点。</p>
<p>思路：先组成一个图，层次遍历，将连接的节点的入度减一,将所有入度1的节点入队。直到最后一层。最后一层就是答案。答案最多两个元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findMinHeightTrees</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">indegree</span><span class="params">(n)</span></span>;<span class="comment">//入度表</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; relations(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());<span class="comment">//邻接表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edges.size();++i)&#123;	<span class="comment">//初始化入度表和邻接表</span></span><br><span class="line">            relations[edges[i][<span class="number">1</span>]].emplace_back(edges[i][<span class="number">0</span>]);</span><br><span class="line">            relations[edges[i][<span class="number">0</span>]].emplace_back(edges[i][<span class="number">1</span>]);</span><br><span class="line">            ++indegree[edges[i][<span class="number">0</span>]];</span><br><span class="line">            ++indegree[edges[i][<span class="number">1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;indegree.size();++i)&#123;<span class="comment">//将入度为1的节点入队</span></span><br><span class="line">            <span class="keyword">if</span>(indegree[i]&lt;=<span class="number">1</span>)<span class="comment">//注意这里包含了一个节点的树</span></span><br><span class="line">                que.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> levelsize=que.size();</span><br><span class="line">            ans.clear();<span class="comment">//清空上一层的结果</span></span><br><span class="line">            <span class="keyword">while</span>(levelsize--)&#123;  <span class="comment">//层次遍历</span></span><br><span class="line">                <span class="keyword">int</span> tmp=que.front();</span><br><span class="line">                que.pop();</span><br><span class="line">                ans.emplace_back(tmp);		<span class="comment">//记录本层</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;relations[tmp].size();++i)&#123;<span class="comment">//tmp连接的节点的入度减一</span></span><br><span class="line">                    --indegree[relations[tmp][i]];</span><br><span class="line">                    <span class="keyword">if</span>(indegree[relations[tmp][i]]==<span class="number">1</span>)&#123;</span><br><span class="line">                        que.push(relations[tmp][i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="hard-2"><a href="#hard-2" class="headerlink" title="hard"></a>hard</h3><h4 id="二叉树中的最大路径和"><a href="#二叉树中的最大路径和" class="headerlink" title=" 二叉树中的最大路径和"></a><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/"> 二叉树中的最大路径和</a></h4><p><strong>路径</strong> 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点。</p>
<p><strong>路径和</strong> 是路径中各节点值的总和。</p>
<p>给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> 。</p>
<p>思路：每个节点root设定一个贡献值，该贡献值为含义为：root的子树的路径的最大路径和，并且这个路径的端点为root。</p>
<p>也就是在该节点的子树下找一条路径，满足以下两个条件</p>
<p>路径的一个端点必须是该节点</p>
<p>这条路径的路径和最大</p>
<p>这条路径的路径和就是贡献值。</p>
<p>那么在cur节点，可以知道，是否要选左路径或者右路径或者两个都不选，</p>
<p>通过他们的贡献值而定，如果路径贡献值为负数，但就不选。</p>
<p>左右路径都为负，那就只有cur节点作为一个路径。</p>
<p>设定一个ans变量储存最大值，只要遍历所有的节点，就可以记录下来所有的子树最大值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans=INT_MIN;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)		<span class="comment">//空树贡献值为0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftval = max(dfs(root -&gt; left), <span class="number">0</span>);<span class="comment">//选不选左子树</span></span><br><span class="line">        <span class="keyword">int</span> rightval = max(dfs(root -&gt; right), <span class="number">0</span>);<span class="comment">//选不选右子树</span></span><br><span class="line">        <span class="comment">//当前树的最大值跟历史最大值比较</span></span><br><span class="line">        ans = max(ans, leftval + rightval + root -&gt; val);</span><br><span class="line">        <span class="comment">//返回贡献值，注意要保持root是端点，所以只能选左右子树其中最大的路径</span></span><br><span class="line">        <span class="keyword">return</span> root -&gt; val + max(leftval, rightval);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="hard-3"><a href="#hard-3" class="headerlink" title="hard"></a>hard</h3><h4 id="寻找两个正序数组的中位数"><a href="#寻找两个正序数组的中位数" class="headerlink" title="寻找两个正序数组的中位数"></a><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">寻找两个正序数组的中位数</a></h4><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 &#x3D; [1,3], nums2 &#x3D; [2]</span><br><span class="line">输出：2.00000</span><br><span class="line">解释：合并数组 &#x3D; [1,2,3] ，中位数 2</span><br></pre></td></tr></table></figure>
<p>思路：找出两个数组中第k小的数来代替找中位数。（两个数组长度总和为偶数则找第k和k+1个数，否则找第k+1个数（k=(len1+len2)/2））。</p>
<p>这里两个数组找第k小的元素的方法是：</p>
<p>从数组1找从index1开始第k/2个的数。</p>
<p>从数组2找从index2开始第k/2个的数。</p>
<p>比较大小，小于等于的那一行的可以排除是第k小的可能性。（因为它最多大于k-2个元素）</p>
<p>怎么排除？</p>
<p>修改相应index（index1，index2）index修改为newindex+1，还有k要减去减去元素的数量。</p>
<p>一直遍历，会出现2种情况。</p>
<p>情况1：找完了其中一个数组，还没找到第k小元素。也就是其中有一个数组所有元素都比第k小元素小。</p>
<p>这时候直接找长数组的index+k个元素就是所求。</p>
<p>情况2：k==1，说明找到了，直接拿最小的index的数。（这里肯定会剩一个以上，因为只会排除小于等于的那一行，另一行必然剩一个以上）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getKthnum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums1.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> m=nums2.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> index1=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(index1==n+<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> nums2[index2+k<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(index2==m+<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> nums1[index1+k<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(k==<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> min(nums1[index1],nums2[index2]);</span><br><span class="line">            <span class="keyword">int</span> newindex1=min(n,index1+k/<span class="number">2</span><span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">int</span> newindex2=min(m,index2+k/<span class="number">2</span><span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span>(nums1[newindex1]&gt;=nums2[newindex2])&#123;</span><br><span class="line">                k-=newindex2-index2+<span class="number">1</span>;</span><br><span class="line">                index2=newindex2+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                k-=newindex1-index1+<span class="number">1</span>;</span><br><span class="line">                index1=newindex1+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=nums1.size()+nums2.size();</span><br><span class="line">        <span class="keyword">if</span>(count%<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> getKthnum(nums1,nums2,count/<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (getKthnum(nums1,nums2,count/<span class="number">2</span>)+getKthnum(nums1,nums2,count/<span class="number">2</span>+<span class="number">1</span>))/<span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">数组中的逆序对</a></h4><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,5,6,4]</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure>
<p>思路1：在归并排序的过程中记录有多少逆序对。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>num1</th>
<th>num2</th>
<th>nums</th>
<th>逆序对数</th>
</tr>
</thead>
<tbody>
<tr>
<td>[9, 26, 55, 64, 91]</td>
<td>[8, 12, 16, 22, 100]</td>
<td>[]</td>
<td>0</td>
</tr>
<tr>
<td>[9, 26, 55, 64, 91]</td>
<td>[12, 16, 22, 100]</td>
<td>[8]</td>
<td>0+nums1.size()=5</td>
</tr>
<tr>
<td>[26, 55, 64, 91]</td>
<td>[12, 16, 22, 100]</td>
<td>[8,9]</td>
<td>5</td>
</tr>
<tr>
<td>[26, 55, 64, 91]</td>
<td>[16, 22, 100]</td>
<td>[8,9,12]</td>
<td>5+nums1.size()=9</td>
</tr>
<tr>
<td>[26, 55, 64, 91]</td>
<td>[22, 100]</td>
<td>[8,9,12,16]</td>
<td>9+num1.size()=13</td>
</tr>
<tr>
<td>[26, 55, 64, 91]</td>
<td>[100]</td>
<td>[8,9,12,16,22]</td>
<td>13+=num1.size()=17</td>
</tr>
<tr>
<td>[55, 64, 91]</td>
<td>[100]</td>
<td>[8,9,12,16,22,26]</td>
<td>17</td>
</tr>
<tr>
<td>[64, 91]</td>
<td>[100]</td>
<td>[8,9,12,16,22,26,55]</td>
<td>17</td>
</tr>
<tr>
<td>[91]</td>
<td>[100]</td>
<td>[8,9,12,16,22,26,55,64]</td>
<td>17</td>
</tr>
<tr>
<td>[]</td>
<td>[100]</td>
<td>[8,9,12,16,22,26,55,64,91]</td>
<td>17</td>
</tr>
<tr>
<td>[]</td>
<td>[]</td>
<td>[8,9,12,16,22,26,55,64,91,100]</td>
<td>17+num1.size()=17</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">tmp</span><span class="params">(nums.size())</span></span>;		<span class="comment">//辅助数组</span></span><br><span class="line">        <span class="keyword">return</span> getPairscount(nums,tmp,<span class="number">0</span>,nums.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPairscount</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;=right) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> lcount=getPairscount(nums,tmp,left,mid);	<span class="comment">//获取左区间逆序对数</span></span><br><span class="line">        <span class="keyword">int</span> rcount=getPairscount(nums,tmp,mid+<span class="number">1</span>,right);	<span class="comment">//获取右区间逆序对数</span></span><br><span class="line">        <span class="keyword">int</span> count =merge(nums,tmp,left,mid,right);		<span class="comment">//合并当前区间的逆序对数</span></span><br><span class="line">        <span class="keyword">return</span> lcount+rcount+count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index=left,start1=left,start2=mid+<span class="number">1</span>,end1=mid,end2=right;</span><br><span class="line">        <span class="keyword">while</span>(index&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(start1==end1+<span class="number">1</span>)</span><br><span class="line">                tmp[index++]=nums[start2++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(start2==end2+<span class="number">1</span>||nums[start1]&lt;=nums[start2])&#123;</span><br><span class="line">                tmp[index++]=nums[start1++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tmp[index++]=nums[start2++];</span><br><span class="line">                count+=end1-start1+<span class="number">1</span>;		<span class="comment">//将num1剩余的元素个数加入count</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        copy(tmp.begin()+left,tmp.begin()+right+<span class="number">1</span>,nums.begin()+left);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h3 id="medium-4"><a href="#medium-4" class="headerlink" title="medium"></a>medium</h3><h4 id="制作-m-束花所需的最少天数"><a href="#制作-m-束花所需的最少天数" class="headerlink" title="制作 m 束花所需的最少天数"></a><a href="https://leetcode-cn.com/problems/minimum-number-of-days-to-make-m-bouquets/">制作 m 束花所需的最少天数</a></h4><p>给你一个整数数组 <code>bloomDay</code>，以及两个整数 <code>m</code> 和 <code>k</code> 。</p>
<p>现需要制作 <code>m</code> 束花。制作花束时，需要使用花园中 <strong>相邻的 <code>k</code> 朵花</strong> 。</p>
<p>花园中有 <code>n</code> 朵花，第 <code>i</code> 朵花会在 <code>bloomDay[i]</code> 时盛开，<strong>恰好</strong> 可以用于 <strong>一束</strong> 花中。</p>
<p>请你返回从花园中摘 <code>m</code> 束花需要等待的最少的天数。如果不能摘到 <code>m</code> 束花则返回 <strong>-1</strong> 。</p>
<p>思路：对bloomDay数组范围二分，寻找满足条件的一个天数。</p>
<p>注意找到可行解后，可能还有更优解。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; bloomDay, <span class="keyword">int</span> m, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> right=*max_element(bloomDay.begin(),bloomDay.end());</span><br><span class="line">        <span class="keyword">int</span> left=*min_element(bloomDay.begin(),bloomDay.end());</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> bloomcount=<span class="number">0</span>,conbloom=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bloomDay.size();++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(bloomDay[i]&lt;=mid)&#123;</span><br><span class="line">                    ++conbloom;</span><br><span class="line">                    <span class="keyword">if</span>(conbloom==k)&#123;</span><br><span class="line">                        conbloom=<span class="number">0</span>;</span><br><span class="line">                        ++bloomcount;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    conbloom=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(bloomcount&gt;=m)&#123;</span><br><span class="line">                ans=mid;</span><br><span class="line">                right=mid<span class="number">-1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bloomcount&lt;m)&#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right=mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="回文"><a href="#回文" class="headerlink" title="回文"></a>回文</h2><h3 id="easy-4"><a href="#easy-4" class="headerlink" title="easy"></a>easy</h3><h4 id="回文数"><a href="#回文数" class="headerlink" title="回文数"></a><a href="https://leetcode-cn.com/problems/palindrome-number/">回文数</a></h4><p>给你一个整数 <code>x</code> ，如果 <code>x</code> 是一个回文整数，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，<code>121</code> 是回文，而 <code>123</code> 不是。</p>
<p> <strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x &#x3D; 121</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x &#x3D; -121</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p>思路1：先转字符串，然后前后判断。</p>
<p>思路2：把后面一半的数拿出来倒过来组成新的数，看看是不是与前面半段相等。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>||x%<span class="number">10</span>==<span class="number">0</span>&amp;&amp;x!=<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//非0的末尾位是0的数和负数</span></span><br><span class="line">        <span class="built_in">string</span> str=to_string(x);</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=str.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(;l&lt;r;++l,--r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[l]!=str[r])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>||x%<span class="number">10</span>==<span class="number">0</span>&amp;&amp;x!=<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> reverseNum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(reverseNum&lt;x)&#123;		<span class="comment">//一直判断到中间</span></span><br><span class="line">            reverseNum*=<span class="number">10</span>;			<span class="comment">//先空出个位</span></span><br><span class="line">            reverseNum+=x%<span class="number">10</span>;		<span class="comment">//取x的最后一位</span></span><br><span class="line">            x/=<span class="number">10</span>;					<span class="comment">//去掉x最后一位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reverseNum==x||(reverseNum/<span class="number">10</span>==x);<span class="comment">//偶数和单数个数字</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="验证回文串"><a href="#验证回文串" class="headerlink" title="验证回文串"></a><a href="https://leetcode-cn.com/problems/valid-palindrome/">验证回文串</a></h4><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p>
<p><strong>说明：</strong>本题中，我们将空字符串定义为有效的回文串。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p>思路1：直接存反转后的判断二者是不是相等。</p>
<p>时间复杂度O（N）</p>
<p>空间复杂度O（N）</p>
<p>思路2：双指针</p>
<p>双指针放在前后，往中间判断，不同就返回false。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">       <span class="built_in">string</span> alnumstr=<span class="string">&quot;&quot;</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">auto</span> ch:s)&#123;</span><br><span class="line">           <span class="keyword">if</span>(<span class="built_in">isalnum</span>(ch))</span><br><span class="line">                alnumstr+=<span class="built_in">toupper</span>(ch);</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="comment">/* string str_rev=alnumstr;      </span></span><br><span class="line"><span class="comment">     * reverse(str_rev.begin(),str_rev.end());  //反转</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">str_rev</span><span class="params">(alnumstr.rbegin(), alnumstr.rend())</span></span>; <span class="comment">//反转</span></span><br><span class="line">        <span class="keyword">return</span> str_rev==alnumstr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=s.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r&amp;&amp;!<span class="built_in">isalnum</span>(s[l]))++l;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r&amp;&amp;!<span class="built_in">isalnum</span>(s[r]))--r;</span><br><span class="line">            <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">toupper</span>(s[l])!=<span class="built_in">toupper</span>(s[r]))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                l++;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h2><h3 id="medium-5"><a href="#medium-5" class="headerlink" title="medium"></a>medium</h3><h4 id="解码异或后的排列"><a href="#解码异或后的排列" class="headerlink" title="解码异或后的排列"></a><a href="https://leetcode-cn.com/problems/decode-xored-permutation/">解码异或后的排列</a></h4><p>给你一个整数数组 <code>perm</code> ，它是前 <code>n</code> 个正整数的排列，且 <code>n</code> 是个 <strong>奇数</strong> 。</p>
<p>它被加密成另一个长度为 <code>n - 1</code> 的整数数组 <code>encoded</code> ，满足 <code>encoded[i] = perm[i] XOR perm[i + 1]</code> 。比方说，如果 <code>perm = [1,3,2]</code> ，那么 <code>encoded = [2,1]</code> 。</p>
<p>给你 <code>encoded</code> 数组，请你返回原始数组 <code>perm</code> 。题目保证答案存在且唯一。</p>
<p> <strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：encoded &#x3D; [3,1]</span><br><span class="line">输出：[1,2,3]</span><br><span class="line">解释：如果 perm &#x3D; [1,2,3] ，那么 encoded &#x3D; [1 XOR 2,2 XOR 3] &#x3D; [3,1]</span><br></pre></td></tr></table></figure>
<p>思路：先求出1-n的异或allxor。allxor=encoded[0]^encoded[1]^encoded[2]····^encoded[n-1] ①</p>
<p>perm[0]=encoded[0]^encoded[1]</p>
<p>perm[1]=encoded[1]^encoded[2]  ②</p>
<p>perm[3]=encoded[3]^encoded[4]  ③</p>
<p>perm[5]=encoded[5]^encoded[6]  ④</p>
<p>将②③④等奇数序号perm代入①得</p>
<p>allxor=encoded[0]^perm[1]^perm[3]^perm[5]·······</p>
<p>求出xor1toN=perm[1]^perm[3]^perm[5]·······</p>
<p>那么encoded[0]=xor1toN^allxor</p>
<p>由encoded[0]^encoded[1]=perm[0]得</p>
<p>encoded[1]=encoded[0]^perm[0]。</p>
<p>如此类推。</p>
<p>注意前1-n的异或可以O（1）得出</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(n%<span class="number">4</span>)&#123;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">0</span>:allxor=n+<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">1</span>:allxor=<span class="number">1</span>;  <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">2</span>:allxor=n+<span class="number">2</span>;<span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">3</span>:allxor=<span class="number">0</span>;  <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>拓展：同理 k-n的连续异或(knxor)也可以由1-k的异或(kxor)和1-n(nxor)的异或求出。</p>
<p>knxor=kxor^nxor</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">decode</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; encoded)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> allxor=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// for(int i=1;i&lt;=encoded.size()+1;i++)	</span></span><br><span class="line">        <span class="comment">//     allxor^=i;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n=encoded.size()+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">switch</span>(n%<span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:allxor=n+<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:allxor=<span class="number">1</span>;  <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:allxor=n+<span class="number">2</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:allxor=<span class="number">0</span>;  <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> xor1toN=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;encoded.size();i+=<span class="number">2</span>)</span><br><span class="line">            xor1toN^=encoded[i];</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> tmp=allxor^xor1toN;</span><br><span class="line">        ans.emplace_back(tmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:encoded)</span><br><span class="line">            ans.emplace_back(tmp^=x);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="找出第-K-大的异或坐标值"><a href="#找出第-K-大的异或坐标值" class="headerlink" title="找出第 K 大的异或坐标值"></a><a href="https://leetcode-cn.com/problems/find-kth-largest-xor-coordinate-value/">找出第 K 大的异或坐标值</a></h4><p>给你一个二维矩阵 <code>matrix</code> 和一个整数 <code>k</code> ，矩阵大小为 <code>m x n</code> 由非负整数组成。</p>
<p>矩阵中坐标 <code>(a, b)</code> 的 <strong>值</strong> 可由对所有满足 <code>0 &lt;= i &lt;= a &lt; m</code> 且 <code>0 &lt;= j &lt;= b &lt; n</code> 的元素 <code>matrix[i][j]</code>（<strong>下标从 0 开始计数</strong>）执行异或运算得到。</p>
<p>请你找出 <code>matrix</code> 的所有坐标中第 <code>k</code> 大的值（<strong><code>k</code> 的值从 1 开始计数</strong>）。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix &#x3D; [[5,2],[1,6]], k &#x3D; 1</span><br><span class="line">输出：7</span><br><span class="line">解释：坐标 (0,1) 的值是 5 XOR 2 &#x3D; 7 ，为最大的值。</span><br></pre></td></tr></table></figure>
<p>思路：要求异或坐标值需要左上角所有的元素（包括自己的行和列和自己）异或和。要求matrix [i] [j]时matrix [i-1] [j-1]和matrix [i-1] [j]和matrix [i] [j-1]都已经求得，而matrix [i] [j-1]和matrix [i-1] [j]区域重合了matrix [i-1] [j-1]的区域，所以要求matrix [i] [j]需要补上matrix [i-1] [j-1]区域所以得出</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matrix[i][j]=matrix[i][j]^matrix[i<span class="number">-1</span>][j]^matrix[i][j<span class="number">-1</span>]^matrix[i][j]</span><br></pre></td></tr></table></figure>
<p>然后就是求出第k大元素，用堆(nmlogk)或者快速选择算法（nm，最坏nm^2），或者排序（nmlognm）都可以。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthLargestValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m=matrix.size();</span><br><span class="line">        <span class="keyword">int</span> n=matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; helper;</span><br><span class="line">        helper.emplace_back(matrix[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;++i)&#123;		<span class="comment">//求第一列</span></span><br><span class="line">            matrix[i][<span class="number">0</span>]=matrix[i][<span class="number">0</span>]^matrix[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">            helper.emplace_back(matrix[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;		<span class="comment">//求第一行</span></span><br><span class="line">            matrix[<span class="number">0</span>][i]=matrix[<span class="number">0</span>][i]^matrix[<span class="number">0</span>][i<span class="number">-1</span>];</span><br><span class="line">            helper.emplace_back(matrix[<span class="number">0</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;++j)&#123;</span><br><span class="line">                matrix[i][j]^=matrix[i<span class="number">-1</span>][j]^matrix[i][j<span class="number">-1</span>]^matrix[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                helper.emplace_back(matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        nth_element(helper.begin(),helper.begin()+k<span class="number">-1</span>,helper.end(),greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">return</span> helper[k<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="hard-4"><a href="#hard-4" class="headerlink" title="hard"></a>hard</h3><h4 id="与数组中元素的最大异或值"><a href="#与数组中元素的最大异或值" class="headerlink" title="与数组中元素的最大异或值"></a><a href="https://leetcode-cn.com/problems/maximum-xor-with-an-element-from-array/">与数组中元素的最大异或值</a></h4><p>给你一个由非负整数组成的数组 <code>nums</code> 。另有一个查询数组 <code>queries</code> ，其中 <code>queries[i] = [xi, mi]</code> 。</p>
<p>第 <code>i</code> 个查询的答案是 <code>xi</code> 和任何 <code>nums</code> 数组中不超过 <code>mi</code> 的元素按位异或（<code>XOR</code>）得到的最大值。换句话说，答案是 <code>max(nums[j] XOR xi)</code> ，其中所有 <code>j</code> 均满足 <code>nums[j] &lt;= mi</code> 。如果 <code>nums</code> 中的所有元素都大于 <code>mi</code>，最终答案就是 <code>-1</code> 。</p>
<p>返回一个整数数组 <code>answer</code> 作为查询的答案，其中 <code>answer.length == queries.length</code> 且 <code>answer[i]</code> 是第 <code>i</code> 个查询的答案。</p>
<p>思路：用nums中元素二进制构建前缀树，在前缀树中尽可能的找最大异或值，每个节点存放该子树和自身的最小值，寻找的时候需要兼顾找最大异或和保持不大于mi（这个更优先）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> minsonval=INT_MAX;	<span class="comment">//该子树和自身的最小值</span></span><br><span class="line">        <span class="keyword">int</span> index;	<span class="comment">//如果是叶结点，就存放元素在nums的序号</span></span><br><span class="line">        inode* zero,* one;		<span class="comment">//子节点</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">prefixtree</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        inode* head;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        prefixtree()&#123;</span><br><span class="line">            head=<span class="keyword">new</span> inode();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">insertNode</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> index)</span></span>&#123;	<span class="comment">//插入nums[index]</span></span><br><span class="line">            inode* cur=head;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">30</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp=(nums[index]/(<span class="number">1</span>&lt;&lt;i))&amp;<span class="number">1</span>;		<span class="comment">//从最高位依次取位</span></span><br><span class="line">                <span class="keyword">if</span>(tmp==<span class="number">1</span>)&#123;		<span class="comment">//建树</span></span><br><span class="line">                    <span class="keyword">if</span>(!cur-&gt;one)cur-&gt;one=<span class="keyword">new</span> inode();</span><br><span class="line">                    cur-&gt;minsonval=min(cur-&gt;minsonval,nums[index]);</span><br><span class="line">                    cur=cur-&gt;one;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!cur-&gt;zero)cur-&gt;zero=<span class="keyword">new</span> inode();</span><br><span class="line">                    cur-&gt;minsonval=min(cur-&gt;minsonval,nums[index]);</span><br><span class="line">                    cur=cur-&gt;zero;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cur-&gt;minsonval=nums[index]; <span class="comment">//cur==叶结点</span></span><br><span class="line">            cur-&gt;index=index;	<span class="comment">//存放序号</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找x和nums中小于m的元素异或的最大值</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">searchMAXXOR</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> x,<span class="keyword">int</span> m)</span></span>&#123;	</span><br><span class="line">            inode* cur=head;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">30</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp=(x/(<span class="number">1</span>&lt;&lt;i))&amp;<span class="number">1</span>;<span class="comment">//x从最高位依次取位</span></span><br><span class="line">                inode* tmpcur=cur;	<span class="comment">//保存cur指针</span></span><br><span class="line">                <span class="keyword">if</span>(tmp==<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">//先判断是否为空，再判断是否小于m,优先看与tmp相反的zero，下同</span></span><br><span class="line">                    <span class="keyword">if</span>(cur-&gt;zero&amp;&amp;cur-&gt;zero-&gt;minsonval&lt;=m) cur=cur-&gt;zero;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(cur-&gt;one&amp;&amp;cur-&gt;one-&gt;minsonval&lt;=m)cur=cur-&gt;one;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                     <span class="keyword">if</span>(cur-&gt;one&amp;&amp;cur-&gt;one-&gt;minsonval&lt;=m)cur=cur-&gt;one;</span><br><span class="line">                     <span class="keyword">else</span> <span class="keyword">if</span>(cur-&gt;zero&amp;&amp;cur-&gt;zero-&gt;minsonval&lt;=m) cur=cur-&gt;zero;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur==tmpcur) <span class="keyword">return</span> <span class="number">-1</span>;	<span class="comment">//cur没有改变，说明没有满足小于m的数</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> nums[cur-&gt;index]^x;	<span class="comment">//到了叶结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maximizeXor</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        prefixtree tree;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();++i)</span><br><span class="line">            tree.insertNode(nums,i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; query:queries)</span><br><span class="line">            ans.emplace_back(tree.searchMAXXOR(nums,query[<span class="number">0</span>],query[<span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h2><h3 id="medium-6"><a href="#medium-6" class="headerlink" title="medium"></a>medium</h3><h4 id="数组中两个数的最大异或值"><a href="#数组中两个数的最大异或值" class="headerlink" title="数组中两个数的最大异或值"></a><a href="https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/">数组中两个数的最大异或值</a></h4><p>给你一个整数数组 <code>nums</code> ，返回 <code>nums[i] XOR nums[j]</code> 的最大运算结果，其中 <code>0 ≤ i ≤ j &lt; n</code> 。</p>
<p><strong>进阶：</strong>你可以在 <code>O(n)</code> 的时间解决这个问题吗？</p>
<p> <strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [3,10,5,25,2,8]</span><br><span class="line">输出：28</span><br><span class="line">解释：最大运算结果是 5 XOR 25 &#x3D; 28.</span><br></pre></td></tr></table></figure>
<p>思路：由于题目是选两个数异或，而且还可以选自己跟自己异或所以下界是0。</p>
<p>本题可以使用字典树（前缀树）来做。</p>
<p>将每个数字转成字符串然后从最高位开始存。</p>
<p>构造一个32位树高的前缀树(含一个头节点)。</p>
<p>然后遍历数组想办法从树里找到尽可能每一位跟当前遍历到的数（x）相反的数(y)。</p>
<p>比如101要尽力去找010。</p>
<p>然后比较每一个x^y,找出最大值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span>	<span class="comment">//树的节点</span></span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">-1</span>;	<span class="comment">//叶结点会存放在nums数组的序号</span></span><br><span class="line">        node* zero;</span><br><span class="line">        node* one;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">prefixTree</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        node* top;	<span class="comment">//头结点</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        prefixTree()&#123;</span><br><span class="line">            top=<span class="keyword">new</span> node();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> index)</span></span>&#123;<span class="comment">//num加入前缀树，index是num在nums的序号</span></span><br><span class="line">            node* cur=top;			<span class="comment">//当前处理的节点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">30</span>;i&gt;=<span class="number">0</span>;i--)&#123;	.<span class="comment">//从最高位开始找</span></span><br><span class="line">                <span class="keyword">int</span> tmp=(num&gt;&gt;i)&amp;<span class="number">1</span>;	<span class="comment">//找到第i位的数  0或者1</span></span><br><span class="line">                <span class="keyword">if</span>(tmp==<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!cur-&gt;one)cur-&gt;one=<span class="keyword">new</span> node();	<span class="comment">//没有就构造,下面同理</span></span><br><span class="line">                    cur=cur-&gt;one;		<span class="comment">//更新cur</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!cur-&gt;zero)cur-&gt;zero=<span class="keyword">new</span> node();</span><br><span class="line">                    cur=cur-&gt;zero;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cur-&gt;index=index;	<span class="comment">//叶结点存放num在nums的序号。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">findMAXXORnum</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;	<span class="comment">//找到树里尽量每一位和num相反的数</span></span><br><span class="line">            node* cur=top;			<span class="comment">//当前处理的节点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">30</span>;i&gt;=<span class="number">0</span>;i--)&#123;	</span><br><span class="line">                <span class="keyword">int</span> tmp=(num&gt;&gt;i)&amp;<span class="number">1</span>;		<span class="comment">//找到num第i位的数  0或者1</span></span><br><span class="line">                <span class="keyword">if</span>(!cur-&gt;one&amp;&amp;!cur-&gt;zero)	<span class="comment">//叶结点返回找到的数在nums的序号</span></span><br><span class="line">                    <span class="keyword">return</span> cur-&gt;index;</span><br><span class="line">                <span class="keyword">if</span>(tmp==<span class="number">1</span>)&#123;			<span class="comment">//1的话转到0</span></span><br><span class="line">                    <span class="keyword">if</span>(cur-&gt;zero) cur=cur-&gt;zero; </span><br><span class="line">                    <span class="keyword">else</span> cur=cur-&gt;one;	<span class="comment">//没有0只能转1</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;				<span class="comment">//0的话转到1</span></span><br><span class="line">                    <span class="keyword">if</span>(cur-&gt;one)cur=cur-&gt;one;</span><br><span class="line">                    <span class="keyword">else</span> cur=cur-&gt;zero;	<span class="comment">//没有1只能转0</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cur-&gt;index;	<span class="comment">//叶结点返回找到的数在nums的序号</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        prefixTree tree;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)	<span class="comment">//将nums全部加入前缀树</span></span><br><span class="line">            tree.add(nums[i],i);</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;		<span class="comment">//下界是0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">int</span> index=tree.findMAXXORnum(num);<span class="comment">//找到树里尽量每一位和num相反的数</span></span><br><span class="line">            ans=max(ans,nums[index]^num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>思路2：int31位。从最高位开始找，如果可以设置为1就设置为1。</p>
<p>怎么判断可以设置1？</p>
<p>set存放数组里所有数的前K位。示例：xxxxx?????存放xxxxx</p>
<p>首先先设置为1</p>
<p>可以得到xxxx1????(前面是已经找到的最优解)截取前面的得到xxxx1</p>
<p>数组里其他截取前面的得到abcde</p>
<p>二者相与得到一个fghij，如果fghij在set中说明设置1是可行的。</p>
<p>不然只能设置为0</p>
<p>然后继续判断下一位。</p>
<p>为什么fghij在set中就说明设置1是可行的？</p>
<p>因为前面的fghi也可以在前k-1位set也可以找到。</p>
<p>由此类推。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">30</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; st;	<span class="comment">//存放nums中的每一个元素的前30-i位。</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> num:nums)&#123;</span><br><span class="line">                st.insert(num&gt;&gt;i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> tmp_ans=ans*<span class="number">2</span>+<span class="number">1</span>;	<span class="comment">//先设置为1</span></span><br><span class="line">            <span class="keyword">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">                <span class="keyword">if</span>(st.count(tmp_ans^(num&gt;&gt;i)))&#123;		<span class="comment">//找到了</span></span><br><span class="line">                    flag=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag) ans = tmp_ans;</span><br><span class="line">            <span class="keyword">else</span> ans = tmp_ans - <span class="number">1</span>;			<span class="comment">//没找到就取消设置为1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><h3 id="medium-7"><a href="#medium-7" class="headerlink" title="medium"></a>medium</h3><h4 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a><a href="https://leetcode-cn.com/problems/permutations/">全排列</a></h4><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <strong>所有可能的全排列</strong> 。你可以 <strong>按任意顺序</strong> 返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure>
<p>思路：简单的回溯，依次确定第i位的可能值。确定到最后一位就是一种解。</p>
<p>时间复杂度O（nn!）    </p>
<p>空间复杂度O（n）除了答案数组以外。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        len=nums.size();	</span><br><span class="line">        slove(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(len<span class="number">-1</span>==i)&#123;		<span class="comment">//判断到了最后一位</span></span><br><span class="line">            ans.emplace_back(nums);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;len;++j)&#123;</span><br><span class="line">            swap(nums[i],nums[j]);	<span class="comment">//将选中的后面的位跟现在i位交换</span></span><br><span class="line">            slove(nums,i+<span class="number">1</span>);		<span class="comment">//找i+1位后的全排列</span></span><br><span class="line">            swap(nums[i],nums[j]);	<span class="comment">//交换回去</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/">矩阵中的路径</a></h4><p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<p> <strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board &#x3D; [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word &#x3D; &quot;ABCCED&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p>思路：dfs搜索路径是否等于word，加入剪枝。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">4</span>]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;<span class="comment">//方向数组</span></span><br><span class="line">    <span class="keyword">int</span> dy[<span class="number">4</span>]&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> colsize=<span class="number">0</span>,rowsize=<span class="number">0</span>; 	<span class="comment">//行列数</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board,<span class="built_in">string</span>&amp; word,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> dep)</span></span>&#123;</span><br><span class="line">        <span class="comment">//不满足条件的返回false</span></span><br><span class="line">        <span class="keyword">if</span>(x&gt;=rowsize||x&lt;<span class="number">0</span>||y&gt;=colsize||y&lt;<span class="number">0</span>||board[x][y]!=word[dep])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//已经深搜到最后一个字母，并且满足条件board[x][y]=word[dep]</span></span><br><span class="line">        <span class="keyword">if</span>(dep==word.size()<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        board[x][y]=<span class="string">&#x27;\n&#x27;</span>;	<span class="comment">//把现在走过的字母先修改成不可能的字符</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dfs(board,word,x+dx[i],y+dy[i],dep+<span class="number">1</span>))&#123;<span class="comment">//找到一条就返回</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        board[x][y]=word[dep];	<span class="comment">//把字母恢复，给其他路径走</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">//找不到路径</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        rowsize=board.size();</span><br><span class="line">        colsize=board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rowsize;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;board[<span class="number">0</span>].size();++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(board,word,i,j,<span class="number">0</span>))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h2><h3 id="medium-8"><a href="#medium-8" class="headerlink" title="medium"></a>medium</h3><h4 id="二叉树的锯齿形层序遍历"><a href="#二叉树的锯齿形层序遍历" class="headerlink" title=" 二叉树的锯齿形层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/"> 二叉树的锯齿形层序遍历</a></h4><p>给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>
<p>例如：<br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>返回锯齿形层序遍历如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>思路：进行普通的层次遍历，将每层结果存在deque，若需要倒序的层，则头插，不然就尾插。然后类型转到vector，</p>
<p>空间复杂度O（n）n为树节点个数</p>
<p>时间复杂度O（n）</p>
<p>提交答案</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode *&gt; que;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> ans;</span><br><span class="line">        que.push(root); </span><br><span class="line">        <span class="keyword">int</span> dep = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> len = que.size();</span><br><span class="line">            <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; valque;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                TreeNode* tmp = que.front();</span><br><span class="line">                que.pop();</span><br><span class="line">                <span class="keyword">if</span>(dep%<span class="number">2</span>) <span class="comment">//该层不需要反转</span></span><br><span class="line">                    valque.push_back(tmp-&gt;val);</span><br><span class="line">                <span class="keyword">else</span>	<span class="comment">////该层需要反转</span></span><br><span class="line">                    valque.push_front(tmp-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;left)</span><br><span class="line">                    que.push(tmp-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;right)</span><br><span class="line">                    que.push(tmp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            dep++;</span><br><span class="line">            ans.emplace_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;valque.begin(),valque.end()&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>思路2：将节点存在deque，下一层需反转的，取队头，然后子节点放在队尾，先放左节点，后放右节点。</p>
<p>​                                     下一层不需翻转的，取队尾，子节点插队头，先放右节点，再放左节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">deque</span>&lt;TreeNode*&gt;que;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> ans;</span><br><span class="line">        que.push_back(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmpv1;</span><br><span class="line">            <span class="keyword">int</span> len=que.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                TreeNode* tmp=que.front();</span><br><span class="line">                que.pop_front();</span><br><span class="line">                tmpv1.emplace_back(tmp-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;left)que.push_back(tmp-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;right)que.push_back(tmp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(tmpv1);</span><br><span class="line">            <span class="keyword">if</span>(que.empty())<span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmpv2;</span><br><span class="line">            len=que.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=len;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">                TreeNode* tmp=que.back();</span><br><span class="line">                que.pop_back();</span><br><span class="line">                tmpv2.emplace_back(tmp-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;right)que.push_front(tmp-&gt;right);</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;left)que.push_front(tmp-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(tmpv2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">机器人的运动范围</a></h4><p>地上有一个m行n列的方格，从坐标 <code>[0,0]</code> 到坐标 <code>[m-1,n-1]</code> 。一个机器人从坐标 <code>[0, 0]</code>的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m &#x3D; 2, n &#x3D; 3, k &#x3D; 1</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<p>思路：层次遍历，满足条件的可以前进，可以优化前进方向为向右或向下。</p>
<p>时间复杂度O(<script type="math/tex">mn</script>)</p>
<p>空间复杂度O(<script type="math/tex">mn</script>)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x)&#123;</span><br><span class="line">            ans+=x%<span class="number">10</span>;</span><br><span class="line">            x/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; isvisit(m,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n,<span class="literal">false</span>));</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; que;<span class="comment">//分别表示x,y</span></span><br><span class="line">        que.push(&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">int</span> dx[<span class="number">2</span>]&#123;<span class="number">0</span>,<span class="number">1</span>&#125;;<span class="comment">//方向数组</span></span><br><span class="line">        <span class="keyword">int</span> dy[<span class="number">2</span>]&#123;<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        isvisit[<span class="number">0</span>][<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">            <span class="keyword">auto</span> tmp=que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> xx=tmp.first+dx[i];</span><br><span class="line">                <span class="keyword">int</span> yy=tmp.second+dy[i];</span><br><span class="line">                <span class="keyword">if</span>(xx&gt;=<span class="number">0</span>&amp;&amp;xx&lt;m&amp;&amp;yy&gt;=<span class="number">0</span>&amp;&amp;yy&lt;n&amp;&amp;!isvisit[xx][yy]&amp;&amp;getsum(xx)+getsum(yy)&lt;=k)&#123;</span><br><span class="line">                    isvisit[xx][yy]=<span class="literal">true</span>;</span><br><span class="line">                    que.push(<span class="built_in">make_pair</span>(xx,yy));</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="课程表-II"><a href="#课程表-II" class="headerlink" title="课程表 II"></a><a href="https://leetcode-cn.com/problems/course-schedule-ii/">课程表 II</a></h4><p>现在你总共有 <em>n</em> 门课需要选，记为 <code>0</code> 到 <code>n-1</code>。</p>
<p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: <code>[0,1]</code></p>
<p>给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。</p>
<p>可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。</p>
<p>思路1：bfs，将所有入度为0的节点放入队列开始广搜，每次将当前节点连接到的节点入度减一，将连接到的节点入度为0的放入队列。在环里的节点将不会被搜到。所以广搜结束后，看是不是所有节点都被搜到就是答案。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">indegree</span><span class="params">(numCourses)</span></span>;		<span class="comment">//入度表</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; edges(numCourses,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());<span class="comment">//邻接表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x:prerequisites)&#123;	<span class="comment">//初始化入度表和邻接表</span></span><br><span class="line">            indegree[x[<span class="number">0</span>]]++;</span><br><span class="line">            edges[x[<span class="number">1</span>]].emplace_back(x[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;	</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;indegree.size();++i)&#123;<span class="comment">//入度为0的节点加入队列</span></span><br><span class="line">            <span class="keyword">if</span>(indegree[i]==<span class="number">0</span>)</span><br><span class="line">                que.push(i);</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            ans.emplace_back(tmp);<span class="comment">//取队头放入答案数组</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edges[tmp].size();++i)&#123;</span><br><span class="line">                --indegree[edges[tmp][i]];	 	<span class="comment">//连接到的节点入度减一</span></span><br><span class="line">                <span class="keyword">if</span>(indegree[edges[tmp][i]]==<span class="number">0</span>)&#123;	<span class="comment">//连接到的节点入度为0的放入队列</span></span><br><span class="line">                    que.push(edges[tmp][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans.size()!=numCourses)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思路2：dfs 随意选择一个未遍历节点，深搜。将经历的节点状态设为1，如果再次经历相同的节点，说明有环，不可能完成所有课程。深搜到底部开始回溯，并将回溯的节点设为状态2，声明他是已完成的节点。不断选择未遍历节点，直到找到环，或者全部节点都为状态2，深搜结束。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; relation(numCourses,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">status</span><span class="params">(numCourses)</span></span>;	<span class="comment">//状态数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prerequisites.size();++i)&#123;	<span class="comment">//建立邻接表</span></span><br><span class="line">            relation[prerequisites[i][<span class="number">1</span>]].push_back(prerequisites[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numCourses;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(status[i]==<span class="number">0</span>)&#123;				<span class="comment">//找一个未遍历节点</span></span><br><span class="line">                <span class="keyword">if</span>(dfs(relation,status,i))	<span class="comment">//返回true说明有环</span></span><br><span class="line">                    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(ans.begin(),ans.end());	</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; relation,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; status,<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ans.size()==status.size())	<span class="comment">//找到所有的节点了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        status[cur]=<span class="number">1</span>;	<span class="comment">//设置当前节点状态为1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;relation[cur].size();++i)&#123;	<span class="comment">//找当前节点连接的节点</span></span><br><span class="line">            <span class="keyword">if</span>(status[relation[cur][i]]==<span class="number">1</span>)	<span class="comment">//连接的节点状态为1，说明在前面搜到过，有环</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(status[relation[cur][i]]==<span class="number">2</span>)<span class="comment">//连接的节点已经完成学习了，继续下一个</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(dfs(relation,status,relation[cur][i]))<span class="comment">//继续深搜，返回true说明有环</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        status[cur]=<span class="number">2</span>;		<span class="comment">//当前节点完成了</span></span><br><span class="line">        ans.push_back(cur);	<span class="comment">//放入栈中</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;		<span class="comment">//当前节点没找到环，返回false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="环形回路"><a href="#环形回路" class="headerlink" title="环形回路"></a>环形回路</h2><h3 id="medium-9"><a href="#medium-9" class="headerlink" title="medium"></a>medium</h3><h4 id="环形链表-II"><a href="#环形链表-II" class="headerlink" title="环形链表 II"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">环形链表 II</a></h4><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code>。</p>
<p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意，<code>pos</code> 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</strong></p>
<p><strong>说明：</strong>不允许修改给定的链表。</p>
<p><strong>进阶：</strong></p>
<ul>
<li>你是否可以使用 <code>O(1)</code> 空间解决此题？</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>
<p>判断链表是否有环，用快慢指针。</p>
<p><img src="https://assets.leetcode-cn.com/solution-static/142/142_fig1.png" alt="图"></p>
<script type="math/tex; mode=display">a+(n+1)b+nc=2(a+b)⟹a=c+(n−1)(b+c)</script><p>当n=1时a=c</p>
<p>所以在快慢指针相遇时，新建一个头指针，慢指针和新指针同时走相同的步数时，会在入口处相遇</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast=head;<span class="comment">//head指针充当慢指针</span></span><br><span class="line">        ListNode* ans=head;<span class="comment">//新指针</span></span><br><span class="line">        <span class="keyword">while</span>(fast&amp;&amp;fast-&gt;next)&#123;	<span class="comment">//fast指针判空，由于链表数奇偶的关系，需要判断next和fast，这里退出说明无环</span></span><br><span class="line">            fast=fast-&gt;next-&gt;next;</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(head==fast)&#123;				<span class="comment">//slow和fast相遇</span></span><br><span class="line">                <span class="keyword">while</span>(ans!=head)&#123;		<span class="comment">//slow和新指针同步向前直到相遇</span></span><br><span class="line">                    head=head-&gt;next;</span><br><span class="line">                    ans=ans-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h2><h3 id="esay"><a href="#esay" class="headerlink" title="esay"></a>esay</h3><h4 id="翻转单词顺序"><a href="#翻转单词顺序" class="headerlink" title="翻转单词顺序"></a><a href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/">翻转单词顺序</a></h4><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;the sky is blue&quot;</span><br><span class="line">输出: &quot;blue is sky the&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;  hello world!  &quot;</span><br><span class="line">输出: &quot;world! hello&quot;</span><br><span class="line">解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;a good   example&quot;</span><br><span class="line">输出: &quot;example good a&quot;</span><br><span class="line">解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span><br></pre></td></tr></table></figure>
<p>思路：先全部翻转，然后把每一个单词翻转，然后去掉前面和后面的所有空格和中间的多余空格。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        reverse(s.begin(),s.end());	<span class="comment">//全部翻转</span></span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;s.size())&#123;</span><br><span class="line">            <span class="keyword">while</span>(s[left]==<span class="string">&#x27; &#x27;</span>)	<span class="comment">//跳过空格</span></span><br><span class="line">                ++left;</span><br><span class="line">            right=left;</span><br><span class="line">            <span class="keyword">while</span>(right&lt;s.size()&amp;&amp;s[right]!=<span class="string">&#x27; &#x27;</span>)<span class="comment">//到单词的末尾或者字符末尾</span></span><br><span class="line">                ++right;</span><br><span class="line">            reverse(s.begin()+left,s.begin()+right);<span class="comment">//翻转这个单词</span></span><br><span class="line">            ++right;	<span class="comment">//到下一个位置</span></span><br><span class="line">            left=right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        left=<span class="number">0</span>;</span><br><span class="line">        right=s.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(s[left]==<span class="string">&#x27; &#x27;</span>)<span class="comment">//找最前面不是空格的，这里由于空串s[0]==&#x27;\n&#x27;所有不用判断越界</span></span><br><span class="line">            ++left;</span><br><span class="line">        <span class="keyword">while</span>(right&gt;=<span class="number">0</span>&amp;&amp;s[right]==<span class="string">&#x27; &#x27;</span>)<span class="comment">//找最后面不是空格的字母</span></span><br><span class="line">            --right;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=left;j&lt;=right;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!count)	<span class="comment">//第一次遇到空格</span></span><br><span class="line">                    ans.push_back(s[j]);</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                count=<span class="number">0</span>;	<span class="comment">//遇到非空格清0</span></span><br><span class="line">                ans.push_back(s[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="字符串相加"><a href="#字符串相加" class="headerlink" title="字符串相加"></a><a href="https://leetcode-cn.com/problems/add-strings/">字符串相加</a></h4><p>给定两个字符串形式的非负整数 <code>num1</code> 和<code>num2</code> ，计算它们的和。</p>
<p><strong>提示：</strong></p>
<ol>
<li><code>num1</code> 和<code>num2</code> 的长度都小于 5100</li>
<li><code>num1</code> 和<code>num2</code> 都只包含数字 <code>0-9</code></li>
<li><code>num1</code> 和<code>num2</code> 都不包含任何前导零</li>
<li><strong>你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式</strong></li>
</ol>
<p>思路：将num2加到num1上，模拟加法，双指针指向两个字符串尾部，往前加，维持一个变量pre表示进位。</p>
<p>边界处理：</p>
<p>保证num1长度大于等于num2,注意加完num2可能还有进位。</p>
<p>可能结果大于num1的长度，即最后有进位。举例：99+1=100</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addStrings</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num2.size()&gt;num1.size())<span class="comment">//保证num1长度大于等于num2</span></span><br><span class="line">            num1.swap(num2);</span><br><span class="line">        <span class="comment">//index为指针，指向最后一位数，注意有换行符</span></span><br><span class="line">        <span class="keyword">int</span> index1=num1.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> pre=<span class="number">0</span>,tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> index2=num2.size()<span class="number">-1</span>;index1&gt;=<span class="number">0</span>;index1--,index2--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(index2&gt;=<span class="number">0</span>)		<span class="comment">//处理num1，num2都有的情况</span></span><br><span class="line">                tmp=num1[index1]-<span class="string">&#x27;0&#x27;</span>+num2[index2]-<span class="string">&#x27;0&#x27;</span>+pre;</span><br><span class="line">            <span class="keyword">else</span>&#123;				<span class="comment">//只剩num1</span></span><br><span class="line">                <span class="keyword">if</span>(!pre)<span class="keyword">break</span>;	<span class="comment">//没有进位了可以退出</span></span><br><span class="line">                tmp=num1[index1]-<span class="string">&#x27;0&#x27;</span>+pre;</span><br><span class="line">            &#125;</span><br><span class="line">            num1[index1]=tmp%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            pre=tmp/<span class="number">10</span>;	<span class="comment">//确定是否有进位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pre) num1.insert(num1.begin(),<span class="string">&#x27;1&#x27;</span>) ;<span class="comment">//最后一位没进，补上1在前面</span></span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><h3 id="medium-10"><a href="#medium-10" class="headerlink" title="medium"></a>medium</h3><h4 id="和为K的子数组"><a href="#和为K的子数组" class="headerlink" title="和为K的子数组"></a><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/">和为K的子数组</a></h4><p>给定一个整数数组和一个整数 <strong>k，</strong>你需要找到该数组中和为 <strong>k</strong> 的连续的子数组的个数。</p>
<p><strong>示例 1 :</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入:nums &#x3D; [1,1,1], k &#x3D; 2</span><br><span class="line">输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。</span><br></pre></td></tr></table></figure>
<p>本题和<a href="#he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof">和为s的连续正数序列</a>类似但不同，不同之处在于递增序列和含有负数。所以不能用滑动窗口</p>
<p>思路与两数之和类似，不过添加了前缀和的知识。</p>
<p>哈希表mp[前缀和]=前缀和的数目</p>
<p>这样区间[i,j]=j-1的前缀和减去i的前缀和</p>
<p>首先求出当前i+1前缀和sum，然后看哈希表里是否有k-sum(这时哈希表存放了0到j的前缀和)，有就将前缀和数量加到ans</p>
<p>将当前前缀和插插入mp。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">        mp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();++i)&#123;</span><br><span class="line">            sum+=nums[i];		<span class="comment">//求出当前i+1前缀和sum</span></span><br><span class="line">            <span class="keyword">if</span>(mp.find(sum-k)!=mp.end())<span class="comment">//哈希表存放了0到i的前缀和</span></span><br><span class="line">                ans+=mp[sum-k];</span><br><span class="line">            mp[sum]++;	<span class="comment">//将i+1的前缀和加入</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="hard-5"><a href="#hard-5" class="headerlink" title="hard"></a>hard</h3><h4 id="元素和为目标值的子矩阵数量"><a href="#元素和为目标值的子矩阵数量" class="headerlink" title="元素和为目标值的子矩阵数量"></a><a href="https://leetcode-cn.com/problems/number-of-submatrices-that-sum-to-target/">元素和为目标值的子矩阵数量</a></h4><p>给出矩阵 <code>matrix</code> 和目标值 <code>target</code>，返回元素总和等于目标值的非空子矩阵的数量。</p>
<p>子矩阵 <code>x1, y1, x2, y2</code> 是满足 <code>x1 &lt;= x &lt;= x2</code> 且 <code>y1 &lt;= y &lt;= y2</code> 的所有单元 <code>matrix[x][y]</code> 的集合。</p>
<p>如果 <code>(x1, y1, x2, y2)</code> 和 <code>(x1&#39;, y1&#39;, x2&#39;, y2&#39;)</code> 两个子矩阵中部分坐标不同（如：<code>x1 != x1&#39;</code>），那么这两个子矩阵也不同。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/09/02/mate1.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix &#x3D; [[0,1,0],[1,1,1],[0,1,0]], target &#x3D; 0</span><br><span class="line">输出：4</span><br><span class="line">解释：四个只含 0 的 1x1 子矩阵。</span><br></pre></td></tr></table></figure>
<p>思路：外层跟<strong>最大子矩阵</strong>的思路类似，双层循环遍历确定上下边界，压缩为一维数组，然后根据<strong>和为k的子数组</strong>思路，找出子数组的个数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSubmatrixSumTarget</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">count</span><span class="params">(matrix[<span class="number">0</span>].size())</span></span>;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;matrix.size();++i)&#123;</span><br><span class="line">            fill(count.begin(),count.end(),<span class="number">0</span>);<span class="comment">//换上边界，清空</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;matrix.size();++j)&#123;<span class="comment">//下边界</span></span><br><span class="line">                <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;	</span><br><span class="line">                <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">                mp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;matrix[<span class="number">0</span>].size();++k)&#123;</span><br><span class="line">                    count[k]+=matrix[j][k];		<span class="comment">//累积本层的数</span></span><br><span class="line">                    sum+=count[k];				<span class="comment">//前缀和</span></span><br><span class="line">                    <span class="keyword">if</span>(mp.find(sum-target)!=mp.end())</span><br><span class="line">                        ans+=mp[sum-target];</span><br><span class="line">                    mp[sum]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><h3 id="hard-6"><a href="#hard-6" class="headerlink" title="hard"></a>hard</h3><h4 id="课程表-III"><a href="#课程表-III" class="headerlink" title="课程表 III"></a><a href="https://leetcode-cn.com/problems/course-schedule-iii/">课程表 III</a></h4><p>这里有 <code>n</code> 门不同的在线课程，他们按从 <code>1</code> 到 <code>n</code> 编号。每一门课程有一定的持续上课时间（课程时间）<code>t</code> 以及关闭时间第 d 天。一门课要持续学习 <code>t</code> 天直到第 d 天时要完成，你将会从第 1 天开始。</p>
<p>给出 <code>n</code> 个在线课程用 <code>(t, d)</code> 对表示。你的任务是找出最多可以修几门课。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]]</span><br><span class="line">输出: 3</span><br><span class="line">解释: </span><br><span class="line">这里一共有 4 门课程, 但是你最多可以修 3 门:</span><br><span class="line">首先, 修第一门课时, 它要耗费 100 天，你会在第 100 天完成, 在第 101 天准备下门课。</span><br><span class="line">第二, 修第三门课时, 它会耗费 1000 天，所以你将在第 1100 天的时候完成它, 以及在第 1101 天开始准备下门课程。</span><br><span class="line">第三, 修第二门课时, 它会耗时 200 天，所以你将会在第 1300 天时完成它。</span><br><span class="line">第四门课现在不能修，因为你将会在第 3300 天完成它，这已经超出了关闭日期。</span><br></pre></td></tr></table></figure>
<p><strong>提示:</strong></p>
<ol>
<li>整数 1 &lt;= d, t, n &lt;= 10,000 。</li>
<li>你不能同时修两门课程。</li>
</ol>
<p>思路：典型的贪心算法，课程开始时间无限制。</p>
<p>假设有两个课程，[t1,d1],[t2,d2]（d1&lt;d2）,现在的时间是t</p>
<p>那么要修这两个课程,</p>
<p>如果先修[t1,d1]。要满足的条件是x+t1&lt;d1     , x+t1+t2&lt;d2</p>
<p>如果先修[t2,d2]。要满足的条件是x+t1+t2&lt;d1,x+t1+t2&lt;d2</p>
<p>显然先修[t1,d1]更好，也就是先修结束时间早的课程。</p>
<p>按结束时间排序，然后遍历修课程</p>
<p>那么当修了前面时间早的课程，时间超过了当前想要修的课程的时候，必须要丢一个课程，那么可以从前面修的课程里面挑一个用时最长的课程跟现在的课程比较，修二者时间短的课程，方便后面修其他课程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">scheduleCourse</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; courses)</span> </span>&#123;</span><br><span class="line">        sort(courses.begin(),courses.end(),[&amp;](<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;a,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;b)&#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>]&lt;b[<span class="number">1</span>];</span><br><span class="line">        &#125;);			<span class="comment">//按结束时间排序</span></span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span> ,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt;&gt; pque;<span class="comment">//大顶堆存放修的课程的用时</span></span><br><span class="line">        <span class="keyword">int</span> time=<span class="number">0</span>;				<span class="comment">//当前时间</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; x:courses)&#123;</span><br><span class="line">            time+=x[<span class="number">0</span>];			<span class="comment">//选择修现在的课程</span></span><br><span class="line">            pque.push(x[<span class="number">0</span>]);	<span class="comment">//将现在的课程时间放入堆</span></span><br><span class="line">            <span class="keyword">if</span>(time&gt;x[<span class="number">1</span>])&#123;		<span class="comment">//如果现在的课程修不了</span></span><br><span class="line">                time-=pque.top();	<span class="comment">//删除修的课程最大的</span></span><br><span class="line">                pque.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pque.size(); 	<span class="comment">//堆的元素数量就是答案</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="easy-5"><a href="#easy-5" class="headerlink" title="easy"></a>easy</h3><h4 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">相交链表</a></h4><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 <code>null</code> 。</p>
<p>图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></p>
<p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="img"></a></p>
<p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p>
<p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p>
<p>思路1：预处理两个链表的长度，再从长链表的尾开始倒数短链表的长度，开始同时遍历。</p>
<p>思路2：每个链表从头开始遍历，遍历完了，继续从另一个头开始遍历，直到遇到第一个相同的节点。</p>
<p>相同的节点为空就是两个链表不相交。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode *ha=headA, *hb=headB;</span><br><span class="line">        <span class="keyword">while</span>(ha!=hb)&#123;</span><br><span class="line">            ha=(ha==<span class="literal">NULL</span>)?headB:ha-&gt;next;</span><br><span class="line">            hb=(hb==<span class="literal">NULL</span>)?headA:hb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ha;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="hard-7"><a href="#hard-7" class="headerlink" title="hard"></a>hard</h3><h4 id="合并K个升序链表"><a href="#合并K个升序链表" class="headerlink" title="合并K个升序链表"></a><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">合并K个升序链表</a></h4><p>给你一个链表数组，每个链表都已经按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：lists &#x3D; [[1,4,5],[1,3,4],[2,6]]</span><br><span class="line">输出：[1,1,2,3,4,4,5,6]</span><br></pre></td></tr></table></figure>
<p>思路1：将所有的链头放入小顶堆，每次选堆里最小的链头，连接到答案链表的尾部，选的链头如果还有后序节点，继续放入后序节点的链头。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> cmp=[](ListNode* &amp; l1,ListNode* &amp; l2)&#123;<span class="keyword">return</span> l1-&gt;val&gt;l2-&gt;val;&#125;;</span><br><span class="line">        <span class="comment">//自定义比较函数的小顶堆</span></span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;ListNode*, <span class="built_in">vector</span>&lt;ListNode*&gt;,<span class="keyword">decltype</span>(cmp)&gt; pque(cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; <span class="built_in">list</span>:lists)&#123;<span class="comment">//加入所有链表头</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">list</span>)&#123;</span><br><span class="line">                pque.push(<span class="built_in">list</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* head=<span class="keyword">new</span> ListNode();<span class="comment">//哨兵链表头</span></span><br><span class="line">        ListNode* cur=head;</span><br><span class="line">        <span class="keyword">while</span>(!pque.empty())&#123;</span><br><span class="line">            cur-&gt;next=pque.top();<span class="comment">//往队尾加</span></span><br><span class="line">            pque.pop();</span><br><span class="line">            cur=cur-&gt;next;	</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;next)&#123;		<span class="comment">//还有后续节点</span></span><br><span class="line">                pque.push(cur-&gt;next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思路2：分治链表，将所有链表两两合并，合并的链表再次两两合并，如此类推。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mergeLists(lists,<span class="number">0</span>,lists.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;<span class="comment">//分治k个链表</span></span><br><span class="line">        <span class="keyword">if</span>(left==right)</span><br><span class="line">            <span class="keyword">return</span> lists[left];</span><br><span class="line">        <span class="keyword">if</span>(left&gt;right) 				<span class="comment">//注意这里返回空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> mergeTwoLists(mergeLists(lists,left,mid),mergeLists(lists,mid+<span class="number">1</span>,right));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1,ListNode* l2)</span></span>&#123;			<span class="comment">//递归合并两个链表</span></span><br><span class="line">        <span class="keyword">if</span>(l1&amp;&amp;l2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val&gt;l2-&gt;val)&#123;</span><br><span class="line">                l2-&gt;next=mergeTwoLists(l1,l2-&gt;next);</span><br><span class="line">                <span class="keyword">return</span> l2;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l1-&gt;next=mergeTwoLists(l1-&gt;next,l2);</span><br><span class="line">                <span class="keyword">return</span> l1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (l1==<span class="literal">nullptr</span>)?l2:l1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><h3 id="easy-6"><a href="#easy-6" class="headerlink" title="easy"></a>easy</h3><h4 id="圆圈中最后剩下的数字"><a href="#圆圈中最后剩下的数字" class="headerlink" title="圆圈中最后剩下的数字"></a><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/">圆圈中最后剩下的数字</a></h4><p>0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。</p>
<p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p>
<p>思路：约瑟夫环，可以递归或动态规划解决。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th>要删除的nums序号</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>4</td>
<td>0</td>
<td>1</td>
<td></td>
<td>2</td>
</tr>
<tr>
<td>1</td>
<td>3</td>
<td>4</td>
<td></td>
<td></td>
<td>2</td>
</tr>
<tr>
<td>1</td>
<td>3</td>
<td></td>
<td></td>
<td></td>
<td>0</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<p>整个表格反过来(k=3)</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th>要找的nums序号</th>
</tr>
</thead>
<tbody>
<tr>
<td>3</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>0 最后一个,也就是要留下来的数</td>
</tr>
<tr>
<td>1</td>
<td>3</td>
<td></td>
<td></td>
<td></td>
<td>1 =(0+k)%2  序号0后面补上走了k步，找到了3</td>
</tr>
<tr>
<td>1</td>
<td>3</td>
<td>4</td>
<td></td>
<td></td>
<td>1 =(1+k)%3  序号1后补上k步，找到了3</td>
</tr>
<tr>
<td>3</td>
<td>4</td>
<td>0</td>
<td>1</td>
<td></td>
<td>0 =(1+k)%4  序号1后补上k步，找到了3</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>3 =(0+k)%5  序号0后补上k步，找到了3</td>
</tr>
</tbody>
</table>
</div>
<p>由于序号等于nums[序号]，所以最后返回的是最后一步要删的数在n长度数组的位置也就是nums[序号]</p>
<p>递归版</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> (lastRemaining(n<span class="number">-1</span>,m)+m)%n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>动态规划版</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            index=(index+m)%i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="medium-11"><a href="#medium-11" class="headerlink" title="medium"></a>medium</h3><h4 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">把数组排成最小的数</a></h4><p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [10,2]</span><br><span class="line">输出: &quot;102&quot;</span><br></pre></td></tr></table></figure>
<p>思路：自定义排序，将两个数拼接在一起，判断哪个数在前面更小。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; strs;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">int</span>&amp; num:nums)</span><br><span class="line">            strs.emplace_back(to_string(num));</span><br><span class="line">        sort(strs.begin(),strs.end(),[](<span class="built_in">string</span>&amp; a,<span class="built_in">string</span>&amp; b)&#123;</span><br><span class="line">            <span class="keyword">return</span> a+b&lt;b+a;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">string</span> ans=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str:strs)</span><br><span class="line">            ans+=str;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="构建乘积数组"><a href="#构建乘积数组" class="headerlink" title="构建乘积数组"></a><a href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/">构建乘积数组</a></h4><p>给定一个数组 <code>A[0,1,…,n-1]</code>，请构建一个数组 <code>B[0,1,…,n-1]</code>，其中 <code>B[i]</code> 的值是数组 <code>A</code> 中除了下标 <code>i</code> 以外的元素的积, 即 <code>B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]</code>。<strong>不能使用除法。</strong></p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: [120,60,40,30,24]</span><br></pre></td></tr></table></figure>
<p>思路：注意不能使用除法，而且就算使用除法也需要判断<code>A[i]</code>是不是等于0，</p>
<p>可以分两次遍历完成，第一遍从前往后遍历把<code>A[0]×A[1]×…×A[i-1]</code>存入<code>B[i]</code></p>
<p>第二遍从后往前遍历把<code>A[n-1]×A[n-2]×…×A[i+1]</code>乘上<code>B[i]</code>放入<code>B[i]</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">constructArr</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(a.size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,base=<span class="number">1</span>;i&lt;a.size();++i)&#123;</span><br><span class="line">            ans[i]=base;</span><br><span class="line">            base*=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=a.size()<span class="number">-1</span>,base=<span class="number">1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">            ans[i]=ans[i]*base;</span><br><span class="line">            base*=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">数值的整数次方</a></h4><p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/">pow(<em>x</em>, <em>n</em>)</a> ，即计算 x 的 n 次幂函数（即，x^n）。不得使用库函数，同时不需要考虑大数问题。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x &#x3D; 2.00000, n &#x3D; 10</span><br><span class="line">输出：1024.00000</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：x &#x3D; 2.00000, n &#x3D; -2</span><br><span class="line">输出：0.25000</span><br><span class="line">解释：2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">范围：</span><br><span class="line">	-100.0 &lt; x &lt; 100.0</span><br><span class="line">	-2^31 &lt;&#x3D; n &lt;&#x3D; 2^31-1</span><br><span class="line">	-10^4 &lt;&#x3D; x^n &lt;&#x3D; 10^4</span><br></pre></td></tr></table></figure>
<p>思路：考察快速幂x^n</p>
<p>时间复杂度O(<script type="math/tex">log_2(n)</script>)</p>
<p>空间复杂度O(1)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> tmpn=n;<span class="comment">//由于-2^31取相反数时会超过int范围，先将n存放在long类型</span></span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            x=<span class="number">1</span>/x;</span><br><span class="line">            tmpn=-tmpn;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(tmpn)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmpn&amp;<span class="number">1</span>)</span><br><span class="line">                ans*=x;</span><br><span class="line">            x*=x;</span><br><span class="line">            tmpn&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>递归版</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">recurPow</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//处理负数n</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">1</span>/x;</span><br><span class="line">    <span class="keyword">if</span>(n&amp;<span class="number">1</span>) <span class="keyword">return</span> recurPow(x*x,n&gt;&gt;<span class="number">1</span>)*x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> recurPow(x*x,n&gt;&gt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="剪绳子-II"><a href="#剪绳子-II" class="headerlink" title="剪绳子 II"></a><a href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/">剪绳子 II</a></h4><p>给你一根长度为 <code>n</code> 的绳子，请把绳子剪成整数长度的 <code>m</code> 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 <code>k[0],k[1]...k[m - 1]</code> 。请问 <code>k[0]*k[1]*...*k[m - 1]</code> 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<p>思路：数学求导得到每一段都为3时，相乘是最优解。</p>
<p>分为4种情况</p>
<p>2&lt;=n&lt;=3时返回n-1，因为 m&gt;1</p>
<p>当对3求余得到0直接返回3的段数次方</p>
<p>当对3求余得到1返回3的（段数-1）次方乘以4（最后一段长度为3的段取出来，分成2，2）</p>
<p>当对3求余得到2返回3的段数次方*2</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> modnum=<span class="number">1000000007</span>;</span><br><span class="line">    <span class="comment">//快速幂求base^exp%modnum</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">FastPowAndMod</span><span class="params">(<span class="keyword">long</span> base,<span class="keyword">int</span> <span class="built_in">exp</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">exp</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">exp</span>&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                ans*=base;</span><br><span class="line">                ans%=modnum;</span><br><span class="line">            &#125;</span><br><span class="line">            base*=base;</span><br><span class="line">            base%=modnum;</span><br><span class="line">            <span class="built_in">exp</span>&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">3</span>)<span class="keyword">return</span> n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> segnum=n/<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> remain=n%<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">switch</span>(remain)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:<span class="keyword">return</span> FastPowAndMod(<span class="number">3</span>,segnum);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:<span class="keyword">return</span> FastPowAndMod(<span class="number">3</span>,segnum<span class="number">-1</span>)*<span class="number">4</span>%modnum;</span><br><span class="line">            <span class="keyword">default</span>:<span class="keyword">return</span> FastPowAndMod(<span class="number">3</span>,segnum)*<span class="number">2</span>%modnum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="数组中数字出现的次数-II"><a href="#数组中数字出现的次数-II" class="headerlink" title="数组中数字出现的次数 II"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/">数组中数字出现的次数 II</a></h4><p>在一个数组 <code>nums</code> 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [3,4,3,3]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>
<p>思路：统计二进制每一位的1的数量，余3后剩余的数只会是1或0，拼接这些二进制就可以得到答案。</p>
<p>时间复杂度O(n)</p>
<p>空间复杂度O(1)</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>3:</th>
<th>0</th>
<th>1</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>4:</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>3:</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>3:</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>sum</td>
<td>1</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>sum%3</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">31</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> count=<span class="number">0</span>;			<span class="comment">//统计第i位1的数量</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;		<span class="comment">//遍历数组</span></span><br><span class="line">                count+=(num&gt;&gt;i&amp;<span class="number">1</span>);	<span class="comment">//添加num的第i位1的数量</span></span><br><span class="line">            &#125;</span><br><span class="line">            ans+=(count%<span class="number">3</span>)&lt;&lt;i;		<span class="comment">//拼接到ans,注意这里count%3只会为0或1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      <blockquote class="mdui-m-t-5">
        
        <strong>PermaLink: </strong><br><a href="http://ioaol.top/leetcode%E7%AC%94%E8%AE%B0.html">http://ioaol.top/leetcode%E7%AC%94%E8%AE%B0.html</a>
      </blockquote>
      
    </div>
    <footer class="mdui-card-actions">
      
        <a class="mdui-ripple article_categories-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
      
      
        <a class="mdui-ripple article_tags-none-link" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">动态规划</a><a class="mdui-ripple article_tags-none-link" href="/tags/%E6%A0%88/" rel="tag">栈</a><a class="mdui-ripple article_tags-none-link" href="/tags/%E6%A8%A1%E6%8B%9F/" rel="tag">模拟</a><a class="mdui-ripple article_tags-none-link" href="/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" rel="tag">滑动窗口</a>
      
    </footer>
    
  </article>
  
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.js"></script>

  <script>$("#main article .mdui-card-content img.fancybox").on("click",function(e){$.fancybox.open({src:$(this).attr("src")});});</script>


  <nav id="paginator">
    
      <a rel="prev" class="extend prev" href="/%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98.html">
        <button aria-label="prev" class="mdui-btn mdui-btn-raised mdui-btn-dense mdui-btn-icon mdui-color-theme-accent mdui-ripple"><i class="mdui-icon material-icons">arrow_back</i></button>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Prev
      </a>
    
    <div class="spacer"></div>
    
      <a rel="next" class="extend next" href="/%E6%A8%B1%E4%B9%8B%E8%AF%97%E6%84%9F%E6%83%B3.html">
        Next&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        <button aria-label="next" class="mdui-btn mdui-btn-raised mdui-btn-dense mdui-btn-icon mdui-color-theme-accent mdui-ripple"><i class="mdui-icon material-icons">arrow_forward</i></button>
      </a>
    
  </nav>




  <div style="position: fixed !important; right: 16px; top: 30%;">
    <button class="mdui-fab mdui-fab-mini mdui-ripple" mdui-menu="{target: '#toc'}"><i class="mdui-icon material-icons">format_list_numbered</i></button>
    <ul class="mdui-menu" id="toc">
      <li class="mdui-menu-item" disabled><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88"><span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Easy"><span class="toc-text">Easy</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%9C%80%E5%A4%96%E5%B1%82%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="toc-text">删除最外层的括号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E6%A0%88"><span class="toc-text">最小栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">比较含退格的字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E7%90%86%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">整理字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">二叉树的后序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">二叉树的中序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">二叉树的前序遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#medium"><span class="toc-text">medium</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E6%AF%8F%E5%AF%B9%E6%8B%AC%E5%8F%B7%E9%97%B4%E7%9A%84%E5%AD%90%E4%B8%B2"><span class="toc-text">反转每对括号间的子串</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-text">滑动窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#easy"><span class="toc-text">easy</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97"><span class="toc-text">和为s的连续正数序列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#medium-1"><span class="toc-text">medium</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><span class="toc-text">无重复字符的最长子串</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hard"><span class="toc-text">hard</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2"><span class="toc-text">最小覆盖子串</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#easy-1"><span class="toc-text">easy</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C"><span class="toc-text">连续子数组的最大和</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#medium-2"><span class="toc-text">medium</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95"><span class="toc-text">解码方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6"><span class="toc-text">股票的最大利润</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hard-1"><span class="toc-text">hard</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5"><span class="toc-text">最大子矩阵</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A5%87%E6%80%AA%E7%9A%84%E6%89%93%E5%8D%B0%E6%9C%BA"><span class="toc-text">奇怪的打印机</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F"><span class="toc-text">模拟</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#easy-2"><span class="toc-text">easy</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC"><span class="toc-text">整数反转</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mindium"><span class="toc-text">mindium</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5"><span class="toc-text">顺时针打印矩阵</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0"><span class="toc-text">把字符串转换成整数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91"><span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#easy-3"><span class="toc-text">easy</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%B6%E5%AD%90%E7%9B%B8%E4%BC%BC%E7%9A%84%E6%A0%91"><span class="toc-text">叶子相似的树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-text">二叉搜索树的最近公共祖先</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#medium-3"><span class="toc-text">medium</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84"><span class="toc-text">树的子结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-text">二叉树中和为某一值的路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-text">二叉搜索树与双向链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91"><span class="toc-text">最小高度树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hard-2"><span class="toc-text">hard</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-text"> 二叉树中的最大路径和</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#hard-3"><span class="toc-text">hard</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="toc-text">寻找两个正序数组的中位数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9"><span class="toc-text">数组中的逆序对</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-text">二分查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#medium-4"><span class="toc-text">medium</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%B6%E4%BD%9C-m-%E6%9D%9F%E8%8A%B1%E6%89%80%E9%9C%80%E7%9A%84%E6%9C%80%E5%B0%91%E5%A4%A9%E6%95%B0"><span class="toc-text">制作 m 束花所需的最少天数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%96%87"><span class="toc-text">回文</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#easy-4"><span class="toc-text">easy</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%96%87%E6%95%B0"><span class="toc-text">回文数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="toc-text">验证回文串</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%88%96"><span class="toc-text">异或</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#medium-5"><span class="toc-text">medium</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E7%A0%81%E5%BC%82%E6%88%96%E5%90%8E%E7%9A%84%E6%8E%92%E5%88%97"><span class="toc-text">解码异或后的排列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%BE%E5%87%BA%E7%AC%AC-K-%E5%A4%A7%E7%9A%84%E5%BC%82%E6%88%96%E5%9D%90%E6%A0%87%E5%80%BC"><span class="toc-text">找出第 K 大的异或坐标值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hard-4"><span class="toc-text">hard</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8E%E6%95%B0%E7%BB%84%E4%B8%AD%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%80%BC"><span class="toc-text">与数组中元素的最大异或值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E5%85%B8%E6%A0%91"><span class="toc-text">字典树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#medium-6"><span class="toc-text">medium</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%80%BC"><span class="toc-text">数组中两个数的最大异或值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF"><span class="toc-text">回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#medium-7"><span class="toc-text">medium</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-text">全排列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-text">矩阵中的路径</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="toc-text">层次遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#medium-8"><span class="toc-text">medium</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text"> 二叉树的锯齿形层序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4"><span class="toc-text">机器人的运动范围</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BE%E7%A8%8B%E8%A1%A8-II"><span class="toc-text">课程表 II</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%AF%E5%BD%A2%E5%9B%9E%E8%B7%AF"><span class="toc-text">环形回路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#medium-9"><span class="toc-text">medium</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II"><span class="toc-text">环形链表 II</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86"><span class="toc-text">字符串处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#esay"><span class="toc-text">esay</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F"><span class="toc-text">翻转单词顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0"><span class="toc-text">字符串相加</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-text">前缀和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#medium-10"><span class="toc-text">medium</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-text">和为K的子数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hard-5"><span class="toc-text">hard</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E5%92%8C%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E5%AD%90%E7%9F%A9%E9%98%B5%E6%95%B0%E9%87%8F"><span class="toc-text">元素和为目标值的子矩阵数量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83"><span class="toc-text">贪心</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#hard-6"><span class="toc-text">hard</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BE%E7%A8%8B%E8%A1%A8-III"><span class="toc-text">课程表 III</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#easy-5"><span class="toc-text">easy</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8"><span class="toc-text">相交链表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hard-7"><span class="toc-text">hard</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-text">合并K个升序链表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6"><span class="toc-text">数学</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#easy-6"><span class="toc-text">easy</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-text">圆圈中最后剩下的数字</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#medium-11"><span class="toc-text">medium</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0"><span class="toc-text">把数组排成最小的数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84"><span class="toc-text">构建乘积数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9"><span class="toc-text">数值的整数次方</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%AA%E7%BB%B3%E5%AD%90-II"><span class="toc-text">剪绳子 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0-II"><span class="toc-text">数组中数字出现的次数 II</span></a></li></ol></li></ol></li></ol></li>
    </ul>
  </div>

<!-- 来必力City版安装代码 -->
<div id="lv-container" data-id="city" data-uid="MTAyMC80NjQxNC8yMjkyNQ==">
<script type="text/javascript">
   (function(d, s) {
       var j, e = d.getElementsByTagName(s)[0];

       if (typeof LivereTower === 'function') { return; }

       j = d.createElement(s);
       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
       j.async = true;

       e.parentNode.insertBefore(j, e);
   })(document, 'script');
</script>
<noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
</div>
<!-- City版安装代码已完成 -->
</main>
  <footer id="footer" class="mdui-m-t-5 mdui-p-y-3 mdui-color-theme">
  <div class="mdui-p-y-0 mdui-text-center">
    
    
    
    
    
    
    
      <a href="https://github.com/ioaol" target="_blank"><i class="mdui-p-a-1 mdui-icon iconfont mdui-text-color-theme-a100">&#xe7ab;</i></a>
    
    
    
    
    
      <a href="1449821178" target="_blank"><i class="mdui-p-a-1 mdui-icon iconfont mdui-text-color-theme-a100">&#xe651;</i></a>
    
    

  </div>
  <div class="mdui-p-y-1 mdui-text-center">
    Copyright &copy; 2021 IOAOl<br>
    Powered by <a href="https://hexo.io/" target="_blank" class="mdui-text-color-theme-accent">Hexo</a>
    <br>
      <span id="busuanzi_container_site_pv" style="display: none;"><i class="iconfont">&#xe7fd;</i> <span id="busuanzi_value_site_pv"></span></span> &nbsp;&nbsp;
      <span id="busuanzi_container_site_uv" style="display: none;"><i class="iconfont">&#xe601;</i> <span id="busuanzi_value_site_uv"></span></span>
    
  </div>


</footer>
  
  <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>


  <button id="gotop" class="mdui-fab mdui-fab-fixed mdui-fab-hide mdui-ripple mdui-color-theme-accent"><i class="mdui-icon material-icons">arrow_upward</i></button>
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  
<script src="/js/mdui.js"></script>
<script src="/js/script.js"></script>

  
<script src="/custom.js"></script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<!-- <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>

</body>
</html>