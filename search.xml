<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>TSPppt</title>
    <url>/2019/09/23/TSPppt.html</url>
    <content><![CDATA[<h1 id="TSP的几个算法"><a href="#TSP的几个算法" class="headerlink" title="TSP的几个算法"></a>TSP的几个算法</h1><p>这是一个自己做的ppt的记录。</p>
<h2 id="TSP实例"><a href="#TSP实例" class="headerlink" title="TSP实例"></a>TSP实例</h2><p>有一位商人，他想访问德国的某些城市，要求：</p>
<ol>
<li>所走路程最短；</li>
<li>每个城市只能访问一次；</li>
<li>从某城市出发，最后回到该城市。</li>
</ol>
<p><img src="https://i.loli.net/2019/09/23/ivBU6RxodJYnZKr.png" alt="1568996702133 - 副本.png"></p>
<p>让我们看一下为什么要学这个问题，主要来看一下tsp到底有什么用。</p>
<p><img src="https://i.loli.net/2019/09/23/ouY7XfMKmTSia8p.png" alt="1568997255774 - 副本.png"></p>
<p>看完了应用，我们来看一下怎么去解决这个问题吧</p>
<p>首先先任意选一个点作为起点，然后开始连接就可以看到有n！种情况</p>
<p><img src="https://i.loli.net/2019/09/23/iCTeADruUnYm9Ia.png" alt="1569036262994 - 副本.png"></p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>我们尝试优化一下，目前最好的优化是通过动态规划去解决，复杂度为o（2^n*n^2）</p>
<p>首先得懂得为什么可以使用动态规划，<strong>动态规划就是在求解一个复杂问题时，将其分解为若干个简单问题。通过求解简单问题的最优解，来找到目标问题的最优解。</strong></p>
<p><strong>使用动态规划，需要问题本身有最优子结构</strong>，我们需要找到要解决的问题的子问题。</p>
<p>现在找一下tsp的最优子结构</p>
<p><img src="https://i.loli.net/2019/09/23/WFVGmarTHC384hi.png" alt="1569036739438 - 副本.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">从0出发，经过[1,2,3]这几个城市，然后回到0，使得花费最少。要实现这个要求，需要从下面三个实现方案中选择花费最少的方案。</span><br></pre></td></tr></table></figure>

<p>　　　　1、 从0出发，到1，然后再从1出发，经过[2,3]这几个城市，然后回到0，使得花费最少。</p>
<p>　　　　2、 从0出发，到2，然后再从2出发，经过[1,3]这几个城市，然后回到0，使得花费最少。</p>
<p>　　　　3、 从0出发，到3，然后再从3出发，经过[1,2]这几个城市，然后回到0，使得花费最少。<br>  可以发现，三个小的解决方案的最优解，构成了大的解决方案，所以这个问题具有最优子结构，可以用动态规划来实现。</p>
<p><img src="https://i.loli.net/2019/09/23/qcUid3omRzaVG59.png" alt="1569036847226.png"></p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>这个算法由于空间复杂度有o(n*2^n)，所以做一般的算法题要用到状态压缩，用0代表没有到达该城市，1代表去过该城市。例如：11011代表1-5个城市只有第三个城市没去过。上述的S集合就是通过状压保存。</p>
<p><img src="https://i.loli.net/2019/09/23/vxHhVn84XWAS1Pp.png" alt="1569036878291.png"></p>
<p>说了这么多，看一下怎么解决，主要分为4个步骤。</p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>（1）选择G的任意一个顶点r作为根节点(出发/结束点)</p>
<p>（2）用Prim算法找出G的一棵以r为根的最小生成树T</p>
<p>（3）前序遍历访问树T，得到遍历顺序组成的顶点表L</p>
<p>（4）将r加到顶点表L的末尾，按L中顶点的次序组成哈密顿回路H</p>
<p>简单的解释一下其中的名词，有需要自己了解</p>
<h4 id="prim算法"><a href="#prim算法" class="headerlink" title="prim算法"></a>prim算法</h4><p>Prim算法如何进行计算？<br>①选定一个起点做为一个集合 a ，剩下的点为另一个集合 b</p>
<p>②将横跨两个集合且权重在其中最小的边加入最小生成树</p>
<p>③将刚刚加入最小生成树的边中不在集合 a 中的点加入集合 a，直到所有的点加入集合 a</p>
<h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><p>首先访问根节点，然后遍历左子树，最后遍历右子树。</p>
<p><img src="https://i.loli.net/2019/09/23/qZefMb7NgIaR1AY.gif" alt="GIF.gif"></p>
<h2 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法"></a>遗传算法</h2><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>遗传算法（Genetic Algorithm, GA）是模拟达尔文生物进化论的自然选择和遗传学机理的生物进化过程的计算模型，是一种通过模拟自然进化过程搜索最优解的方法。</p>
<h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h4><p><img src="https://i.loli.net/2019/09/23/H8VtSwGa3Ax42TJ.png" alt="1569037387267.png"></p>
<p>这里补充一下细节：</p>
<ol>
<li>交叉操作：随机挑取在染色体（路径）上的一个序号（2-n-1）交换两条染色体序号后面的（基因），这里需要进行基因冲突处理，即交换后要检查是否交换过来了已有的基因，如果是则和另一条的重复基因交换。</li>
<li>变异操作，对一条基因选出i，j（0&lt;i&lt;j&lt;=n）将其中的基因交换。</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>TSP</tag>
        <tag>遗传算法</tag>
        <tag>动态规划</tag>
        <tag>Prim</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/08/30/hello-world.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment<img src="/2019/08/30/QQ%E6%88%AA%E5%9B%BE20190815084633.png" alt="QQ截图20190815084633"></a></p>
]]></content>
  </entry>
  <entry>
    <title>ExpressionToValue</title>
    <url>/2020/05/17/ExpressionToValue.html</url>
    <content><![CDATA[<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">

<h1 id="表达式求值-wpf"><a href="#表达式求值-wpf" class="headerlink" title="表达式求值  wpf"></a>表达式求值  wpf</h1><p>主要思想：表达式递归切割求值。</p>
<p>主要分成三个类。Expression，item和factor。</p>
<p><img src="https://i.loli.net/2020/05/18/D36Pi85OzXsHYqI.png" alt="1589730555323.png"></p>
<h1 id="Expression（-）"><a href="#Expression（-）" class="headerlink" title="Expression（+/-）"></a>Expression（+/-）</h1><p>由divStringExp类的divexp（）方法分割字符串</p>
<p>将表达式中的加法和减法消除。</p>
<p>先用栈找出最外层的括号：</p>
<p><img src="https://i.loli.net/2020/05/18/9yvzgBIKtb4h1Fr.png" alt="1589730585178.png"></p>
<p>然后往括号两端扩展</p>
<p><img src="https://i.loli.net/2020/05/18/wQOiU6col4kmjx2.png" alt="1589730598531.png"></p>
<p>切割加号得到两个items</p>
<h1 id="Item"><a href="#Item" class="headerlink" title="Item"></a>Item</h1><p>把字符串分成被除数和除数</p>
<p>分两种情况：有括号和无括号</p>
<h2 id="有括号的情况："><a href="#有括号的情况：" class="headerlink" title="有括号的情况："></a>有括号的情况：</h2><p>同样是用栈判断最外层的括号</p>
<p><img src="https://i.loli.net/2020/05/18/r9RHuIQCJpPechX.png" alt="1589730611640.png"></p>
<p>把括号内的乘号和除号省略，分割外面的乘号和除号</p>
<p>并把除数之间和被除数之间相连（或者用两个数组将分子和分母保存起来）</p>
<p><img src="https://i.loli.net/2020/05/18/MzuFHbxXe1aEsKC.png" alt="1589730620914.png"></p>
<h2 id="没括号的情况："><a href="#没括号的情况：" class="headerlink" title="没括号的情况："></a>没括号的情况：</h2><p>遇到除号将后面的除数加到除数字符串   </p>
<h1 id="Factor"><a href="#Factor" class="headerlink" title="Factor"></a>Factor</h1><p>拆开最外层括号外的乘号</p>
<p>剩下的元素分成5种情况</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="一元函数"><a href="#一元函数" class="headerlink" title="一元函数"></a>一元函数</h4><p>递归求括号内的值，再代入函数</p>
<p>例如sin(exp)</p>
<h4 id="多元函数（目前只有log（a-b）函数）"><a href="#多元函数（目前只有log（a-b）函数）" class="headerlink" title="多元函数（目前只有log（a,b）函数）"></a>多元函数（目前只有log（a,b）函数）</h4><p>例如log(a,log(b,c))，将括号内提出来“a,log(b,c)”</p>
<p>将没在括号内的，分割</p>
<p>分成“a“和”log(b,c)”再分别递归求值。</p>
<h3 id="次方"><a href="#次方" class="headerlink" title="次方"></a>次方</h3><p>求最外层括号外的次方</p>
<p>最外层是括号：</p>
<p>拆括号后递归求值</p>
<p><strong>注意：次方内可能也有多个表达式</strong></p>
<p>例如:2^sin(a)</p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>找coefficient类将值返回</p>
<h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><p>用table.Compute（）方法转化</p>
<h1 id="参数（Coefficient）类"><a href="#参数（Coefficient）类" class="headerlink" title="参数（Coefficient）类"></a>参数（Coefficient）类</h1><p>正则表达式找变量并忽略掉所有的函数名，并初始赋值1</p>
<h1 id="tool类"><a href="#tool类" class="headerlink" title="tool类"></a>tool类</h1><p>装有静态的函数名对象，方便外界访问</p>
<h1 id="界面设计"><a href="#界面设计" class="headerlink" title="界面设计"></a>界面设计</h1><p>Stackpanel中嵌套三个Grid布局</p>
<p><img src="https://i.loli.net/2020/05/18/wpmizh45WgBr3GL.png" alt="1589730840570.png"></p>
<h2 id="Grid布局1"><a href="#Grid布局1" class="headerlink" title="Grid布局1"></a>Grid布局1</h2><p>计算结果用label显示</p>
<h2 id="Grid布局2"><a href="#Grid布局2" class="headerlink" title="Grid布局2"></a>Grid布局2</h2><p>四个listbox分别显示变量名，范围，滑块，变量值</p>
<h2 id="Grid布局3"><a href="#Grid布局3" class="headerlink" title="Grid布局3"></a>Grid布局3</h2><p>输入栏和确定按钮</p>
<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h5 id="确定按钮click事件"><a href="#确定按钮click事件" class="headerlink" title="确定按钮click事件"></a>确定按钮click事件</h5><p>初始化动态添加元素到四个listbox</p>
<h5 id="变量范围keydown事件"><a href="#变量范围keydown事件" class="headerlink" title="变量范围keydown事件"></a>变量范围keydown事件</h5><p>判断输入是否是数字</p>
<h5 id="四个listbox滑动条同步事件"><a href="#四个listbox滑动条同步事件" class="headerlink" title="四个listbox滑动条同步事件"></a>四个listbox滑动条同步事件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VisualTreeHelper.GetChild(VisualTreeHelper.GetChild(this.listBox4, 0), 0) as ScrollViewer;&#x2F;&#x2F;找到scrollviewer对象</span><br><span class="line">		sv4.ScrollChanged +&#x3D; newScrollChangedEventHandler(listBox4_ScrollChanged);</span><br><span class="line">&#x2F;&#x2F;添加事件</span><br><span class="line">        private void listBox4_ScrollChanged(object sender, ScrollChangedEventArgs e)</span><br><span class="line">        &#123;</span><br><span class="line">        if (sv4 !&#x3D; null)</span><br><span class="line">        &#123;</span><br><span class="line">            sv3.ScrollToVerticalOffset(sv4.VerticalOffset);</span><br><span class="line">            sv2.ScrollToVerticalOffset(sv4.VerticalOffset);</span><br><span class="line">            sv1.ScrollToVerticalOffset(sv4.VerticalOffset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="双击变量名产生滑块动画事件"><a href="#双击变量名产生滑块动画事件" class="headerlink" title="双击变量名产生滑块动画事件"></a>双击变量名产生滑块动画事件</h5><p>System.Windows.Threading.DispatcherTimer类用于动画制作</p>
<p>该类用Interval方法设置事件的发生间隔</p>
<p>tmr.Interval = TimeSpan.FromSeconds(0.01);</p>
<p>给他的tick事件添加委托threads方法</p>
<p>start方法启用</p>
<p>判断条件满足后停止</p>
<p>end方法终止</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void animation(object sender, RoutedEventArgs e)</span><br><span class="line">        &#123;</span><br><span class="line">            Label label &#x3D; sender as Label;</span><br><span class="line">            int count &#x3D; 0;</span><br><span class="line">            foreach(Label l1 in listBox1.Items)</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">                if (l1 &#x3D;&#x3D; label)</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            ProcessToanimation &#x3D; 0;</span><br><span class="line">            CountToAnimation &#x3D; count;</span><br><span class="line">            System.Windows.Threading.DispatcherTimer tmr &#x3D; new System.Windows.Threading.DispatcherTimer();</span><br><span class="line">            tmr.Interval &#x3D; TimeSpan.FromSeconds(0.01);</span><br><span class="line">            tmr.Tick +&#x3D; new EventHandler(threads);</span><br><span class="line">            tmr.Start();</span><br><span class="line">        &#125;</span><br><span class="line">private void threads(object c,EventArgs e)</span><br><span class="line">    &#123;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            int count &#x3D; CountToAnimation;</span><br><span class="line">            slidersList[count-1].Value &#x3D; ProcessToanimation;</span><br><span class="line">            double td &#x3D; (slidersList[count - 1].Value - 5) * Convert.ToDouble(rangesList[count - 1].Text);</span><br><span class="line">            td &#x3D; td &#x2F; 5;</span><br><span class="line">            valuesList[count - 1].Content &#x3D; td;</span><br><span class="line">            variableCollection.vlist[count - 1].value &#x3D; td;</span><br><span class="line">            exp.setVariables(variableCollection);</span><br><span class="line">            result.Content &#x3D; exp.getValue();</span><br><span class="line">            ProcessToanimation +&#x3D; 0.025;</span><br><span class="line">            if (ProcessToanimation &gt;&#x3D; 10)</span><br><span class="line">            &#123;</span><br><span class="line">                slidersList[count-1].Value &#x3D; 6;</span><br><span class="line">                double ts &#x3D; (slidersList[count - 1].Value - 5) * Convert.ToDouble(rangesList[count - 1].Text)&#x2F;5;</span><br><span class="line">                valuesList[count - 1].Content &#x3D; ts;</span><br><span class="line">                variableCollection.vlist[count - 1].value &#x3D; ts;</span><br><span class="line">                exp.setVariables(variableCollection);</span><br><span class="line">                result.Content &#x3D; exp.getValue();</span><br><span class="line">                (c as System.Windows.Threading.DispatcherTimer).Stop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception e1)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>程序</category>
      </categories>
      <tags>
        <tag>WPF</tag>
        <tag>表达式求值</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ - 1611-day3-F</title>
    <url>/2019/09/01/POJ-1611-day3-F.html</url>
    <content><![CDATA[<h1 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h1><p><a href="http://poj.org/problem?id=1611" target="_blank" rel="noopener">POJ - 1611</a></p>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>Severe acute respiratory syndrome (SARS), an atypical pneumonia of unknown aetiology, was recognized as a global threat in mid-March 2003. To minimize transmission to others, the best strategy is to separate the suspects from others.<br>In the Not-Spreading-Your-Sickness University (NSYSU), there are many student groups. Students in the same group intercommunicate with each other frequently, and a student may join several groups. To prevent the possible transmissions of SARS, the NSYSU collects the member lists of all student groups, and makes the following rule in their standard operation procedure (SOP).<br>Once a member in a group is a suspect, all members in the group are suspects.<br>However, they find that it is not easy to identify all the suspects when a student is recognized as a suspect. Your job is to write a program which finds all the suspects.</p>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><p>The input file contains several cases. Each test case begins with two integers n and m in a line, where n is the number of students, and m is the number of groups. You may assume that 0 &lt; n &lt;= 30000 and 0 &lt;= m &lt;= 500. Every student is numbered by a unique integer between 0 and n−1, and initially student 0 is recognized as a suspect in all the cases. This line is followed by m member lists of the groups, one line per group. Each line begins with an integer k by itself representing the number of members in the group. Following the number of members, there are k integers representing the students in this group. All the integers in a line are separated by at least one space.<br>A case with n = 0 and m = 0 indicates the end of the input, and need not be processed.</p>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><p>For each case, output the number of suspects in one line.</p>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>input</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">100 4</span><br><span class="line">2 1 2</span><br><span class="line">5 10 13 11 12 14</span><br><span class="line">2 0 1</span><br><span class="line">2 99 2</span><br><span class="line">200 2</span><br><span class="line">1 5</span><br><span class="line">5 1 2 3 4 5</span><br><span class="line">1 0</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure>

<p>output</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>并查集，找与0有关的所有人，用bb数组来存放头目有关的人数，最后找0的头目，就能在数组里找到所有与他有关的人。</p>
<h1 id="AC的代码"><a href="#AC的代码" class="headerlink" title="AC的代码"></a>AC的代码</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> gro,s,aa[<span class="number">30005</span>],bb[<span class="number">30005</span>],cc[<span class="number">30005</span>];    <span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span>                 <span class="comment">//寻找根节点的函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (aa[x] == x)</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		aa[x] = <span class="built_in">find</span>(aa[x]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x1 = <span class="built_in">find</span>(x);</span><br><span class="line">	<span class="keyword">int</span> y1 = <span class="built_in">find</span>(y);</span><br><span class="line">	<span class="keyword">if</span> (x1 != y1)            <span class="comment">//根节点不同连接</span></span><br><span class="line">	&#123;</span><br><span class="line">		aa[x1] = y1;</span><br><span class="line">		bb[y1] = bb[x1] + bb[y1];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s &gt;&gt; gro)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (s == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; <span class="number">30005</span>; r++)</span><br><span class="line">		&#123;</span><br><span class="line">			aa[r] = r;</span><br><span class="line">			bb[r] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> f = <span class="number">0</span>; f &lt; gro; f++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> p;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;p);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> q = <span class="number">0</span>; q &lt; p; q++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;cc[q]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; p - <span class="number">1</span>; x++)</span><br><span class="line">			&#123;</span><br><span class="line">				join(cc[x], cc[x + <span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> k = <span class="built_in">find</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; bb[k] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>天国旅立</title>
    <url>/2019/09/09/%E5%A4%A9%E5%9B%BD%E6%97%85%E7%AB%8B.html</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/09/09/IcUw5WsjhbGYmlT.png" alt="Saved_Memory2.png"><br><img src="https://i.loli.net/2019/09/09/XDAKdzLsoYnP3HF.png" alt="Saved_Memory8.png"><br><img src="https://i.loli.net/2019/09/09/KtRvuZnfELqWC9k.png" alt="Saved_Memory9.png"><br><img src="https://i.loli.net/2019/09/09/QCnb92H8UfmLEkO.png" alt="Saved_Memory10.png"><br><img src="https://i.loli.net/2019/09/09/WYmx4RS1ebr6DIF.png" alt="Saved_Memory3.png"><br><img src="https://i.loli.net/2019/09/09/BV2Fr1oiyPvDxqd.png" alt="Saved_Memory4.png"><br><img src="https://i.loli.net/2019/09/09/ihdkgzsEnYFUTN7.png" alt="Saved_Memory6.png"><br><img src="https://i.loli.net/2019/09/09/YJrthXoDLxFyTGq.png" alt="Saved_Memory1.png"><br><img src="https://i.loli.net/2019/09/09/PlLtiIhN3yRA4ns.png" alt="Saved_Memory5.png"><br><img src="https://i.loli.net/2019/09/09/nz9eSMLa5yUxvfK.png" alt="Saved_Memory7.png"><br><img src="https://i.loli.net/2019/09/09/xagRIqXjJKv2ny7.png" alt="Saved_Memory11.png"><br><img src="https://i.loli.net/2019/09/09/tT4IaXVMRHxGJsS.png" alt="Saved_Memory14.png"><br><img src="https://i.loli.net/2019/09/09/pDMBcbTXQK1Asg5.png" alt="Saved_Memory12.png"><br><img src="https://i.loli.net/2019/09/09/b3wZcoDHPxG21dm.png" alt="Saved_Memory13.png"><br><img src="https://p.pstatp.com/origin/fe8f000115e907fd41cd" alt="Saved_Memory15.png"></p>
]]></content>
      <tags>
        <tag>Gallery</tag>
      </tags>
  </entry>
  <entry>
    <title>test_pic</title>
    <url>/2019/09/01/test-pic.html</url>
    <content><![CDATA[<p>微博的图床：<a href="https://pic.lizenghai.com/#" target="_blank" rel="noopener">https://pic.lizenghai.com/#</a><br>每日最多上传100张。还可能会失败？<br><img src="http://wx3.sinaimg.cn/large/9cd3e769gy1g6kg8jv0uwj20gi0jyh1c.jpg" alt="aaa"></p>
<p>github图：<br>可能dns污染上不去。<br><img src="/2019/09/01/test-pic%5Caaa.jpg" alt="testgithub图"></p>
<p>sm.ms图床：官网地址：<a href="https://sm.ms" target="_blank" rel="noopener">https://sm.ms</a><br>特点：永久存储免注册，图片链接支持https，可以删除上传的图片，提供多种图片链接格式<br>图片上传限制：每个图片最大5M，每次最多上传10张<br><img src="https://i.loli.net/2019/09/01/himBgnrRaPVld1T.png" alt="20190815084633.png"></p>
<p>聚合图床：官网地址： <a href="https://www.superbed.cn/" target="_blank" rel="noopener">https://www.superbed.cn/</a><br>特点：将图片分发到多处备份，借助其本身的CDN加速功能，节省服务器流量，不用担心图片被删除。<br><img src="https://ae01.alicdn.com/kf/H95cba61bf4a14818b70ccb89894b900ci.png" alt="aaa"></p>
]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
</search>
