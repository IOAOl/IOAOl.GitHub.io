<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ExpressionToValue</title>
    <url>/ExpressionToValue.html</url>
    <content><![CDATA[<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">

<h1 id="表达式求值-wpf"><a href="#表达式求值-wpf" class="headerlink" title="表达式求值  wpf"></a>表达式求值  wpf</h1><p>主要思想：表达式递归切割求值。</p>
<p>主要分成三个类。Expression，item和factor。</p>
<p><img src="https://i.loli.net/2020/05/18/D36Pi85OzXsHYqI.png" alt="1589730555323.png"></p>
<h1 id="Expression（-）"><a href="#Expression（-）" class="headerlink" title="Expression（+/-）"></a>Expression（+/-）</h1><p>由divStringExp类的divexp（）方法分割字符串</p>
<p>将表达式中的加法和减法消除。</p>
<p>先用栈找出最外层的括号：</p>
<p><img src="https://i.loli.net/2020/05/18/9yvzgBIKtb4h1Fr.png" alt="1589730585178.png"></p>
<p>然后往括号两端扩展</p>
<p><img src="https://i.loli.net/2020/05/18/wQOiU6col4kmjx2.png" alt="1589730598531.png"></p>
<p>切割加号得到两个items</p>
<h1 id="Item"><a href="#Item" class="headerlink" title="Item"></a>Item</h1><p>把字符串分成被除数和除数</p>
<p>分两种情况：有括号和无括号</p>
<h2 id="有括号的情况："><a href="#有括号的情况：" class="headerlink" title="有括号的情况："></a>有括号的情况：</h2><p>同样是用栈判断最外层的括号</p>
<p><img src="https://i.loli.net/2020/05/18/r9RHuIQCJpPechX.png" alt="1589730611640.png"></p>
<p>把括号内的乘号和除号省略，分割外面的乘号和除号</p>
<p>并把除数之间和被除数之间相连（或者用两个数组将分子和分母保存起来）</p>
<p><img src="https://i.loli.net/2020/05/18/MzuFHbxXe1aEsKC.png" alt="1589730620914.png"></p>
<h2 id="没括号的情况："><a href="#没括号的情况：" class="headerlink" title="没括号的情况："></a>没括号的情况：</h2><p>遇到除号将后面的除数加到除数字符串   </p>
<h1 id="Factor"><a href="#Factor" class="headerlink" title="Factor"></a>Factor</h1><p>拆开最外层括号外的乘号</p>
<p>剩下的元素分成5种情况</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="一元函数"><a href="#一元函数" class="headerlink" title="一元函数"></a>一元函数</h4><p>递归求括号内的值，再代入函数</p>
<p>例如sin(exp)</p>
<h4 id="多元函数（目前只有log（a-b）函数）"><a href="#多元函数（目前只有log（a-b）函数）" class="headerlink" title="多元函数（目前只有log（a,b）函数）"></a>多元函数（目前只有log（a,b）函数）</h4><p>例如log(a,log(b,c))，将括号内提出来“a,log(b,c)”</p>
<p>将没在括号内的，分割</p>
<p>分成“a“和”log(b,c)”再分别递归求值。</p>
<h3 id="次方"><a href="#次方" class="headerlink" title="次方"></a>次方</h3><p>求最外层括号外的次方</p>
<p>最外层是括号：</p>
<p>拆括号后递归求值</p>
<p><strong>注意：次方内可能也有多个表达式</strong></p>
<p>例如:2^sin(a)</p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>找coefficient类将值返回</p>
<h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><p>用table.Compute（）方法转化</p>
<h1 id="参数（Coefficient）类"><a href="#参数（Coefficient）类" class="headerlink" title="参数（Coefficient）类"></a>参数（Coefficient）类</h1><p>正则表达式找变量并忽略掉所有的函数名，并初始赋值1</p>
<h1 id="tool类"><a href="#tool类" class="headerlink" title="tool类"></a>tool类</h1><p>装有静态的函数名对象，方便外界访问</p>
<h1 id="界面设计"><a href="#界面设计" class="headerlink" title="界面设计"></a>界面设计</h1><p>Stackpanel中嵌套三个Grid布局</p>
<p><img src="https://i.loli.net/2020/05/18/wpmizh45WgBr3GL.png" alt="1589730840570.png"></p>
<h2 id="Grid布局1"><a href="#Grid布局1" class="headerlink" title="Grid布局1"></a>Grid布局1</h2><p>计算结果用label显示</p>
<h2 id="Grid布局2"><a href="#Grid布局2" class="headerlink" title="Grid布局2"></a>Grid布局2</h2><p>四个listbox分别显示变量名，范围，滑块，变量值</p>
<h2 id="Grid布局3"><a href="#Grid布局3" class="headerlink" title="Grid布局3"></a>Grid布局3</h2><p>输入栏和确定按钮</p>
<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h5 id="确定按钮click事件"><a href="#确定按钮click事件" class="headerlink" title="确定按钮click事件"></a>确定按钮click事件</h5><p>初始化动态添加元素到四个listbox</p>
<h5 id="变量范围keydown事件"><a href="#变量范围keydown事件" class="headerlink" title="变量范围keydown事件"></a>变量范围keydown事件</h5><p>判断输入是否是数字</p>
<h5 id="四个listbox滑动条同步事件"><a href="#四个listbox滑动条同步事件" class="headerlink" title="四个listbox滑动条同步事件"></a>四个listbox滑动条同步事件</h5><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">VisualTreeHelper.GetChild(VisualTreeHelper.GetChild(<span class="keyword">this</span>.listBox4, <span class="number">0</span>), <span class="number">0</span>) <span class="keyword">as</span> ScrollViewer;<span class="comment">//找到scrollviewer对象</span></span><br><span class="line">		sv4.ScrollChanged += newScrollChangedEventHandler(listBox4_ScrollChanged);</span><br><span class="line"><span class="comment">//添加事件</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">listBox4_ScrollChanged</span>(<span class="params"><span class="built_in">object</span> sender, ScrollChangedEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">        <span class="keyword">if</span> (sv4 != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sv3.ScrollToVerticalOffset(sv4.VerticalOffset);</span><br><span class="line">            sv2.ScrollToVerticalOffset(sv4.VerticalOffset);</span><br><span class="line">            sv1.ScrollToVerticalOffset(sv4.VerticalOffset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="双击变量名产生滑块动画事件"><a href="#双击变量名产生滑块动画事件" class="headerlink" title="双击变量名产生滑块动画事件"></a>双击变量名产生滑块动画事件</h5><p>System.Windows.Threading.DispatcherTimer类用于动画制作</p>
<p>该类用Interval方法设置事件的发生间隔</p>
<p>tmr.Interval = TimeSpan.FromSeconds(0.01);</p>
<p>给他的tick事件添加委托threads方法</p>
<p>start方法启用</p>
<p>判断条件满足后停止</p>
<p>end方法终止</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">animation</span>(<span class="params"><span class="built_in">object</span> sender, RoutedEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Label label = sender <span class="keyword">as</span> Label;</span><br><span class="line">            <span class="built_in">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">foreach</span>(Label l1 <span class="keyword">in</span> listBox1.Items)</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span> (l1 == label)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ProcessToanimation = <span class="number">0</span>;</span><br><span class="line">            CountToAnimation = count;</span><br><span class="line">            System.Windows.Threading.DispatcherTimer tmr = <span class="keyword">new</span> System.Windows.Threading.DispatcherTimer();</span><br><span class="line">            tmr.Interval = TimeSpan.FromSeconds(<span class="number">0.01</span>);</span><br><span class="line">            tmr.Tick += <span class="keyword">new</span> EventHandler(threads);</span><br><span class="line">            tmr.Start();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">threads</span>(<span class="params"><span class="built_in">object</span> c,EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> count = CountToAnimation;</span><br><span class="line">            slidersList[count<span class="number">-1</span>].Value = ProcessToanimation;</span><br><span class="line">            <span class="built_in">double</span> td = (slidersList[count - <span class="number">1</span>].Value - <span class="number">5</span>) * Convert.ToDouble(rangesList[count - <span class="number">1</span>].Text);</span><br><span class="line">            td = td / <span class="number">5</span>;</span><br><span class="line">            valuesList[count - <span class="number">1</span>].Content = td;</span><br><span class="line">            variableCollection.vlist[count - <span class="number">1</span>].<span class="keyword">value</span> = td;</span><br><span class="line">            exp.setVariables(variableCollection);</span><br><span class="line">            result.Content = exp.getValue();</span><br><span class="line">            ProcessToanimation += <span class="number">0.025</span>;</span><br><span class="line">            <span class="keyword">if</span> (ProcessToanimation &gt;= <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                slidersList[count<span class="number">-1</span>].Value = <span class="number">6</span>;</span><br><span class="line">                <span class="built_in">double</span> ts = (slidersList[count - <span class="number">1</span>].Value - <span class="number">5</span>) * Convert.ToDouble(rangesList[count - <span class="number">1</span>].Text)/<span class="number">5</span>;</span><br><span class="line">                valuesList[count - <span class="number">1</span>].Content = ts;</span><br><span class="line">                variableCollection.vlist[count - <span class="number">1</span>].<span class="keyword">value</span> = ts;</span><br><span class="line">                exp.setVariables(variableCollection);</span><br><span class="line">                result.Content = exp.getValue();</span><br><span class="line">                (c <span class="keyword">as</span> System.Windows.Threading.DispatcherTimer).Stop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception e1)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>程序</category>
      </categories>
      <tags>
        <tag>WPF</tag>
        <tag>表达式求值</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ - 1611-day3-F</title>
    <url>/POJ-1611-day3-F.html</url>
    <content><![CDATA[<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">

<h1 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h1><p><a href="http://poj.org/problem?id=1611">POJ - 1611</a></p>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>Severe acute respiratory syndrome (SARS), an atypical pneumonia of unknown aetiology, was recognized as a global threat in mid-March 2003. To minimize transmission to others, the best strategy is to separate the suspects from others.<br>In the Not-Spreading-Your-Sickness University (NSYSU), there are many student groups. Students in the same group intercommunicate with each other frequently, and a student may join several groups. To prevent the possible transmissions of SARS, the NSYSU collects the member lists of all student groups, and makes the following rule in their standard operation procedure (SOP).<br>Once a member in a group is a suspect, all members in the group are suspects.<br>However, they find that it is not easy to identify all the suspects when a student is recognized as a suspect. Your job is to write a program which finds all the suspects.</p>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><p>The input file contains several cases. Each test case begins with two integers n and m in a line, where n is the number of students, and m is the number of groups. You may assume that 0 &lt; n &lt;= 30000 and 0 &lt;= m &lt;= 500. Every student is numbered by a unique integer between 0 and n−1, and initially student 0 is recognized as a suspect in all the cases. This line is followed by m member lists of the groups, one line per group. Each line begins with an integer k by itself representing the number of members in the group. Following the number of members, there are k integers representing the students in this group. All the integers in a line are separated by at least one space.<br>A case with n = 0 and m = 0 indicates the end of the input, and need not be processed.</p>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><p>For each case, output the number of suspects in one line.</p>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>input</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">100 4</span><br><span class="line">2 1 2</span><br><span class="line">5 10 13 11 12 14</span><br><span class="line">2 0 1</span><br><span class="line">2 99 2</span><br><span class="line">200 2</span><br><span class="line">1 5</span><br><span class="line">5 1 2 3 4 5</span><br><span class="line">1 0</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure>
<p>output</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>并查集，找与0有关的所有人，用bb数组来存放头目有关的人数，最后找0的头目，就能在数组里找到所有与他有关的人。</p>
<h1 id="AC的代码"><a href="#AC的代码" class="headerlink" title="AC的代码"></a>AC的代码</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> gro,s,aa[<span class="number">30005</span>],bb[<span class="number">30005</span>],cc[<span class="number">30005</span>];    <span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span>                 <span class="comment">//寻找根节点的函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (aa[x] == x)</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		aa[x] = find(aa[x]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x1 = find(x);</span><br><span class="line">	<span class="keyword">int</span> y1 = find(y);</span><br><span class="line">	<span class="keyword">if</span> (x1 != y1)            <span class="comment">//根节点不同连接</span></span><br><span class="line">	&#123;</span><br><span class="line">		aa[x1] = y1;</span><br><span class="line">		bb[y1] = bb[x1] + bb[y1];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s &gt;&gt; gro)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (s == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; <span class="number">30005</span>; r++)</span><br><span class="line">		&#123;</span><br><span class="line">			aa[r] = r;</span><br><span class="line">			bb[r] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> f = <span class="number">0</span>; f &lt; gro; f++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> p;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;p);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> q = <span class="number">0</span>; q &lt; p; q++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;cc[q]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; p - <span class="number">1</span>; x++)</span><br><span class="line">			&#123;</span><br><span class="line">				join(cc[x], cc[x + <span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> k = find(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; bb[k] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>TSPppt</title>
    <url>/TSPppt.html</url>
    <content><![CDATA[<me ta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">


<h1 id="TSP的几个算法"><a href="#TSP的几个算法" class="headerlink" title="TSP的几个算法"></a>TSP的几个算法</h1><p>这是一个自己做的ppt的记录。</p>
<h2 id="TSP实例"><a href="#TSP实例" class="headerlink" title="TSP实例"></a>TSP实例</h2><p>有一位商人，他想访问德国的某些城市，要求：</p>
<ol>
<li>所走路程最短；</li>
<li>每个城市只能访问一次；</li>
<li>从某城市出发，最后回到该城市。</li>
</ol>
<p><img src="https://i.loli.net/2019/09/23/ivBU6RxodJYnZKr.png" alt="1568996702133 - 副本.png"></p>
<p>让我们看一下为什么要学这个问题，主要来看一下tsp到底有什么用。</p>
<p><img src="https://i.loli.net/2020/08/21/FcSKANeDQJy5Zdo.png" alt="tspzuoyong.png"></p>
<p>看完了应用，我们来看一下怎么去解决这个问题吧</p>
<p>首先先任意选一个点作为起点，然后开始连接就可以看到有n！种情况</p>
<p><img src="https://i.loli.net/2019/09/23/iCTeADruUnYm9Ia.png" alt="1569036262994 - 副本.png"></p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>我们尝试优化一下，目前最好的优化是通过动态规划去解决，复杂度为o（2^n*n^2）</p>
<p>首先得懂得为什么可以使用动态规划，<strong>动态规划就是在求解一个复杂问题时，将其分解为若干个简单问题。通过求解简单问题的最优解，来找到目标问题的最优解。</strong></p>
<p><strong>使用动态规划，需要问题本身有最优子结构</strong>，我们需要找到要解决的问题的子问题。</p>
<p>现在找一下tsp的最优子结构</p>
<p><img src="https://i.loli.net/2019/09/23/WFVGmarTHC384hi.png" alt="1569036739438 - 副本.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">从0出发，经过[1,2,3]这几个城市，然后回到0，使得花费最少。要实现这个要求，需要从下面三个实现方案中选择花费最少的方案。</span><br></pre></td></tr></table></figure>
<p>　　　　1、 从0出发，到1，然后再从1出发，经过[2,3]这几个城市，然后回到0，使得花费最少。</p>
<p>　　　　2、 从0出发，到2，然后再从2出发，经过[1,3]这几个城市，然后回到0，使得花费最少。</p>
<p>　　　　3、 从0出发，到3，然后再从3出发，经过[1,2]这几个城市，然后回到0，使得花费最少。<br>  可以发现，三个小的解决方案的最优解，构成了大的解决方案，所以这个问题具有最优子结构，可以用动态规划来实现。</p>
<p><img src="https://i.loli.net/2019/09/23/qcUid3omRzaVG59.png" alt="1569036847226.png"></p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>这个算法由于空间复杂度有o(n*2^n)，所以做一般的算法题要用到状态压缩，用0代表没有到达该城市，1代表去过该城市。例如：11011代表1-5个城市只有第三个城市没去过。上述的S集合就是通过状压保存。</p>
<p><img src="https://i.loli.net/2019/09/23/vxHhVn84XWAS1Pp.png" alt="1569036878291.png"></p>
<p>说了这么多，看一下怎么解决，主要分为4个步骤。</p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>（1）选择G的任意一个顶点r作为根节点(出发/结束点)</p>
<p>（2）用Prim算法找出G的一棵以r为根的最小生成树T</p>
<p>（3）前序遍历访问树T，得到遍历顺序组成的顶点表L</p>
<p>（4）将r加到顶点表L的末尾，按L中顶点的次序组成哈密顿回路H</p>
<p>简单的解释一下其中的名词，有需要自己了解</p>
<h4 id="prim算法"><a href="#prim算法" class="headerlink" title="prim算法"></a>prim算法</h4><p>Prim算法如何进行计算？<br>①选定一个起点做为一个集合 a ，剩下的点为另一个集合 b</p>
<p>②将横跨两个集合且权重在其中最小的边加入最小生成树</p>
<p>③将刚刚加入最小生成树的边中不在集合 a 中的点加入集合 a，直到所有的点加入集合 a</p>
<h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><p>首先访问根节点，然后遍历左子树，最后遍历右子树。</p>
<p><img src="https://i.loli.net/2019/09/23/qZefMb7NgIaR1AY.gif" alt="GIF.gif"></p>
<h2 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法"></a>遗传算法</h2><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>遗传算法（Genetic Algorithm, GA）是模拟达尔文生物进化论的自然选择和遗传学机理的生物进化过程的计算模型，是一种通过模拟自然进化过程搜索最优解的方法。</p>
<h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h4><p><img src="https://i.loli.net/2019/09/23/H8VtSwGa3Ax42TJ.png" alt="1569037387267.png"></p>
<p>这里补充一下细节：</p>
<ol>
<li>交叉操作：随机挑取在染色体（路径）上的一个序号（2-n-1）交换两条染色体序号后面的（基因），这里需要进行基因冲突处理，即交换后要检查是否交换过来了已有的基因，如果是则和另一条的重复基因交换。</li>
<li>变异操作，对一条基因选出i，j（0&lt;i&lt;j&lt;=n）将其中的基因交换。</li>
</ol>
</me>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>TSP</tag>
        <tag>遗传算法</tag>
        <tag>动态规划</tag>
        <tag>Prim</tag>
      </tags>
  </entry>
  <entry>
    <title>Summer Pockets -REFLECTION BLUE- 玩后感</title>
    <url>/Summer-Pockets-REFLECTION-BLUE-%E7%8E%A9%E5%90%8E%E6%84%9F.html</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">Hey, password is required here.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="e560c5b15835a256035331a81c198d7a2d017e317ba73ac3c0b7aa989dc31e5f">4630436162ade97ba2718b7d0c4b3b635f06c2f714fc5ab1e5fc4a1c12dda4338403796addb4284117cef0f96a80096b88fbd575dc7153d48d411ffa456c9d72c4c33d14fbf675ec19b8877f8103ac6286bed5a9b1d5cc1c6c508c184e8e2a8bf85599e6c7adaad34ff1fd08a0c9f04317bc0adf8eb2cca5ef0fcace2216ed50176e4e0cebef0339953978b5f3d423a9ba2a0be4b48cbae0962cde5ac758dc29a698d451b6d8545310fe39121714ff2d4a3f2f4b7ab2c2f415e26379882ac0675705439ea2b1b00791d7bdbd2c038132a774363493c96e182a43ff37b6f66d0d4faadc2a670de34d0d6f3d37959c5c33032833501c78f0faa6f80492497ede9570bc6dabe8aa27364b077622d02d9bae80cdae46ee2185c7616c65099806cc706e58fecef21579f156ab7f24fe5025816d7d958724c65c6794a0f2500d8f2803a2a2b9490a7dadc97417431ef7fee5dc9ecbf2d18b9543127abdbb16a3e45c8a119d9d6806bbc6fe80281cbd169dc09ff51635535d5850c282f041a17f6ba0510919fa5198b7b563d3bed863fb1e60e16031b07c92d66d31889e607100c169e28b1f7c272f534ad5192deb802ec642c9ba22fd853eb8e1b4ad65fdb9ac255b90230e078c06a50a1183dc3570713f7e660e9bc8a435cdd4ea36fbd3261a41fc5eb39c3903e1a92e7269f0e632936983afa98cf4dcf5a910c7398c9afd871bc2f34ec0a43f6bb19b65ad76c9faa61934b51e2b6b4b41fb641ea587cf8a9fe48fc663eb0086d61c479074ad54abcb821a6edde1ec27db5d161ebc419022c8342569cea91e45e1b023bdce35bd8c9d385326ccd68682d9e1d089d7341986a69e744ca10f7f4bb1b5690476e8dfff6f5b88e213cbe41c3b5909a9e4c96c84b66767622d99b8f9b3660afd8a296370f5988361122186ba2df10104781c0fba5642eebf380df35cff896de09119b5c260d9c099f962ad134a3a1bebe413dedd27832633c59cbdd09526870d7ba7677834dd5450ac1b1a02239762fda7aaad9cf0c321d1d40d141c06075ce253e204fe44142597750944af002e7bd29dd9bdb1878db19d3f40fd38e3ccd1aa3e8a316c2ecb39e007f5108fee55f16b00e3c15a58d98a05db490285b37405ae866a21e553f301b931a40de5d6bd67efccb32ce231d8e6d7acb5df4b38448bcac05e334d2157bf8f78f9d8a6df70e37929b4ce064f5e8fcb2c54594ccb1f57ae74d18a11616717571eaed0d70ef0f45c1630832d8fc0136df8c661a4b0b71eae095b61a43c19a25786c35c5b6843b5dda99b24cddb4cc7cd5067d36a6580f33773e3286b0bf163c3519e940c687e4fd9893fa7e7837b756a8232a18516a2361de90b7088bcc90f78da657b5e2248656518fcd1475e30dc39bda357395bd3f42194136c640d23a78c60efc4ac8251e0e7d6d4f232ae0db5caca3b52bd172e448d6ccebcf19db6cc64d971d54e2758850f37f8539a0ba910cbc8a92e9289cd442c5d8b07610632feb270cf389b43a89749ce6a95f1ce0e080b9a25fdafea40f8e4783ae2739f742de406fe459bef9136a42d9a21bc71628a59694d4585f53279a16c069f611fdba3c637cbe65cd54be1c07f713eb64b953958a4d5d4ecc917a954719227430a26fb176b15174655a1498f8ab787677eabe83ca500ccf7dac8b5040278e9c097bcc590cd7b57ee1750aef6adebaa6e6ba3f33e4f5199b45be60ad97d976a02f24518016e4e81d43bc0a6485a015a033eac8c61cd1e9941d66c3936933477b128be46099fc1378a0b61be807c945facd886b0313fa04f28174350983f8d82c00fe2a0ee6acfd0f42d817b2eb984134f5a82e67a9d83988555c730f42286e149db732202c44ef80ecf1a39ca7b4648450da6f253511c4cf46c1a0423e675e4e04694653934b6c0a49ba9ac6ebf9b65017113263f349dadfd9e05fe36867d372ec3ce22b854aed912790af005d9db9ba9f3f5ba05356d87e659672ca5fe291562ac872fda6625b3915ee545efc5efc5d41fcd6310466da633a2a40a7cc1871fc465dc43603dc9e67beb386865e449199b48942a180b5c055940ed3ae1437819fcbea2d42771edeff3e9227349fd4a615c981039254e8296108287e33f8a242a55bf8630dcd28208e8dc861872c1783318c8e7fd25fa9ca1ff2e513e881ad25524f890c398b208398dc9c39bf30e99cf3bb6310f573bdd28866aabc51caaed0eb63b91f14d89b34d519f8a5b20a6b57e07dc92882c0aac6389120934e301ddf0cfb4d586736a5f537866db7ee81b292d43f15c8447eb1a0e6548e9c693a45a88a8108f23f407fc314630f8f9f2943dae92cd847d068721e7cf4f1fa8601d1e9f2ca9343e018066cc164e7042da98a0985618796cfb5b728569c0edea7b18a3fa547d54f375dd0ad44c5abab50b475d35cbbc8b1d6c0c85e2d5e65a464fab5f367f0a09c6bad4df28680f9ec7798edb869f5e25952815429a84348891cd32de01e8ab7fe480092648adf0c6909562f6071899af0356080320d51df1de35eeb3c51053cc7b60039402655daaa933cfd50b1996599e11a44fc2d46736e0bce0e5705ea669adb349659dadacb07eb08b90cb7f6d2fee5c5a159fc58c6cbb104495be19ec79c50058a30834f97fabe4454f673e02a62dc8256c19c2322f17b98985c89b007305f2e5d026a3caa2977c72a2ac5e124565573cab928cc26b86bce205bec4ef769e0ce6c4583fb1e564ba8752f9a1b23ed45cbaa5a95234a17da1ccdd3ab19d1e0e3b383cb108f7961ddca0cdf7e2c2b08add57e9071cabdab7216733479e05e91db56c6c649ba17140b368e4c3eac8e32e09c02cb7534325171c7ecd00ac9a0ef0e89a05256f231998486dbe6c24b9c80bfb769c44601dcc0fc61dc5609072d4dba31a0d34116a93088bd4d01b7a20b1be55ab668b81d3d285b7d53432f664849a933619312a5b840af39e7419520ac9fad4a295df9c10c2407de55e071c4a7520f1f0c448072f37fdd11ef249bf905157136aebd4d839327846cc5777f343272dd8ba6eba8936e0c536a3594816fe923c13e8ac918bd372a0760407c199e02b55900a3097f77f55dd1b3a14d7cdf748c90bcafc8dd60a5d413a03b439ed4206f25b6b48128c14bace6da8bc469c95f0bc6a5bc0b8176bf25224893ee32623f4280730a8caa4995ce71f6ff5effb9bd13438ec8f84e0c74f3a34365dc978196c160f3f88a8acd827b0e28f914fda7de6b3fa7207c32657950d2e6d490d5f0f5e7335c1ba689b2ec9c41847cc44665234325b7c79aab7107bf5b156d4b723b90d5dea867be7a66eb0d8f43f9a456b51db13cd36dafaa091544eb5f07162255340c26cfccb6a01c0fac28d57b53fe6490fab9b61a630a56a4d1e75b816daab68451115f71c720809cf73bbd4f9f59d930c7a4b1961ea97f6e6bcbdcdcb4b4c3eff90e0aaef249f89e77ada219c8548570c8edf82edff94df9766a7e90d09deff7d022fb52280ab0b0e6d2416f0e42620d2b933cb4eebbafd1711c5793c45414e8efc7c1458c1da7d0e7ce2c5dfc00c9dd06989da7b3f990ca6c10d2051f9961284641c40f3627e871834690399ddc83eb7a76b173008a78b20e99dafcbb03e51179e5e92434af0034a9e60ddbb97dc168e9bef0e4c7b775b97da44a5c3598904f8de3179cc5608c7282ad6e2be2ed9556b1a26d8c4e144d8d02656a73daeff5d934c7024538097650b52cff3de01e925a4ae5405d345417e1c9a9d7ea96a7891cbabe550b0dc07791cf1134743bee748ef1321890039d828393a4f7d3cb42ad56734d0d604271c147263dd6c47d4e6bf453468c3c4004b37d2975459597e0e730644625763e9a08cd9207ea111bddb76d1bbd359358b8fa6ca617f54d3198d39fa472e72c600543d0e124b0477f8cf84230d33fd5a0c0e591b26968e490edf367578d5d8e24ee7c012ea258ccea342c1d0b307d7ee360f9fca01a3b0b39b9c4242e94a2c37ba8020b11242ec560929c6549a0a3169d4feeabdbf7b2280941145aab0d301f4803adf4073c367ad2b398ed7851700cda762cb80601e090da7306c2c5252070dce59b50620f49767a1f8f5c7a6888a35071ba21b4814c8e84bba68589511a975490fce1791c5c75533020e0589701ea2b802084ad4263bb355eb87477f7108397e4ee9137051c933ae21918b090eb4a87fcce43f4eb10b03c8ac0757c68e8eb440ca4b320b3bdd22658a35e89d71e9fd296c3f0eb27b0023e1ddcd5856ffdca7ffe7bd89ccff49bbda35c194069918f781da5b7df4c43c013c3d7dc880f35cf669d599c008f7010d0ac43cebe39941d43d9c3cd53de5f5c033dab86448ee9eff63d5571970afc7caae360b7c30df6f217a5e8e2ce184b50cb3fa2542b62d853341d3079126d90b846d84f779059cf5b465300d83d3ccc12a82a58acd09bb09a7e6173711bdc4bb7fd5d366bd9cf2eeed95517aaa9ce1d3495574170998e2f1cbb8bbde016f440f517c4de031c52ea205a22e5393e2b8bcc7f2964485bb8105aae4cfa5de1c469aebf664f076a2cfdd0f16b0aa919200c064d0159c0ce54c435ee9570c51fbb100f0d5dd3ce0231611f0990c4a53e34c24c25c995160d76db787f0a56c220dae7f35e99e346749412ce02b0169a2b9265b9d55d4570fe87b468ce22829394729d45945255444093c5b401159e0d17cc8050b57a058ad97e3ffb973691d40ff70b51f07a9e7d69443ef7571b474674c599bd8f8f491e58e94a95e98ef50d858519f767db035861ef515dfafc1bf983344bf48ac4a061dfc0871ecc2255f83fc91c7c06d70778d88c3ca9732f6f50ac81cb62e105b07ed98ef5c61f0bde606fa95f127d9e0f3c6d7c3d09829c27f64c8a30eacc0e0ed2b87f4bb5a6e6662fd2120c092486e1fb6a9fff4a7d394403ed913d2908cfd2d1361b6b73b9891baaf7306728bb5b3ec3f3769b7de16132d234cc256a14b5f09c37dd76521e7f02cca3c1acb82ead0f4a6e99eb49c153b6fbf51711d976d3cda1f8c2302772fea8e41f113996a67464b841084f50ccfe813894cc6d5bc8975c9a9f8cb44c6dc012f2b4d31daeadc0752edb4e0783517df59f644c9cf7c6d57a8d007f2ec95126b5da78b73ffda4b6d1a097af75ed1aa2a4dfb6cc47286ca1887c9bb743b9d6018eca6e4cdccc628cb0227444406f9cb84dc4bf718da49ba773cedfff5ac275d7bc83c6e60044f5b0c16c70fa13777ef199d4b8a78ef4a7ed65e5e925ae2dfbb4553325b394be4e8ef93f55bd6a9ed6d8c052cef8dd11e0948aceaca0d6b8cf81a517db0a95b6e89231a8a350a650ab0953a86cf8eaab2cfada400ee9babd3fee82ebcd00d5cc1e9718b0f7fc6b95ec21c72f5eafc2eb1fe17a4d4c91d12501cda9920cf2715c0aa50859ccc9ccfd40dde3fb79e07aa4aa43ee78dcdd59bf5550b159fb1b5aa9ab0708dade126817cb49f6ebd76d63ab9d512c8b2afe9a430569741fa512ba253aff72524e45971d20b4bf732ef0d37dae3d35fbfc1505ba0cb3d7a7f013d59baa00c2075307349f9ab7e9a39ae1095fbf8e800f1c31e4a09efcc7b44936e5731a8b13b83782c59396581db60ce76079a9a330bcebb94daf421fdc1b5cf540ab9e2aab9bcc8b5e5e332ed0bed7a01e095c8eca57567ea87f3293c07983bcff2ab1c7e425d6b08b382b1daf1a8ad2db97ab8c2ed72603f014d9e2511db308807e528a16750b47174b0bc91fc2aea9beea08db501e98e53e686cfff97f090c5eb2620d0acc10617dda7c2cab78179f4b67125ab24ba40a04e1ba4576ff55eb4f02fc4b3150c0fee2780875c9c684803e50392fcea58be9742a7912b92802a78d89b3c5b4dff772b4f03dbae4585f5e5a5d000edcb0baa24d4d80a05756b91e43634f887c5f3f2006bf5af8f06482cd8aae0901c938a07e48a1d5fa5e72c15108ffc0b54d5d5948a3f73de2a27b9266d435af99a9f909820916380064480e76b70bd38a698d1676501e1f7798202094545590880dca02b3723b30e4eeb03f4b70d0fddad5fc0fd8460798a1612e773d054a83b9c7decf18e6622dfd2ff3baed3ddbdd079fc0ed2fe111dd471b6715172516f6eb9b19f23df9460a3285c0c1ccb65cbcf2d83935099f7d38a78b8900618e7290e2d62f3e740540d1a95a5359a56700cadf7d22e0bdf383494c69c07cb4efe56d6b208e31d39a71c6bf1fff74d591dd888ead268abe02d2f3b5d8fa2ba17a84308459660c6b107cb1c622b0671bafcbfe5605b9acb2e3c8974b1ec9502330b35e3b43567e888c9c6282af5bb276d373f241db8ac8a25e4d565fd6fa72e98fa86770e8d328efbdffeaa9e2e455375e8e2ecca374bba74d4c7088ea225d414e96ee6fc62eff7dd7db08c7d562f7131dfedea8ddd44af05cf6ab84079873625e3563c3c4d0cb3f69acca70f22215c906f2348658fc7c26c14ab91d777b53526bf09e68829ca5249fac61fd5c67fef4359c693bc6988621d81d022f77a33c49e6a621a4882deb8e7f825ce7b742cc6d3a329945c43ab23063e18efe70395c851cdc8b5cd5d97b7a43b2ec874a32744824d34917c46b32a0500caea77349e2c974bc786330073caa5a9bc4c119d79b0d799db8031889082ba7e6700cc02a6a5c3194021b983b758765e237285a5c17cfffa39716d6acab21e3b0d98ca2bb3f35d4f7daba80210c9b8867df7e4af3d427dac58060c3fda4a0f05a1cda6922132532775a50969fdb7ca9332c68d4316d037d0c0c6dc78802cfbe602371c7e21c0211c7ff76ddf2dd45724bab29ddf858557e853133e42467eda21a387657525a9ae87e826e25c4d7b580cfdfc6c2c731a946b9d14bdc44b266393a717ab143d9b1303848bfaf96b0e5fdaa242ce3f287c503f7a7d83c9c2c49e68a8ac0cfd5e07811299e120faa2eabdb59870968cae597769a363d33a6016476d03719a8821b108f75f5ce8a65e68b7295a8937411fd02d492a08803a6f37a948efffe88818e05bc13fa7af03855407e9fdc92a2a0035b774d6355160397812c3f16c026d6c0b84012ab91d0360f6355be8996584fed812e712c89b2c230a8fd37e7b31a3220e72f77101a95c8f77bb8b3f7d1348925d443e70411272a61d3de718be04c91195424fb103bf4389aef8b78c43b0954e9507bcb2e16fd96f66481574b78b33fe3f8278623b2a21e8f18c0355be3ca8921b15a7f0dc948069a96f09df94d83896dea98eb940f1345d1de5466682510baa8e385e8ffb5ec3c14709395f78db1761f888172342bc4822ab47923b2396aa2105aafe034ff2f279815d57b5b8f1d084f5583c9edc179f780e8e9c05fafe3e2d8053fd688c5acd4856a9d18f54d9d0b06e6ecbe75cd7cc094a0bc8d1f5502879ee8e76eefb974efec85af960714d30a1de79558db291d7548ce6b04f6d626336fde24d3466b5aab3209c1c222570c88841b3a6c6f0a448987c93a715677d69bb6e5c56cd774d7fa3e5b923672ba946fc7996ff61acea03b8277ddce4746e9de88f58751bf508fb3903799209b02b9681326125494163ef61745b0823f0762ee1e27e964250b715b30d55db5bcb48b69be71978f1f546f9d203c3c2c03c844bb26dcc52538c2fe74ca0fa709be6d5992a7e21132c6b277eb61faa954b5f0e9fd8237debfa70ab1bd33939a6ff4835f6cc4256ece32f300eea0645726c2cb3e69e81c8c1e295fa69ff411faf03abf2c9a53976395b28e7659fe0e7fd5690956ae19fd70bf0fdf0d047147e294f435ad3d0a50189289f7f566e9808289a2578a0e2497e157bd89ae29fca71d7eee25c6711e02f1599704997711808b9c85f29ddf0521ffb6818f5c7eff1f4db7182e8c823e94d41054fd8588972287d405adfbbd0e5777c70849bea9f0c3877820ebc941ead5254e7976302f087c5931a4fcaf9832feb897ba17143013a08cad40f6b959a10d91c6cedd2acc2c017277e73495cf91cfd16ed58ba7aefe7b6dc096acfcfe3887bf5483992f066c3c9e8f814c66816b2aa102b1edf47048f9815765c956d963036787edf2c4d3d804886583c364271186d10242cdc63c7825674cc138a9bdf00f810dd289c14f9921a70775cc573e9faeb643363e6f9867dabc3666a6c211430b4561ea4fc5d96f4ea0f91a95f9b94afa8623a380fea25a13bb64928b88cbe75810a0e042e3a4cd9cd0117cb975b7e68b34f1d8f4fed60837c0a85b5a17e67a86a76916f70211517f57fb59f0b1efd51f51b49cd32c1e98ee6cbebe358ae50051c1da0a145036a4752de242f987ea9461834b93b0405e5e669a1163acbd2f8c46ab9dad8260b023b850731cd6284dc750c35b8848a71e0363f26b346eaca8f6819b7fde8783d0338eb6dbf6846d1c0735f6510f2eb5535f399ca741c94f67cb245c02c54ca2e2dc7c211749d1ec9b6d6bfa6655ae0d7c8388cc8221b82027a3cf43cdcc3f96f0632050e3123b5029d11b7e45f09f8db2c3b1f079eff9e49f17d7063c2f784ecc776a9a2817a33a56c34f5a4e08772c90c8fb1ae7c33bfef47eb8ad1a729bd2a676da2a1cb524d7228a3d54d23dfe2a1736a1b1bd7ad84e803f112ab7b9d4851791f171e2dc5ad5e03dea35438752d71d3ee6473ac1188ffd87eccc59546c9cf90baf820a502be465c3d26dab4f5ae0da7b8848a73fa40d0893f1989c7858fc7ee44e8b84260dcb98e3ab2007c4158fea3be13f904c678cd79c475cb49d6421a1c2e89f220f586dd16cd778049318e55e78b13ee081b04149b8d996b3f3939970f169bcaf1a0173f1a74acf039fa7ab0c5352d0522f9941cff41bfbd6e4a0957816bb99b6a74043e4368ff80464f863acd5d5c4f0f29e4caaa028ef660cc7139a3a13c74e74bfcc47d739aa1527424b1c25d217a88decd6606573439b738334e0f4978e0a2f0ede11a0d8d629ee0733f97784b13669a0b764912df18d4937d7e2be2ffd21fd7844382b0a92fde0753e2c99c73e134a8e802f426a08f1875957b5e2a18795b7fd2ce08cab9bb38e857350e85448645f6a6fa97d7a774bcd5ecb96dbb60899820461df6334db5d3e6ccc566e28b9600dca832dc68779b07d3cccfb68226fbaed6bb665d4a2c8676e7128dbe887386ba9f6ada80d0b4e95b9dd16c1204cc1a4b7dfd8c0ff2442b720387c7427de4f8051085f3c4f77ca012a8595214ae76a96627ea522685210aedc083ff94e40a46834a5775524835b6fab630d4370127c3a737241fd8c449f8156ac0277293d61059c2b6c450e4971b9bf8457fe1f20bf3c9a30c6e60f9772c491d07cb5ee2648b538447726e23310d67fec1c1763a34466a1b1bffc94e53c62ec5f00f86dd44795ed5048dcb7697223b97e29a9910c9444f12c12666f2eea3174939bad6b164b9267edc432313561aae954e80f88bced4db4197bc7b86b84c07b62dcada45d68d2466f6f5dda6134d5d76e61cf18b5eb19b786cd8b2b39582b34385b0f13d811e6b24aaa389055851d7f2f27752fbec56763460de843eebb9bba75005511eb36b110f6ac27681d87b136dc1fefa9785e2be6a595c0cecf6baad23dbc2519e8c24af46ead296c72e180ceeccdd65ead5d535cbdd3f603d59867d8f1d5797d6dfa2b785e8f1922c368cc6dd5ef7b9ee9898785e8ee8323fadfc30f10983f61911f9c62596549675c3044cf86c20e44d7739ce9b887e2bda2caf36b29154649c5585d2567a592fff0af923a586fb3dc29d7d63ba063cd81acfc647ac4841a0008391f3121303d99d3fac30473234ce2c75f7a7ae159202affd60614a95b156aebcea5be19f319898a49b9d3c8d406fc42fa7e20caf96e86be2e70affd62e7bba3062ef33454c0a8f3942b43e1805dc09b1092ccc7bd4e35e68824e3ee5b943463b8ec604508fa64a6ffa79c4bd0b337978e4faabf33814cda3eebb5a5b2ca1ee3c7ca407351915c557363ddd75ca5d7fc1078989161d1805b0cc8b025e9be77e67e761f259111850f7c20b02d0a5c6521ab00f5f8c06ce8ce65036d3bc9bdf26ab2def28ce056d7c6cad00f462c9c5da47e8f5c68ef784a16d375aa66bbfc3acbaba637ea9de97e259b5e3baf748f1d3e3b41fdc1c8d2bd9371c50da417d9055904fa363ea9475fe6b7040a446a1fc85516da8dacb080bc70782ab832e3d3fa6bc37211b3f9ff53d19eec2594b4c5bc99d09178b7c4472d55a89a2a428da628382d30a77583082f8a4f82cd7694f3fab2d1be148b9a7c65ce698ea4f72b613568882f36d9cbbabf864395fbd2e3ff3eec804c6bfe1d224a8491bfaf736016c554c2af4c9ef9d75ab5dddbf02ab72041c8c27169836bc6d03e5ba704b6437effc60c39fe01b4e8622b95ba0e93747389ffcc7997b0ed4b0fed2fa98da832893748224076b4a4e26bdc6a1ddeba7dc7d3f795b3b92ef892c24eed7ec5d8edeb9f456d2afa507af1158bbb1c9d7e700cb4f34ada46cb72364dfdcb637d57675e0f6268a65571d7ffb6b9463322894f6d0a64a159fa86c54e09a92bfb68a39721f2750c31530731471789e619a097431af1a676279bf3c4b15311cb241974daeec5273182a747deb9ac3e0a98b248bca7eb7e73b45e43109fbc138419129fed6ec5da565d95ce99c02d79c61948728264c3999a859392406345cf3a54548e55b5bad9fd19650643db9cbf25c7314bb7edb3dcf4a89e029f82d3df864162df540bbd768b0a94783b33e22244a433c2c0e86d2d197d71ba262447793c265e804038f259d1d9d47db6f1a851b29d709b4f5ade6aa3e24784360f4d5881d16c011353042eb2eb49386691469051d91c4547f0a991a5ee5ea670891754bbd34df2a99f804f18aec79d69e9d6a8b3efd1a4f497b07610b3b8840bf9355d952991b435389d502638fe9761b0dda194468b0fe29ea7f50447386563e1a775a9e3f339b852efa9e51e6fd67383300cce02e117dfd45bfd52d4110b87104e47ea93caa261e3ae8aa73cb6f1e26cb7065646230d0b4776b2fc264c488d2df1f1bae2b6b225eee30dc12181f8def761d4c7ae059d2fcee118e07091c3ce4e875da3fc0362e8c1cae547258d05aa736d996aec9d59ec261a4043f967d820675d45829dcd88cc90f88f2fbaff398ecc3955d3d95f82337ef57f9a5829a012388452aa14158aab7c18f7c7bb037dd27d39e76a7775aa0378031b020c455be167fe89cceccf39d3c67dc8f9ab9ef7dbb30514320b0cac3aa10c926fe9dcbd6121902586033435e4b77b1ecbe59ff3087e6c74e642dc5d2ed04a83285b4f0db2756d49b2de1fdfce8de20138c56f842d408d20b0bfdd04bd32dd0d8878b4b0ef66803df763fc17dba7a701cd72d6283ee5a2438c1c54afc60ad5c28d7a78e2f26ba0ca148be822d7f27f709f59ef9a6658b4041fb46ad1ab0638076fa50edb7c9feb56b411f5dd49cc78cd8f4c9db2cd058e120357a81a3e72046be45919e1802e1f715e2314c9b16955bb9f5709e7247d9b965e32842eae8cc07c347bbcef4fd86098945f409d344e0901de6a9e406d991563e82f5d1c463f8022a45f182b49c0f510394c06eb8d4b211fdf61061f4b90c6352f869e85aed74067677a090e94afc5c4c912524d0cb353870fd936792babd83a5b501ee959378a5269826cb85aa94ef4a30760d12322b5e1636f6f3514dbade1077465da6e23b749d1cc6a13bedfd6798b9e8b19995c92c876cd1a43e55ef9a6b43910c9dc46c845a98ffccbd754ede6cff3e3bb34e74f52644ab9e59376d3a65e84a80dd43aebba1f5e0559665c24f50f3783f20e9ef4162d1f4f507ab132b5f2d04e79b89fc0033bb0121088b36cb4707abb35012adb3bb0fe5ad61f3baecb41d7c40883b1e601d09cdea39d9c15f040bc450d4690eb9d13f679fdc96b7b49605b558e21c171028aa53f38467d8b60f8f8852165638c163415d7a41433024f0cca57605f16e4a8ec41c76278f1e5b467aaddb1f522bc74c463185de4e16139e8f5fbf4eef06564473a805b654acde46855cdd812619a1b539e8036c1864e4a5c30c8e9ec379a94f486bf2ff9f7abfa173d0dfd47e28556c98e19bcab226316f095993cc123f6bd87bdb51b457955241c2b81175653692ebcf139b2cbcc113ab115a553d73a1201b30e1d7b2431a6513646ac89afd09657e4f89b1c70a6dcca1d22b3bc27cf2b3ab94d00c63170bbeda4d55c0bb13e187eb0a61017ff340e07c6e578e677f3a4a2d2043067d08604be58ebd7f319cb2defae8b0cc606aa9b9a232bcd4860c3d44bc132e584b49b4f5af3d15687dea3091283956f791d01761f1ade9df8a11f26e08107386f558aa797269b2bec50e89f2a32f24a9abadf098f8d4dcaf680c496e355b560af31d225a717c5c07d0ece42f7c1f4ff413cc2f7d17980d65adeb58a1fbb71b8692a20537bb4b0208f75f8f367c499680afe60d9aac7a90bb895c945df3ba79959997ac9d2158c6e595c37ad48513f3a9a2d0e0efbd29832f74c6f59c93940f6b1192a11703f7b239041f5f92b55dc382283f90627f85e21bf69057a0b5eb0e1e39546a048a2a7a477397bd1f54b8267563ae6825423b06bc0a3e746a83a03292fb1924bc27455dd693baeed4e3d51daa014dffe895419e9b683a66dd323cf4ad999d6f7c38df80d4ccb3bcb8480b838b75f424680cddbdb9de9ad722ee36a1c522ea064ba346eac81484b7a5beb5c3d8af1aa977c55abf442312ba1bb6f2a988b913165f3790a437341b43b2c296f1593ebb822353f9e148bbfeeac107a7614a39bad8f4bff85e30f019321a257ff3a31f01bb5b0b6bba5437aabc8124b65f9d5a74824ef687127cc53e618b28aae60d04e2822a2dd023c436fece204dd528a1a822a7e9817999489528e2e3a4050acd8de392a36176bf83944823dd48f4e0d397cd0b5802c627625fdd0a988d3220df91380f36313241b72100c2a6568bcd3adaa04b7fe7fe29b7be90668422cb722706391410e906ad34d702a4fdb4870640bb183c90cf2367f98a19475b0b2d0ba7c66a18becaf1b9bf6b107087d827f823b55f4530961d956befb1c566b517ba43ef7a67c51e8b13cd6f142479d24c06b3e143f894f92ba350043500b1765acfbf15e663789ff93cdd9341ba432cb645481cea3e874fb3bbe55d4da2ed0d4d963612c1fe29aa0bcfe3590606445a957ab05f739b8d7d8958b7689df0ea0d1e475cf91fa8e1e5e69bd629c542f03abd7bb495e9fbd55b2ceaa84402eca826c41775d515b4831f1195a63c7597cf59227321d00779cb8ae221e52da2ec4d53d86ce77050d01a359f5fa5ca0bddce9313b308911e9f141e63720a774fb882ac9c944141c54122a15652994ae6beec24c1996c71703b403c3add6b7872f20444b2cff9b546286a4c57fa41005f26a154ea2b8844413fc5131bfa227f027840134a473cd5e212dbc925b10bda75176f99e5e4413ce5a439649e2e68e9154cdcb9f40c2eba0feef00bebe62a43416a8b3e192a40655b75899eeef47fbe14d9cd15109bcb5b8bc06ddcdca2d2d95a732638149cb3bca9f46d72f8938dacd97f02a0c34df0860d6ecf267ef63986327462b24f1ffba757a2ffb4288f4492eb861ced1ca799bfb9d03aef1b11956a112eb2aae23455504719d665292a79bd3d491e0ed906b3e2ea5a1e077cd4a5f358145b727137e4f12b7a4ea10031b0c62363193d02e549480854bc75cdbc8f82ea8c35f4a1eff74fb9ceb6889015dd1ed6599c7ff4e15e40f22036fd266d4bae633df19cd5e4a78b70a6d96519c26711342aad6b7a6cfb6d5471d41854eccb1c5d1ca185adb8200e2ccf04e9d941d78fee87798db68cdcb432ee51cf88bc2a31626f67f1c65be2520c446bb25bffe8cf59f716cf327a2c2fbc3fe16cad01cd8d97bfa5b7f56b587483fbe0bc2d288bc93486797bd2aeaf288b4caeb7fc5d82bde460d9e183d3ca80a1605f80662929c49a2e83c78873838305237b4ae412b883c8e0338696d657d6f408b5a9682523e781b07c1ccf51ee30cbf06c43d45994275a06207ffcfa3019cae8e0383446ffdabfb23faa89b58e9e08a79124e2e23d2c60af5881bf402c9c356d3d2f1e308032789b9a644a803e673674720fd421ec26bfbdab0227da62a8287f86f1132724bac23b1aa837a7395f2748b909842cef790aa6125cee80189cd5f8c2ebf80906103a729a14c8b905b0b6ac496ca872cca9d89a104b3a88395d72c5cb3442284b83f37c4afe9f89620bb3558009b03ba19f68d79bb64916ef70ea3e158a887cacc453d37625331b749dfb61cd1c638e0b2101c8989f50beadb351097298829b48956e535d0edbf6db7ed809c57e38bc0a783d9124a99aa9b3594521e0bbd4aa076cda8fbabc5c7d917bf036e9b0cf98355f4c961a2c3fd680bb5661e7efff1e5d81cd5d5a471532a767ede86fc05afe812ce8972209e52ecf690bea10041f7cfaf5f4762186cf8ed28a00340fdaca9b2a94b8fe5ddf9c31e2a8bdefa079f6ccc862d6fb36632cc866a6f26f8dd9ed25f16b3ebcb4d6a37fa98766d048805ab8e31eaf6e3f671b279cd003f48151538a46455afcd280c2aa0dd037b91d624ae0ef006678c9669501d15c96a651fe5a8040589e470ebaac4e976db2637837a41265e90b236d0bacf3f20202aacde2c588b6d830c0afe874e4a73c4b4395eb2bc313f7998fda439092e9abf23064b4a42a0278830caef0baae1e4345fae47b4bd644a6a1a1add73d04ff796758a4919d87e3adb962a27e1df55165d68552b3eacff590d41541e9bf6fb05f46809d6adfcc6a7dc0f78af668badacc55279114e973154259a0506b4cacacf259bc60ec37f1e51737c919f06855d09a9de180855c21569788aea8d8a545966b0df48db714b551d12e14b35884a8a49d83964767a857d85ff6ae34e7aa4bb750866c75e9e7555d8307a881f6d74defe3d79ca00b7604d74a3c4bc34af72ae3f5b0e80d16681c64ce21fc6716bd869f2bfd9ba03f22f6cdf524ba7a351d7bf18d2686a94f268373f71f776a4fc17de7b78d048571fff4fdd0ecd0174234fc734fca2bd04ad878eb7d28b499f41198394d1b49748f0d81d64e422dd6bc34537f72695fb3acf671089cc36a4d04c498dd61b432b602d962827ce4300fc68ed6f0c237e845eb3838256fd152be3d1470c98a81274135befd95a75c14b429503a39f3e2bf9eb2573bc0683096b053d9d1a0c99f616206feed8b9870f55300ad522b8d5e15cb9da2fb7378cdf29447424ff4af72441809261e1324aeb30e581ac2ccb6e27b6c959ec07c83cc9f618fc3f9fa87274e258e7dc929830f6f9af2a5d41c8c21cc458031f41ae184379a2381afdc26081104f45b1bf1ac0334730b2df7983b54f7aa5b8cbd6c5eda2ea7824beac960194f58f077c99fb1e26ff76e321744f8e734c1e58be60febe5344f8026d558116e6b135735b6259663eeb7e0cd1b33a8ce5d436e62c45a7614251a4f7158ef268bd3a8dfc8d99e161c394ef68f467be625a7229a983340e18f4d8a479e84fd2a66f3259459b529155ff9c01e6ea076b7822a2b219c7919767a4f2977ace4fc064ea034d12d28fd0ad2c1d49912e674d650b7b0a9e97049d23f82f7abb9be09ba84542a2f6587b857748c895ac85bc564afb5a8972c1399791cae8c31b691ce205dfd1129e63c70597d7e500ea1b375bee06662a657be4e3cf36b8212a1bbf47f21c6fb287a680acd6b7a25e7ec35ad8725efe9497d087ce5472878d2a0b8358a6d5762e908896bb6a396144dbdbe0ececa4d57755ab11fdb4ac4878afe5b52aa28d5b3fef5917637bfd5803b2b29698dcc8ea30f28622924264b18cfad7f8804611fc2bf18950902d38d4c13b21cb5468f7a88daed14ea12066d36646d56299c4be556b405e50f081a55788eec51a235550c1487cd38fbeea7cd1ec5409696abccae2a2675c7d95126eb48806385be4c6130fe8aae8f041b60fbf7d4714d0f528b3c1846d33546b6afa9e7ae254a82106f4eb54e0e308e8fd3bb883d66a72c3b5a7dbad2ce4af3d8eb9f9ee762f54a8a9ed748e2ad37f44e4dd240cc765b0f7bc9733316a342fd534d600d97b66df10c68347fdbc1af69e8f6afee9cac6095de032080ee6ca794079f78f539439d4e7ab61b9b265f256b87fdda9cef0eb25437a5b91efb5b63fdd44e554cb835adf780208e7e35726f7d5f0732c684facc7f621f5774f2ea7cee2688828d6feea148271d451ef25d3964c19bce23da4574778da6e9549e0bd069a5e12c08107cd8258da37230914e07c9f4db2d5dea20182e03ea5112db7a2ed2c347c83c66b9311ee3e81fd23822dea7e387c29c7cc60337c8a1172ec636d99d4ae3c0137180f1e139f59f1184792a7285f928e86af1e759bbc8d6f534b9c8e8602595ff77f9f0fc3a55a9c6e2792633281cc58f61b76223ded7e527343c4f2433a8207b6fd40074efc7c00229f8cb210b2cf0a46b2cb97a06e35abb9ff77c5c719038aba41c23d81135922473323bdad85eb0bfe222332d75d3e2a9607455f86d822e3b6fdeb34b6f3b4ceda2b805ef63fb7733305724fe0768fbaf543fa47d9bd9ff064b60df729367fbd54115b3f1de8e1e681cee1424b37f5ba50f63b4a17d190195c1084be88eec3aa3b5cd602db0b5d76cddceb0f3aa3c57ce174de96dea775003428bc7154c2843f6b0237df0a9c5c327eb1237b3768429fbeb17f433dfaf09dfc51d81280ff17aab018971d65de94c5498ca77744bd5bce87b29f0fbde4db99de906be963bce41a05cfd47346b405e7be4e355d6744778bd37116b7146a5a817db072df9f8b06983e5a23e632fc3e9874111ff1d6a8bd05dd7ad15f5fd59f375e89020f213114036e26768ddbed38c99c20689fb275de1b7e9c87da2d176b7bddab94269d57fb0336ad603367f317a563ef65ed03f6593ca28698eae973261737ec8c1c15b9d22677c6d325011060eb2c298fc68dce8d6c4e78f3ac53664cf07792024db1a62c99a6a7b183446384e2e46183e9dc7505efcc3b4841b789fc7f7eb2121ea691935bde61342db291435f66f60a7cc7c355ace3e4b1575726ea3224f9069000b85be4e579f411fbff7df28238f495741754fad48e1ff2c28014ccfe18d0520a73cd26e9ed5c48842f3169f865dc4db407492fd6099cf40522f007619d79b759f70960b6e6e34ac896b555fec192ee98fd8c11609f4991f9ea1e511ab6eb3249413cf6345d4e38d97758dfbb9f67de796773a1c5cfd0e46e145c4a3c5f89cc6b8a6ac601d8574717efa7b33b291b39d9d6379f1f836dcfd3702bc61cf09e45e180df8472795d67496bae81d5dad4375b840d7b9e6a71190296f2994d8986d335c56f3f0613ee02fb8c59a6d02a0b360a35fb20f0f3866a1a54a67c38c1f7d23dae7fec45eb8cb775d612af409d6b9d2bdb4124b2a58523dcf98d1c6ed7468bd91910f3899fb149306391d881debe619aa5e673f110965185087c33200b9819ee132cba47faa69cb621b128b31660726a51b338da16beaf578773283e8d69acff971b5c5eae58808d4d6f1fc44ad76ea83008fcaa15e29bf5bf3de49bce6cd16eab2d13968cd7390caf3e157a39968fa92a8ed6297947444a029ee2e4355b20aa33b58298d5c5356e11cce17317354ab0cb4b7fe64389d8d6da1a547f77a74eb1b236d08a321e4a4506ba81091def5f668aabd594f8cd92ea2244ac0f2afa39c9bf8e17d316773b8fba560a46218ad2cde8a9c84bf58d6f9347d1cd953e4d3af4c2d5db57eefc11103e0f17a9d9b690d641a728c5a0c6d56b4fec8e1f7a7926d36699319bd993c33e891d19909b268034b1116e48dc634ea11a18926d1664493297896f8511c8a0d1882ed1bb37abcac769db7a55c816eb4de7744ee43f6a4eef3652b9c3cfb30cd699648dd93523ec97a0f1b88f166752e44f2f14bc87e4c2260479161c2594cef2a1264d78a4c38d2f47a12362a7a3158cc1ce4151ed388e32eec0aedad44d872f6186bdb431166bdacc4d4eec38d1b0a318740512180a582154960098e7c3133b41fca5ccbcecf03a1c427304b1191669037463b41c78756fd72a463e9651103fbab13b04767f7640cfa4441ea92f82fa3483e0ce57ec2dbb32eb020ece24fb52269389ea75c86766b5c606784f0b40998dcca53c092940862e8e8f7c627f96bc3c50ae8a49a49360c7d2581882cb34200ee802537ecc4f4558976280ba72505e94705359f65171de842641885c03e29a26b23f94c</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/hello-world.html</url>
    <content><![CDATA[<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">

<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment<img src="/QQ截图20190815084633.png" alt="QQ截图20190815084633"></a></p>
]]></content>
  </entry>
  <entry>
    <title>jsp学习笔记</title>
    <url>/jsp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content><![CDATA[<p><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"></p>
<h4 id="Jsp学习笔记"><a href="#Jsp学习笔记" class="headerlink" title="Jsp学习笔记"></a>Jsp学习笔记</h4><h5 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h5><p>定义：一个public修饰的java类，提供无参构造方法，并且类的属性都为private，属性都提供get/set方法。</p>
<p>javaBean可以分为两种：</p>
<p>（1）封装数据的类。相当于数据库的表</p>
<p>（2）封装逻辑的类。用于操作封装数据的类</p>
<p>用于简化代码。提高代码复用率。</p>
<h5 id="MVC设计模式"><a href="#MVC设计模式" class="headerlink" title="MVC设计模式"></a>MVC设计模式</h5><p>M:model        模型</p>
<p>V:view            视图</p>
<p>C:controller 控制器</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>M(model)</th>
<th>V(view)</th>
<th>C(controller)</th>
</tr>
</thead>
<tbody>
<tr>
<td>模型</td>
<td>视图</td>
<td>控制器</td>
</tr>
<tr>
<td>模型表示企业数据和业务规则</td>
<td>视图是用户看到并与之交互的界面</td>
<td>控制器接受用户的输入并调用模型和视图去完成用户的需求</td>
</tr>
</tbody>
</table>
</div>
<p>控制器调控模型和视图之间。不同的视图请求会由控制器选择不同的模型完成。</p>
<p>jsp+javabean+serlvet就是典型的MVC模型。</p>
<h5 id="servlvet类"><a href="#servlvet类" class="headerlink" title="servlvet类"></a>servlvet类</h5><p>继承javax.servlet.http.HttpServlet的类，注意重写doGet和doPost方法</p>
<h6 id="serlet的执行流程"><a href="#serlet的执行流程" class="headerlink" title="serlet的执行流程"></a>serlet的执行流程</h6><pre class="mermaid">graph LR
    加载 --> 初始化
    初始化--> 服务
    服务 --> 销毁
    销毁 --> 卸载
subgraph   
    服务-.-服务是最关键的,包含了doGet和doPost方法.
end</pre>

<p>通过a href=”servlet的类名”访问.</p>
<p>在serlert2.5中通过serlvet-mapping通过serlvet映射到servlet的地址</p>
<p>3.0以上的版本通过@WebServlet(“/地址”)来指定servlet类</p>
<p>通过localhost:8080/项目名/地址可以访问到该servlet</p>
<h6 id="servlet的继承关系"><a href="#servlet的继承关系" class="headerlink" title="servlet的继承关系"></a>servlet的继承关系</h6><pre class="mermaid">graph TB
    interface/servlet-->GenericServlet
    GenericServlet-->HttpServlet
    interface/ServletConfig-->GenericServlet
    HttpServlet-->servlet类</pre>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span></span></span><br></pre></td></tr></table></figure>
<p>service方法在service中，在GenericServlet抽象继承，HttpServlet中参数类型强转为</p>
]]></content>
  </entry>
  <entry>
    <title>hexo+github博客域名配置</title>
    <url>/hexo-github%E5%8D%9A%E5%AE%A2%E5%9F%9F%E5%90%8D%E9%85%8D%E7%BD%AE.html</url>
    <content><![CDATA[<p><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"></p>
<h3 id="hexo-github博客域名配置"><a href="#hexo-github博客域名配置" class="headerlink" title="hexo+github博客域名配置"></a>hexo+github博客域名配置</h3><p>搞了半天，几乎全部坑都给我踩了一遍。记录一下步骤。</p>
<p>首先需要一个域名。</p>
<h4 id="买域名"><a href="#买域名" class="headerlink" title="买域名"></a>买域名</h4><p>买就完事了，上阿里云买个域名</p>
<h4 id="解析域名"><a href="#解析域名" class="headerlink" title="解析域名"></a>解析域名</h4><p><strong>也就是在阿里云网站上填写主机记录和记录类型与记录值</strong></p>
<p><img src="https://i.loli.net/2020/12/12/a6gcoHEbkG4Fj5C.png" alt="1.png"></p>
<h5 id="具体步骤：记录值的填写"><a href="#具体步骤：记录值的填写" class="headerlink" title="具体步骤：记录值的填写"></a>具体步骤：记录值的填写</h5><p>这里用到了A记录和CNAME记录</p>
<p>a记录的主机记录是       @</p>
<p>CNAME的主机记录是   www</p>
<p><strong>A记录值:</strong></p>
<p>在cmd中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ping githubname.github.io</span><br></pre></td></tr></table></figure>
<p>这里的githubname是你的github名字。</p>
<p><img src="https://i.loli.net/2020/12/12/IcM1uxQSUaovC5p.png" alt="2.png"></p>
<p>把这个ip地址记录到a记录中</p>
<p><strong>CNAME记录值：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">githubname.github.io</span><br></pre></td></tr></table></figure>
<p>githubname是你的github名字。</p>
<h4 id="github上的设置"><a href="#github上的设置" class="headerlink" title="github上的设置"></a>github上的设置</h4><p>打开github上的hexo项目的setting，下拉可以看到GitHub Pages。接着</p>
<p><img src="https://i.loli.net/2020/12/12/ANT947R2yS5iGU1.png" alt="3.png"></p>
<h4 id="hexo的配置"><a href="#hexo的配置" class="headerlink" title="hexo的配置"></a>hexo的配置</h4><p>本地文件的hexo文件夹找到source文件夹</p>
<p>添加一个<strong>文件</strong>（没有后缀）名字叫CNAME。</p>
<p>里面填写你的域名</p>
<p><img src="https://i.loli.net/2020/12/12/sC2VK1hagybBtvH.png" alt="4.png"></p>
<p>接着cmd里cd到hexo文件夹，重新生成文件并上传。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean&amp;&amp;hexo g&amp;&amp;hexo d</span><br></pre></td></tr></table></figure>
<h4 id="任务完成"><a href="#任务完成" class="headerlink" title="任务完成"></a>任务完成</h4><p>浏览器地址栏输入域名即可访问博客。</p>
<p>github pages可以看到这样的信息。</p>
<p><img src="https://i.loli.net/2020/12/12/vfGZctIKhraxQCd.png" alt="5.png"></p>
<h3 id="科普知识"><a href="#科普知识" class="headerlink" title="科普知识"></a>科普知识</h3><h5 id="主机记录"><a href="#主机记录" class="headerlink" title="主机记录"></a>主机记录</h5><p>主机记录就是域名前缀，常见用法有:www:解析后的域名为www.aliyun.com。</p>
<p>@:直接解析主域名aliyun.com。<br><em>*:泛解析，匹配其他所有域名</em>.aliyun.com。<br>mail:将域名解析为mail.aliyun.com，通常用于解析邮箱服务器。</p>
<p>二级域名:如: abc.aliyun.com，填写abc。<br>手机网站:如: m.aliyun.com，填写m。<br>显性URL:不支持泛解析（泛解析:将所有子域名解析到同—地址)</p>
<p>解析线路：选择 默认 （默认为必选项，如未设置会导致部分用户无法访问 )。</p>
<p>记录值：记录值为 IP 地址，填写 IPv4 地址。</p>
<p>TTL：为缓存时间，数值越小，修改记录各地生效时间越快。</p>
<h5 id="记录类型"><a href="#记录类型" class="headerlink" title="记录类型"></a>记录类型</h5><p>记录类型包含：</p>
<p>A记录，CNAME记录，MX记录，AAAA记录，TXT记录，URL显性/隐性转发，NS记录，SRV记录，CAA记录，PTR记录</p>
<h6 id="A记录"><a href="#A记录" class="headerlink" title="A记录"></a>A记录</h6><p>使用场景<br>添加 A 记录可实现将域名指向 IP 地址。</p>
<h6 id="CNAME-记录"><a href="#CNAME-记录" class="headerlink" title="CNAME 记录"></a>CNAME 记录</h6><p>使用场景<br>当需要将域名指向另一个域名，再由另一个域名提供 IP 地址，就需要添加 CNAME 记录，最常用到 CNAME 的场景包括做 CDN、企业邮箱、全局流量管理等。</p>
<h6 id="MX记录"><a href="#MX记录" class="headerlink" title="MX记录"></a>MX记录</h6><p>使用场景<br>设置邮箱时，让邮箱能收到邮件，就需要添加 MX 记录。MX全称为mail exchanger，用于电子邮件系统发邮件时根据收信人的地址后缀来定位邮件服务器。例如，当有人发邮件给“vincen@example.com”时，系统将对“example.com”进行DNS中的MX记录解析。如果MX记录存在，系统就根据MX记录的优先级，将邮件转发到与该MX相应的邮件服务器上。</p>
<p>主机记录：一般是指子域名的前缀，（要做xxx@dns-example.com的邮箱，所以主机记录输入“ @ ”；要做xxx@mail.dns-example.com，如果主机记录填 mail）。</p>
<p>记录值：输入内容通过联系邮箱注册商提供。例如阿里云邮提供的需要配置的解析记录值是 mx1.qiye.aliyun.com；</p>
<p>MX优先级：输入内容通过联系邮箱注册商提供，MX 优先级的数值越低，优先级别就越高（如下图，邮件会先尝试发送到 MX 优先级为 5 的mx1.qiye.aliyun.com，如果尝试失败，才会发送到 MX 优先级为10 的mx2.qiye.aliyun.com）。</p>
<p>MX1<br>MX2</p>
<p>注意：以上仅是对MX记录的设置为例，完整的创建邮箱，还需要同时设置CNAME、TXT记录，具体需要配置的解析记录请联系您的邮箱厂商获取，如果您的邮箱提供是阿里云邮箱，您可以参阅 添加邮箱解析 的操作文档</p>
<h6 id="AAAA-记录"><a href="#AAAA-记录" class="headerlink" title="AAAA 记录"></a>AAAA 记录</h6><p>使用场景<br>当预期是实现访问者通过 IPv6 地址访问网站，可以使用 AAAA 记录实现。</p>
<h6 id="TXT-记录"><a href="#TXT-记录" class="headerlink" title="TXT 记录"></a>TXT 记录</h6><p>使用场景<br>如果希望对域名进行标识和说明，可以使用 TXT 记录， TXT 记录多用来做 SPF 记录（反垃圾邮件）。</p>
<p>主机记录：一般是指子域名的前缀（如需为子域名为 www.dns-example.com 添加 TXT 记录， 主机记录输入 www；如需为dns-example.com添加TXT记录，主机记录输入 @）</p>
<p>TXT记录</p>
<h6 id="URL显性-隐性转发"><a href="#URL显性-隐性转发" class="headerlink" title="URL显性/隐性转发"></a>URL显性/隐性转发</h6><p>使用场景<br>将一个域名指向另外一个已经存在的站点时，需要添加 URL 记录。</p>
<p>使用前提<br>添加 URL 转发记录时，转发前的域名需完成备案。</p>
<p>设置方法<br>示例：以 <a href="http://dns-example.com">http://dns-example.com</a> 跳转到 <a href="http://www.aliyun.com:80/">http://www.aliyun.com:80/</a> 为例。</p>
<p>1 . URL隐性转发</p>
<p>用的是iframe框架技术，非重定向技术；</p>
<p>隐性URL</p>
<p>实现效果</p>
<p>为浏览器地址栏输入<a href="http://dns-example.com">http://dns-example.com</a> 回车，打开网站内容是目标地址<a href="http://www.aliyun.com:80/">http://www.aliyun.com:80/</a> 的网站内容，但地址栏显示当前地<a href="http://dns-example.com">http://dns-example.com</a></p>
<p>2 . URL显性转发</p>
<p>支持URL转发301永久重定向、302暂时性定向</p>
<p>URL显性转发</p>
<p>实现效果</p>
<p>为浏览器地址栏输入<a href="http://dnswork.top">http://dnswork.top</a> 回车，打开网站内容是目标地址<a href="http://www.aliyun.com:80/">http://www.aliyun.com:80/</a> 的网站内容，且地址栏显示目标地址<a href="http://www.aliyun.com:80/">http://www.aliyun.com:80/</a></p>
<p>使用规则<br>添加 URL 转发记录时，转发前的域名都需完成备案且备案接入商为阿里云。</p>
<p>URL转发时记录值不能为IP地址<br>URL转发不支持泛解析设置。<br>URL转发的目标域名不支持中文域名。<br>URL转发前域名支持HTTP，不支持HTTPS，转发后的目标地址支持HTTP、HTTPS。<br>URL转发属于特殊商品，云解析不提供攻击防护服务，如遇攻击黑洞时无法使用URL转发，请将需要转发的主机记录配置为A或CNAME记录。</p>
<h6 id="NS-记录"><a href="#NS-记录" class="headerlink" title="NS 记录"></a>NS 记录</h6><p>使用场景<br>如果需要把子域名交给其他 DNS 服务商解析，就需要添加 NS 记录。</p>
<p>设置方法<br>示例：域名 dns-example.com 使用阿里云解析，将子域名www.dns-example.com 的解析管理权从阿里云解析授权给腾讯云解析做管理。</p>
<p>主机记录：一般是指子域名的前缀（如需将子域名为www.dns-example.com 的解析授权给腾讯云解析的DNS服务器进行解析管理，只需要在主机记录处填写 www 即可）。</p>
<p>记录值：记录值为要授权的 DNS 服务器域名，例如腾讯云解析的DNS服务器域名f1g1ns1.dnspod.net。</p>
<h6 id="SRV记录"><a href="#SRV记录" class="headerlink" title="SRV记录"></a>SRV记录</h6><p>使用场景<br>SRV 记录用来标识某台服务器使用了某个服务，常见于微软系统的目录管理。</p>
<p>主机记录： 格式为 服务的名字.协议的类型。</p>
<p>例如：_sip._tcp</p>
<p>解析线路：默认 为必选项，未设置默认线路会导致部分用户无法解析<br>记录值：格式为 优先级 权重 端口 目标地址 ，每项中间需以空格分隔。</p>
<p>例如：0 5 5060 sipserver.example.com</p>
<h6 id="CAA记录"><a href="#CAA记录" class="headerlink" title="CAA记录"></a>CAA记录</h6><p>使用场景<br>CAA(Certificate Authority Authorization)，即证书颁发机构授权。是一项新的可以添加到DNS记录中的额外字段,通过DNS机制创建CAA资源记录，可以限定域名颁发的证书和CA（证书颁发机构）之间的联系。未经授权的第三方尝试通过其他CA注册获取用于该域名的SSL/TLS证书将被拒绝。</p>
<p>域名设置 CAA 记录，使网站所有者，可授权指定CA机构为自己的域名颁发证书，以防止HTTPS证书错误签发，从而提高网站安全性。</p>
<p>CAA记录的记录格式<br>CAA记录的格式为：[flag] [tag] [value]，是由一个标志字节的[flag]和一个被称为属性的[tag]-[value]（标签-值）对组成。您可以将多个CAA字段添加到域名的DNS记录中。</p>
<p>放大查看<br>字段    说明<br>flag    无符号整数（目前仅支持0和128），用于标志认证机构。通常情况下填0，表示如果颁发证书机构无法识别本条信息，就忽略。<br>tag    支持 issue、issuewild 和 iodef。<br>issue：CA授权单个证书颁发机构发布的 任何类型 域名证书。<br>issuewild：CA授权单个证书颁发机构发布主机名的 通配符 证书。<br>iodef：CA可以将违规的颁发记录URL发送给某个电子邮箱。<br>value    CA的域名或用于违规通知的电子邮箱。</p>
<p>设置方法<br>添加如下两条解析记录。</p>
<p>放大查看<br>主机记录    记录值<br>@    0 issue “symantec.com”<br>@    0 iodef “mailto:admin@dns-example.com”<br>CAA 1<br>CAA2</p>
<h6 id="PTR记录"><a href="#PTR记录" class="headerlink" title="PTR记录"></a>PTR记录</h6><p>反向解析则是指将IP地址映射到域名上，需要您与IDC机房或主机服务商联系实现。</p>
]]></content>
  </entry>
  <entry>
    <title>rj感想</title>
    <url>/rj%E6%84%9F%E6%83%B3.html</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">Hey, password is required here.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="0600041c5df95e571ee231548ad3acb13e1e495c9406e4774de6ecd00a45578b">4630436162ade97ba2718b7d0c4b3b63ab954ca66037664d11f05e9c40a3fbe7a0c0924c663e56eea1af4af31d5db1947aeaea6af819cf706a2f3295b4c2a1bdce8f9e6247244ccf9557756d6be2b0efb7d7ff467b2b8f79d4d6d98d3ce741a2cf53bd6bec3df0c5537b4d77b3f027db22df2aa224408565ca0edeedcb5c810a465404403b2d918304e96c55d0db21460883f2395780b0ebef249c0f0653ea6e669f0b28365575883dc1b89a99aeee0374668a2e53d37348e007c8a01b9d40a3c74afef39b76f27bd542abf9cb5a972bbc114d43cc78d47ba346086061cca38579c900d9f3b7f5c307f0d8d5a877fcab565bc39937ae43ac04cb94c82318b17dc16b3711b23e6e6af5eea8c0f226090a60ed293bc83efada35a8237f885eb09db8c2c07831d7503b859008433b7363b2479d084b4527a5c74b6cab87f39885d265eadc0ed1b4376c27e9203f634e8259da6b4dfd6662f88a3d719fc7c84e18a5c877af5e1472c81c3eb4d8d6d54f8767c048480300fa5701f8d135e0471d41f54598186fcf96cf1a7a591274a0d49a620ce0c986492779e7e94f2c15bfd03eeb088983d3cfe6b13790e7320740a1effb63e2e41d2beeabb18f4e8cd3f29dce25fd1f4a3e4f62abc45181dc73babc62279ac7dad0642ce20464938379a35436df4fe80860bb18cb33f2b1155190b0060653a06b339272dec36d86b5915302b633e2a2501ace5a5982668361e744247b7a78dc2e1e210efc0eb1b1b6ae53776458f451563f38be4f50a3a638b0f0af63e8e52662f28082637ebb58f3ac213098ba116040deba28826f07928294638cbe554289c22918faaeb7c0e906105dc3be1e5ccf17d31f93f00ea024d1c7ee9d15e7d2ac127270c5e0be5aa989fcb3533e7ae544711fa2144b7da03c8206e51a7091716ff0e3942b3fa4eeb762aec42543ee0f8f5cb1909e06276575f9e847647d4acbb7a3d5eb72e6012997f875ecd95bbc15133b997eb395ae9692d4cb6c40662ffe1d8f6332a3cd3b17dfc84bb9bbd0b4525956e0ce9b8db8c3d835c87c7e132a184a4e3e13cd20663a1bcae2e8fcbf444d009d5dac03233e22e4c2403a3782ec8bd27c0eb2663593b789c4ac78c3b9f1ee6306190016a29f5121d1c12910795181f966f00ea22791d9fe5dcf3cff8c9a230d969b0e567eefee5473c89bf1df54110073758c3fbab26f9fde4a8c3b37dde614f067b7e12e13187da1ffcc66a627f00e0366f489251f16299d3494fba8260f8aa8159a0b9e1111c596bfdeb9aca58e666225e147b1a52a1288763c1e1989a2aa883858a94e06299e7de7d0d670e06a5c78dbd19633c87785b4858b26770424dfa91bd420d7d39a0a085b1b7e29e52ae29f7a859ad8414183ba8ce1be20cd9e19b740bce79746f156c400227bb747c1610aeedec7de47b8d14c4c27369cd87fa4d7d74459e6e24769b0e4232442bda58465aadc33337a263172d75de0ef2d00a2eafc7b81f44cf74b335a803d64ecb92dd1d965f9c26cdeb5743db4bf73804d293f244a07a2f1818308e1cbaa69299da5f2ff6838fae341a7d6fef595e3cfb4c066d1a21699b96090ef064fe51e81d46b34d2926ac272ac10c4807b17089cc9d5a2f4edc4560fae768f5d0b6b896e74dd9256bdbffc27dcf4134570a6eb8d6e382b400cd4de1cea4949b7e3f48d702b495a3812d1e2bcb1294bdfe6094046d3850dfceefa609773f9c3f764a2bf38d9c17df8384a58f52dc5b6a0124e008b7331df258b641dba452f3b448801447888967e99015df7b2cdafc34f96fffc368403d37fce1793ca9dd3f12f2a14b9bea84497b6706f9f3d971662bdd7229967fdd98de77b2ecbf256bcc9256bd4e3cf94798762c8da3372b6b495f194ac5213c0e10047a39a1ff8b3d4548e65bb4ee3a9302296260214160bc534094df5ee355ace6a266bd30db0d1c8e2b82e41c4197d5c5af0da460c858eb20c40beb8b6ca45d1fbd2cbee88616928f32c788cc70bd113f261f908f32b2d3242be28af5dc91afc4a59a5c4fd41299e83eed92e5b6ea4ebee83ed19f7dbdf3eb957c048f7cac968fe377e7ec7b37bf62670d067991ddfb19783ed7091a28c0f2de0d7c074a73311331bf730242949cb9fc786fc07efcc4660c9f61b8a4d19f99be035af0ca118da5aa0f5820011f742a1ce91e76d2e546040b6ae364d52ba8a79cba1a3c5bcaeec8a8923e2836a9d179d193bc79e61be30520bc5d6ae59d0179fb33fc48f00fa20f06c4ce86b9c3e91158faea9fb327deba726351ace65ff077b9003e8e3fd31977da04d3caf821c01e49cd48caf42e69829446c7b484babef34b7e1b7246bc4d28ff9a70efc7ccb6779cf6833125c684b9841ab341dcb2773e794a9d28964edd072ec54f3c1bf17c7aec9b171084ba3dcd7f51c7536a861cc209838c9db222dfc8a0c4bf4bdd01a8db970bc18e927d8778a5587fa5004d681bfb47edaae933fa217958e53a0b0d608376d5ab5b45e7d5b81d2ec3a9b9e293f9100a16c966adeaa7297f46d441587cb216a33fa0ad267a97a01d1bb992963fb906d2c02c58808da8c337e14513578314d68860d1eecaca3d927c631da92247aafd0e43076e0d2d5b691c0ca0d1c0ce0d73fa1b3f148a0beaf51330ddb9cca42c95976cdcaee024ac57016a3a33606f9a91a5cfd85909b8aec9b545b11f6c1e24566d6f54484df89ddc386a9a49f61c91ae51596ae1cfcd03dafb47db98f4a481993e120c766d861cabb1ed833506a33e266fa89876d18ab76b6c287f91cc83a98bf5cdc05dbe5a35a5f13e095d2ba838983a60752fae2ec014e44971af10f91ebe3c1e48de72b5e526b9bdc8597e8afdd1ed705add9c1235f83f29c41dacc18f3a974561a801d534097bb22cd01dbea942556dad5e93125efeab952e3e335fa15a78e38756c8a727861126291650a0ad5ee845f62f3832ab832007f696c6c1629675f3255d8c93172793d66780507565919f90be3fa9c82a3ec10ead771f1051faf676bc8d37c84014308f470e4e92bc6cda52cc14f336e04eb66433d2463d5571f79b9966e9f97184d469227b75af2a0f4670ed4ee722eb907f33fa389bb80c1386a0da031d77bbe588e1db425374257192fab1302746353ed676c1e29eac19ce51360cc1ab99c2fb7b04a8c85add5b9d2cf4a2156d41b060c4e4da8ed441adb78309a3224f76d16dc4238083d92bfb09e129e78207bb02324a4024c00c36c08d147713ecac8e9c8e143160ece9a1e549282750b6002a6b99849ca9da82d0846c4b7fdc2657ac8a9a64836504c0fa1403114b245372dfe7429a20201ba2282f06ce14efa7c0c8d238cb4ae6f1587de5af7c3365daaca5d2cb2709bc72ee2858af5461b81d67560265e5d4babe07bdd70f345d94f5046d403df4faf7583bfddcb89181e367069ff59f1730fbf8a28b1e1f93533240ee9af961112748aab6962dde69cf4b59c0799065792f0a61bcecdcf9fa8bc9de1de1d5ffbb583d68fe07f1c90a751996e9104f79a03bff0c820d17e5e9ff4dc6644516e229192df024507e93ae20939163d8da847289cd645ee0cfaccbfdaf8b6bd3dddfea34d8038392d3a586157ac8e8a1aefab0c15a3d6606eab3132c49381f6f05ecfdbe22ec3397d128d0e0ebb08e54de431daa4ce8fd1f2f451aa95ae8dc65827067f223c5170a10127a2239fcf7e702afdf93c43e2e9d1324574220484a92e30c3a4d2415e573ee3fb4520cf728bcd117a595430a9a4b5ed2caa1ab1502b121b83bee9e88c78b8eb2dbf8c9d1d0dd05b22bb93a27f2fe5a521f7de713fdaefb91d374d901e80e92931b5ddbfe2488ae09c98d7a38b6b5dc4bb04108f304affa78a77cf8a14a8b7beea01a8f77eb07f4e9510d0433341c67f23645cce7f3b9a27a0504700dbe4d57dabe3014a8f38cd90edf970d46c162138e498b47c57333bbc06cc918a09a2e17f821f913b7948597216c6d394e8bade520123033a1dc9dbc88b48657726a21142a146654951ec85e64ec2eb01d40ad0918e15c55776bebcfcae329b5b8ff5c12ed5fcdf84216147ecb3ce4ddccaf63804f3544ed0d3a3c19395eb095edb3553d2c564ffcb87fdbb75b8c547fcb2aff2b8030786c9a03220f96a841343d94d5853e86c153586a95be0f36e7750a58380f8ecb8fa4e7f8cdf04ed26e63178e48c19ed7791ff7f76b84f8cbafa3b28304d358db3488740fa87ed80ef1ba2fc37badfdccf32e794e16d5fa2887098cc32df91727e173d1532a5c07e8405a273555605200b4bcd8d861a98799781792aed1df6fcb30cbdb20a8a3e0df6f0ee5ff69fd4a95868890f2f66f58a5462b3758eb52a0375b74331cef3fd538813132f81fa78839c4c934b62e5d30f0c24a4ad6860d8926df510a4a0a781a67d86bb24df0f18ce17e6b407d1b8193c30b381a7d7ca76e4f03aecd42f6ba390ba49674eec1e55ee3ea7c4690cb9afbc44a3f5409b84af4c66c9b60e5a8cfbb139decd6737bb657a7cbe4ba81b838aeee7d63fd9777ca6fdeea9447cc4f9d31ffdd1566e41439b716b01cead2efb53852686051dd2c2d4ba4d7069b558eb10ca7b733e5383803054a2b6aedca7447e349e102a646d8fae83932147104704b041116c30e52ff14e0ea0014e5e058b585c1ca9e90a9b856d52c2edf506b6c36aca650ea86f597cbb5edfff1a751941a1f6408484b2d4de0dd1bbb2bfc113989bbf3befafc6df883d100fa736aa2fa539c7d024ef309850920695fd1dcc8a80f1d59afb888cefcc28daf23316e4e08990c7fb97edc3df83bd4b4b68ee58eb226361570ef772ed696c0c7dbd00ed8e39d873cc11cedd7ae0c538fdb961dc08e9cc1f55e97b9725095a72812dd438e392dffb35e61bbe59f2012c9103108a14d64e58c16a9739af51a2966edffa749d587a7c9cd2511c3111aa6d16fcf0a504e52f2c94bf0f4774d810d834d1b03a148c7fcedb852a6e87996bc2573c74be047f7ad53fc92ef4195ab046912099fe90bed163d2dfe814fd8778bfc8f83ec38756547a6ff2f8bb6c8d8db93168abd31ca0abc0d18d7565efcd6e982b6f3c1cc85ad2944973b512d850fddef0af7b26963b1ebd4cfec9b385251fd2d1ede75736c41f372ed543e350cc36e9efc775bd031cff7f72a6a3afc338c71ae784ab155b9dd27237209cdbec53968562db4e67e51d4e2ed83d4369fd1e52379424587b3254df73402910cef3c062d7a3f4ff897b51e88bb0dfd846b1e426557a0e81660834d169f25bafad3d8e887998153882a2e6b8c1e1bf25004b2050744abc27a1385f79a258b83004dbb6414faf0a45289bdcd3d5e9ec093d8bda86568de69ff51ba6a97f5746b25529cb93bb959345345677121a9c31a34bf7f4790445fbd8d430745ab6aef8700c92d319d1d2bf3b096840974890e6a1dbd2165d8d93b98b597fa52254a4c21a86ee3d44cc5b3b19374ba1a318d6e641a042617123fcfdf59f0101efaa62c22f3d6e82c5a123eb5390e963cd29017614ce80e8f0588bd1489053ebf0c782b010698c3b95d1ec9e1d69a616e7550df76ffec8759a161d608a3ae75fade9ead76e63b1b6d38913419bf97a52721d583d85e108b141e2779cf25b78e4385dc27bcd67c0103f42a2860a3b7e1988698ad696afb6de38adbf8d844d581403bc2ceadd1d4b62aea12a685f4e02d35f791a02de5e2f4b6924a3ea76f408a285534dfd8e389e6a1c9669a30ac423edaeed35ec5bb16779cc0106f7e78730b382216262b53cf129e9ba3b45fadab9ae356e02dbcab460762456134cf8d362395e9162f5710b702b288deca47ecd587041ca2c673efd61e3824829e3a05eac438e13491db51380ea578066a7961cdb09dfc74d6f236107da418507c911e59e363fdfb9b2b2be17d647f1f0c57e9cfa86635a9c311151bfe40041ffcdc8d9a7ecf01b7ee07ff4b26caf8154a9433677ad895f85e0906f7782a399fd28a914b25e4a0c1b0e4bcf987c1c0acf5605cabe72812b426de396642c4f0b9202e049b950a3c50d53c1b75d76c4e426c3bfb34eed703a545aa94982ff256143822563f8331f093c6597328047587627c22d50702f1eb9be67a21152c2108fc2403d97dffc6da6e8784956e71e322fde1107b899f577009a0f78a75fb5714ef71e89ca07d4943c573b50a61374bca54dc83920dd5217001a6f9fae25932c5a47c513a9bde546752183c13c6d82a74481370e5214f1deb1a63f3a07dea579465bba19fc5d3067c63dd664a0fdc15c6b683550722c74ba21808008f6e5986467031546e708f23588ccebdda132f69b19ab799a7d3be682c13b472b8d411abe2bcbe8b63bda9763f3aeedf6514c6a3f9d0a8735b707107b3f9ebebe30907d77efef3a1349b77804d4da05c886ec4f90a84144d638d7d84d05cfd9ab17fe794068896e09980aee2311acddff360ac3d4bed350c2179a91be8d187f01db899e113b792bc2f9e31e0a76644ec061ebb7919517a5bc3f95b81f60f8435ce72b54bbc9b897252a39686c1349fced00ab3258a8c629751a470f8a5e6fc64f3b2aece95f29fb0b029c5703c40752cfdcd86a4bd34e466989ecc7e322ec26a8152d69429a4e28aacd7e8999844462a5d031d689ecf6b391af300d527bde9c16962b7682cb3262cd91f5b3f2bf57043fa4cd549c5935b74e4bec194aca717b04221c33f92863492bd7a490709297894344824713170dd081cbe0abc04a49061c51a8a1fc9f3489f23c33a01c43a7c0bc2914e258be32e0e8b241beb7b247378a59831b2cb6038343be05befff40602b42e74f73e8ae011d6b2e346a8a72b826ca3f735a23d0c2d1b838a020185b9bdb5f948cffbea9240c09cd13f02dda0dae7650201a6e0d8cd8abf1ef824945bd66820e33356d1741752f1a425515e60ebcd75ef61a02f1287afc17fe85b7b07d6dc23bd1fe0380ccdc1e7688854286500dba2fe4f0dd6cefca9f658954c27c898804fc80021fd965cbee6f845a41ec3b491daee72de3edfda29f65d9cafc8cbd30d6766d1979da180bc5dbe1b2941944fcee7d4ec7db620d679841d82cfcbc503a88c81731c08f07ec631c9e33de4e9fa72fccd2cf608a283be6ac5b48a55d4629b1d8e83e58216f074bf7b60a78e0cef20159de4f4aa6951969ab40655c28c508e0f0ffda0754f80f918696713ae65ebf2b3c17102048cae6a588fcde826a180f2938bfaf777e9eb413bf5fdd146d6a1bad48be7ba5e10044943fc2325a9de9bacf1b2ad4a8cdc9972f28b473e4a1aec05caa53f1cb0ec844d26a8bc69e714a77e57115e2c292af85cfe043cbe4eaa27e38580fceabe2ee66af90063ff0923f88b28900d2c4fb73b0673e35182d84f44e782c81188b00d0f08379a69e2eba1d9e8bca285d009085701b3c93c74712bbaab2087d709584a14293f1b7d98d2317d604f5ead4c9f00a30f9dc00b2a19a025c70e8907772b2c3527366996018f65c35586325a708a99f80e63caceec25dc78748ec49534447a9dbc6be96d93f6cd7083d063b6b0534ff1fba0d82c9e7bfdd419fd7eac16864f565e9c2fc6252510566964ef4f173708ba374381350f7d80fcca60eda935d0584afc32018fb8082e2120d51132b4118ea8144d460b19cd8eac5f5793b616b712d3a4a5a2988a0b9922c00eb41affc7702254684f2288c656fb09101eeb1530887b89eb7c7873925dbf75f40f5466d9edb02ba184b98894c499319fed1d654f46d235071919672502ec1f9f09c7b94b753e0676a82483f858829e6dc5470fd77c3b882f97652df329c1841f7a36043c3ca710045459a3c4ab847bfd52b813b4dc31be34bc25d42ce7d3c5a638b29ddd0e7e1a21c1a02da4245b112be30801f60395dbc6f80c11c445583333485e11030e2408909119e4287fd6f7a6ec3a5b9263e4b7b2d20ede05c7ec9e9b6326d871e643811d281143b8107dda17a2269974b425dcfbbc361ffc6429faac6a2a835d50c06730c27fd97b35d4d404c4668a8f30c4c59c0fa9ceb504b6ea6edc8ea940a163223c986302cb8fc2d187a42872602abfb74eed0c5bc86aeeae5312df8d7d1eb9f9d632a5b474b4fdad5eb4045b2a4a8fa6207750a9c3743cea1996eb95cba2f401b53cd72d92428b2a53ab88aa88a9ffb589af5c3a9bf4ec3e2948e27dd24ae64307d0173c0c9b65e23c3627c8145ed080fcf501c32cb0bcc26c8ded587200cf1d39c7ed26f6b064d5b3bd18fb8d428f59c080f0d5284247be15fe79df1b509bc292a958fc00a48d9edfc0bb54f32104c311196287b3621748c398b4824d6b378e3dc170e15b737f57fc541841aa99c683ac2198dab09eeef7304679c6f1f93a31aa070693c527975a0317ec9b30e1a5858bb428497b42ebd2a2a48eff3057bcdc64e1f1f5da8cb319eb7fe09446702e4c6514a857db03691bdd17e1405e0bd7ab89b783a1ba424d55b68173dfe77ce47f1d4d74848dd415313e32e3e8220d7f0401eb790227251f2408eed9674252679e69ab4f1524264401785e73b1fb7f696bedf12cad0f65e9dd7c39c7ca16da5948baea618b5230bfc56fa54b38611c2b76ebfa5f3eefbfdeba0dca189db18d2efb350c5ea4df534609bb8d700ea7e523496bef71adbc30fe178c6e6229fc352e632ea2a50af09104ec239e26e52ee51acbf4d3f0a867ec2ea1a67021c9f5bdf7647e20ecdc22162b57705eef21cdbcb0f3889d399d2c5a49e17b03d8bdcc74b632f669dcec982df8dec37fb5b74e2f59baaaae88433647281ffb98e896733b84d22b210cf409504aa75c2e264ebd679b5679e0279ada43acdc6297b43880a33fa6f9440a06e075d93b8e4b9806f9be57aae0d433086a92a2b8a99be77f332941937c02ae2608e3ba4b5283c0437de22343d3cb0605a3b075385a631a85e733a83b7823ff1a7ba004dfc1390c34beab2234f7036d43816a3e4e4908eff86562924e9f85960b1ba1368abc23e152f025bdcb8058b458ec6ab6e93f7f5b4046c222960dbdf238488564b0debc6db4758e2824ce10d7110e0108e7972df510e5671418936a1e0930aa62c8ea24b2a23a745bf18bf1067af2ab3785d7d74786441b8e8c8bbf5b6b7abfdbd75a024b92059e0732cc435d4607e6bb6ae21e61f461551176e5d0ad87668d79b5a3717e80d934de71bcb8371073378506147533409bfc55e95f2177e57009f6b9e0d0fc93b0107ee3873cdedba622477416e1fbaa6eb89b0c96a10de90e740029b97cc047b3e5161ba0743a6b3739af8c9d6d0075cc0a8b3f5f9c73f748981c1299803e93f1956238a9d7834d02f7a34e05347a6baccd8852cad4e61f7662e91016083031b10e2f42e2991742f3360bbd6265838e68891e1d9a886d82fee3419ee86a960d00e8e85cc4f8aa99f3333b24cd35188832babd43694ba04862d0303ed38bb1b6123fd250f0a9a3541558e3796c37f421e69469909cf0df91ec22e5f52cc8246b7c2665090573cc667286ade5b1e3ebf64aeaeceb8310b07341111723bcf35f6243c155f95f3050fd7661287963924ed6f8fbf6cad1ab2a4b4e06ac2eb4e2dde70cb6700fde4d3ae1f793cad4fddc35eeb6b5e93e693eea2d66229f690d110b87b52362ee8b168f608ffb3671f98190e8474d8062ae5cd4e0fca81d701b7c13dcbd51685c8a6d909fd313c7bec7484b631b7deb1085b085d95b4cc959496744258b01b0dcf67e9530e5295755f17cb6ebe8bb979fbed8f21b22784ff07f1559a437b673076bfebb0410309b0ea868f721400f5d0ad81fe12075ab5ab6ee09d94171f3f08eb60a1d2811b4d57222e060a1de935ceee61459a546e6b00f45a8aa1387e224225407913dc616026e1c19e9b705b5ac0ba2ccd4930a19fa9db80bfb29e92627c8edf2644c0391367e245774d04873dadea92ae89bb5777f607510aa9ec67419259cf57735e441ab87c00399a62d1261e0f7346877d36edb0e56884d1b302ba5a6b3813ce2beb72e2a632a23fed6cd51cf86285ab9e9ad0f37cd47f1ad6950cd64c137622329a8cb50f51dece22413a163273f3e9063b91ab76e9063456f2b7ac610a641bff0901a6098f2ab3ddd588da36e6cadd59ad1bf9ab2e47150d306e2afd9db8dcf40000a1b44153b3e29486ac9fdd40d6b6a7343332292319a1cea60c3a8d5d51ada6151178bfc01e06430851403501ccf5584f6cfd8c5542d1c626be62606562abe17d2b9e9401cc676ae6f029aad7428aa595fb76d408e93860318ec086c8426917882d2c5e2ae8eb2da58bb68351b436326cd2a601dc03ce81f639dbdd605658e9fde6c038c9f4bf8e415f5374dfc9b20d4634165caac85656d6dbbb574100f640ceb59ee1ec4e8fc39f43500c665d7589d2a33f0bcdc0f00ea534bb7a725ea9cb8536ba578bed475c0d99f5d9777a68d3e5eea0c6508afbf56c9577f91708be06019d4e2e8448d301a904ea856e706861343b134725c0b55495b10c39c05639f4a29435777fc55dbb897d2af5ecdc18462dcf81180fc41c98c5e62e685025023b43179abde875904958244a7b8aee906fa7d5cb1a70bb68c4f6c4fbd6d111641e3ebb9efa2871eb4cdbe0059dc4d6f14b9f86119113887629c057a9654015d0c9c8c701805720f065d4dadcbcafc318fc49f0d9f4c4ca9c8b0c927730168ece0269b5ae4d27aff53a26b63f1ab5b105a4c8468eb2aba2e84f83c1d12fab5c2f3f99cec41f585595bec547e1d84f21ea4d0cd096ffaf312923cae63d5aff624a9d8bee9d952821ccba5f851f5b3d4d478d4a1aefb2200f38156f56a864103fb0077c50c2c901825dcf1f5bdc0339805736ea5d40b71593cd9d5087013a9efd628350e36b6691fb23fd98a5c16f07ade919a1f10cef88708796c295ca77bae0ff7f690e18588538c47505644d32de5d010b05f8a3f01ece1f4a4a74c803fd05aafae4f55fa399718895212f4ae2df38ec97c807f3e3238577dd23e9c4037a71ed9b8f05e915728b348c7156a72a2f27d01d1c3e1d0e9e08e60aa9ed870dca74031b5479749da6747e37086cd247bd67d506cde2eed15ecae8ab2d36b59c8aceec7809470d019c0148f6840819f79185db5620bfaa5c2565e1cb86d08cd2b4018d535c47a1c2f2b0eaaff9f37b89c9559d6861224d55a8583f49c885fc409f8396c7e5de04a7662b71663b262e45c406e4de21083cbd43a93869622d277e0afd6726c48ed3d4efaee1292d943cc8ef4c23ee92f3a55937a384375548492db8f0c81625f2fc4d37b890468b70a6c7b62f397af7b71b542a055e75e9eb0e8f7035dc4f7e1a1e17049ad454b583cd9a1d17856757bc663645f137748133f7f49d74b3a3fc8a4eff6fcff17ab165433e4157b08eea52f60f24a5e2b3de5c601c3b1e4540a866d4c495cb809781f667b71e9a2a5122e8b415c4170a9659a3b61704f3a17330f2d26862e6a09b488225bf4881371ea9afa805ac883f14bebf8c51eda0fd15372d3dacbac2b17df24af32727f041b3eeebc41d87ab73a10705db1dcb4534a81a0ef18db6ef4c8d232a8f76fad9e4d6bb82a2de571612d76703eb02dc76b05f4e610012b7851c5104df96d289de45051b57a07cf0cbbc0d53317035f06ded96a771c3e731f51df72abf4c8b08b9b2f807f2e60802d6afcd130a4fe1656a83991f80e05ba15b56c619f491754d015cbf1ef7ab9c974a02ad5ddae12d55028d789cdbb0ef5abb68691e571902174ee8dbdf269f02e92d2ebd36d98290bed95a7b8a65862e69a551f1c91d5bbe0e862dd846e28ecdbbdcd2fab15f1549c3dace27a05032f69b9acde25defbc968fe0131180d5c9ee01c7766ba80f1896a84c79fc808047b4cebe9ba09ed93c4026aa828b825bd0dad6c73a675509a10b7c3d9d6b65b8d480a26c3cd58b7e3622114364c41afb5389692b646b8ece2ddc60ca91ecbc62e3b3ff62b697c770310a0c1f87f2d6eb2cf336f5a50bad547c4ec2c6299ecb1307572318670e1e87c22576c401be94f90e1a3958e00fda7e33810c8b39426bf16cd8ee4aab4f4be1d13bcc0bb50890d5207f14dfb9a210b21220611030fdb7df46f265adb841e83613204d5df31c2dbc982bc07b10842d89831cc5334b6d2f605c4f46d102a789aae2b376f7089dac846969fa5446a335c3e5b4669610290fb89a75d8dc3521458e7e4e5da12061d818330726d0c5b1a992f4abf7ab9b5d6a86ee22f6a3351a0c66fe9f86150ccb636e530496babde617bcaf632812cf8b6d4386e1cce904ba21cc1ded10a00c8b98bddb2fc1eb6a511f216191e9adbe291f110a99e4a536f760eb8cc62cb25634d2335ded08a95e17de0c9da313dfac97ed69aa67b922c7aefee9fa4918939e4dc00dd72dd52b81843a78b22596338d8353d7636aa2338ec46777dc9622a63cff5779f9f933230acb4f8531f13262ed151515ca240a2ce4922239c8fc49f10e2eb7a38ef56a37e991131b3a20f745b861cd0fb7781b0cf9b655a2f635a1d7194b8ab3e7e42744364b66c183286aa31c80538bf6d7225448ea9dcdfbb760271abc7cfb6addea1072e11db2e28ab1f14c301bdcb4905781ddd830784bc160d6d06898b319ca2485f03ae9987724eed93fee65dd0842a0ea399fd138f73362e7f498bdd28b9974fa3e75245fc65c92073acfc86ac26e3bc9dee200dc1166c1e5722447b2aaf7f13cbe80291c971af00ae2e1560721a5c57d41d779e15a2ba67d1115a4383561487292ce3235cba921e0258f02a1fd670aa26341ff71fb9e939cb9491e48a6aa79f96daaf6acbe351e42d7263ead37001c9c87db91ee383fbf0adfb635f245ba09d89f9b6612b84c5fddc9205a196f0a0429d1028b22c03bfa6d71600610ed5fbd917992ab3accbbd29adacd737ded58aacf46b4551374a6ac8d8cc70136e9566c08b2bc2465acca108d4cff2e03d23c7a76c3adfc172d059b6f2b6257d2164d499202013d97c5c3fbc0224800fc8b3f63c2a55706c1845aebf5c187a6322b46ff7e7390a5b5ba12cf61afdbced954159af92f1ed0f6a0c14ac098f91afdffd6a3fd1d296809d167009be30b49cb7a363a10873b72bb3f30d00313ee7081028e83fab30b97f54a5442c2c3e71164c59ea4a7a9aa3d5f2d0365e18f43903f1428983bc8f1eaf6829201b46913e12a2279c53dd074a65be1ece32db8c236571844ef5555f4df91cca0cc1e10e1280f53f136e85f6702e1cfc1432e6aa6a378152936f6bfe209f42cf167c14aff0fc1df09514b21d9f7d152947a39fd7f847d4c90da2f83dc73f305d6a7d414f44bba2b3d2f43a6798def76554fd0814d57ca742f00248edb3c056d8c432e2790f9915fe2e1fe050ef81fb63aa7c7bcfe4a98039c376a51f92a6537d4ec1ee0cf8e46d9a13d750bab48127fe2a0fb491ee31319b7b60bf4a25af9959b7d9ae0a51175a7724786249b5e60c7084e8d8e1163f2370aac3432b8b867b4f0fc1da9f45fc28dbac73b324770f8167fdd7883797a1084baa96ff8e1ed2445a400365e75bb93a6801b1ba8c32b9a12576c4f97056e11e95331986b032526a6a92addb0ca35e95b6a53f9c036115353a3c67ea5593fa242d4e7341a7c34a61a78897da2db455d3e8ab81fd4655f702494d670fcab993f9c79ee1a3ae56ef7801cb37894a2ce521126cfb6723097e6baefcac533080e018f3f0ca2d2044b733c70c3dc5a206d346104994773714f38f443489bca6dfb51e8bde57d8da75ff1b952303c2ed13279e156951f8aabac1c4cda68f623b2c9f1027356a18ede4cdfc91c75a4fbb9b59972706ff299a7dde782b737c25ac16cd9629c1331a103d3242aa507396af1c942fabb4cc9e335d531a419e66cb3092f3ddd097384a34ecba00ed0246e7a1de7d13f5099d711fd1c03531125b18cd593c72b3b3047f825fd23fc04c528a690eab3a716a27bc77e218b6360cc61e13de151567aad8400ee2a0826923d2f566e04885abf39f32dbdc08778b15c91ea9761ed46fbbb9154c68bba6acc6737dc7decd2479612bf071cce3adec90eff1cd438c93227ccdf3e1af4e7119cf0969ad8b58e1f96697cc9674071c06e8f5f0d533ae52fdcd8d94326aaac0b7de415781b9866ffdee85e7d2b60ab65e545b4b4703c20c8d3b42db08daef50e7bd6eaabe84a60c9c81e1e9b48abe5808989dbfe790610c28b83c853c1847b6979b5fcc7b86e5198838b5737b00243ec290618596d032e63909c154eca820e10c32037b78f4cd1c663509b5f63b9b52c83fa3656e9108837857a2bac84c489bf9fa32c96f57abebff0f5bb19049d060bf674aac72198e57ca94b44c4c9ab2a773f0e20991cbf00a16bdac1555240ff4cb8f04a653f0d4b25996bcd476b4bcd453cebdad3874aa8d5cbef41a43f03007cd1dc07febb6d8611a593624892753afa5862ad7b714ec8053e42f9311397fbd967094e0bb924dca29adc9ed63fee4d4e618debecbb0a75a0ae6386509d57b8b353164056095bc91b92535d3e22b5e3769f71d9e756f2a45b32ceb7cbc4bba38bd891c028761fb1d98a4c3fe562b9f1a9053870d54385d1b34473edfb3e01b448303a19138f1dff0f4dc326896eebf595ecfe9a4924c635b4675954f47ed5c4efa74a9553c7371c20ad3c9a30e0d3a6500270165d9e4456dca1fd0d75e2885f5c3d83ea0114820d52a783915961e71df4ce4b9389b6f70cc877c91ea05057dfc7f9df6ce41ce110c07f85f504bdae0e0fbb37751504914db5b211e88da0f063012e958985ba36a23f78668ff2356f8ae46a168ab92392ff6d7069eb8ec5f475f612c09a954af92c6a706cc327fde08221a6577834a9a59c8599584eb1429e26826b1d461f08b6a904e745a738adebef7d045f1946eb22c127b19ed5748e88f47041fcae7fe8e7748450f4e703c860f85e15b1e90fe6a7ea78989f92eb4e2360a739b776d0b849f0411e8d219d0a8fb81dc10bf87cc44f8d1257db3edb76e3d83a4c0c2cb298f82ffaf7b91647f10d7edd802a51f044242fe95162b50840d3341f4eeb8a146fa1636faad90ea0eceb08c7aaf09bea9bb4cb16097566c8fb25990aaa49f7bfdb63d1c6b6c9ab338d0c02d1e0b4671c136fb3259ccbe88d86be5f5f79a50b099e653da11e3177449a982fc0bc142b8ac48ffa1db360d5858100890178f30d6f358f79bd3ded11554c88e1653cf85e6159d6d55774d54aabca2f6a17ffb43b74fc325e81d7ea03c081bb6f808f7075964c1190573e59c628da8d7990e0ed5be0cabd2667b3ded30e9cddd9ade60cbaca7265c2fcaef8fed295966912a670c0cf2cb616cb4c1784f2167bed160b18db7047748633125c9d46316d2a2d7091b24a35353aa52d926aaffb38de6b449408c332b438b5d7821bfae56d615996fefbfc22e8b0305b0243ecc3438d22f1019dc8744cc2cd6e4867a9ffa4ae40018d52e499ae97e2f50558cb73152946d0aa0623517a4417d7385bbdab84021413dfc4f65516c3868876d364a1ce00a129c1f87f46c4c8019c52d45eb0094d4e1a9ed1c046d414432c36304a9ea26ecdb75e46b1f8cdca7940a239662a2f22c8b02055848e4143118dce8e3482b5638df631b35b76b45dc5910ef562f4e5e01a21c483d5c7ea4c8aceca82bd67730c2a753dc676f3d6e4a0cb4f9bb1410b0d1afb0cdd6b9baa466beb02d5c319021efd03ed91662647e3f81568c834169e8c349b9bf066feee778f7bd69fe11b809e37c8d3d2f248f31fea378c7f571e5a58e3800327d914b670e443a96c4ba2f0aa57eb5760fef0cb94ae076b9f71f4058015214f342fa615711eb5feea0336ebcf31be10665f8f6f152cd01edadf751dfa2f5068dc9ea2125987707efb951e88feb400dbb0928b376622cd3f714c5ee15a7e672eea8ba35dfb8d7ce1d40f836c111d5329344219d42f9bad825a8e23b5af59be3c42bd8b3920da84529ae0fa7a3584581ba334ba8f347191b313a0f5ccde6ccf1c88dc17fddd1cc4b8bc5f9e0248d8b1c231ef18412aaa7863d2587e140a4f94e56213de3107cdf50aaf64bf4a6146b68baa3ecff0dbf5df10aebfba84abc93d44ade925d43b5ec57dcc7d26fc1398a6d664c14111b3a7bbedbf072161a319290050d0bab549987e307b4c1a2c7b2d9b0f84a33a74c72fa9cddd81dc7821797afbb458fa6c5968200ba8a9bb5a539b2b870105e50e0d83f833fd3815ab52448cf4f8134432de23bd28cd83b9e2a5a9740af6f4e0eea72e015f92ebde431b10169636ae6ea7512b4e3b7469d28f56b5bcf7c0fe3026f1c208cf5502805888b235c78f905af0ea6712c5c1ff2680a64d663e79185f071ac211508a058967fd4bc04eb07d8c68b893106ef2d1fe8d37d472fd7c6bbc20f6fece777cb5fe6dfe1a8a7d2d7d9e83b223d872ac8322a9a6cbb23a53f88e3a58af16b64753fe75ca08e286bb94847309669fa51f009bdb9bfe0928016757987f8aa48617fe42c5c597e23ce523ae6d02d15c6faedcfc0780924ce02a612964ed4991ce4c509c66a1399359da80d3d35ae76492f7680821949a4781c4c23b183a2e60aea71a8388009c9adbabfcbad7373360348ce7ff503d33b0d92a010ecc649816c48d1a580d4b8c06f8eb38bb2b910c09f05563f7908250a4f745ba58c1ec009e63624eef805d2ce340153740ee13e5e45a45fdcc55c4b9e4e20af42616238672e5654f0bb8f31dd658854d138c1306a83570785a2d988237569add5ad984a6b8c69d3a51e51f35419af9160f9108d5887e9ba06c031b6d02a524065055ef16e95f4e683e29f1e096ed753fdcfcf353cfc0f1ee94b7fc232cecdd8337f5f4950f44691b43bee79c16d1e210ac39330f5ed58f8410a6654f6e4f928bee306dfd5581864d64c94b32ec044d4ef261671fdda6473f62dd791262800e36c8262ad494d8ac8867a87fba1dccf7300972bcc61804013a45793de280bfe07140c8f8e4cc8e195139ba7cd5a6842acf65b725927b6d184c09d1fce33796705eea2d7fce760c284ce331ccaaa5d366c1a295c454764205afca6b653241fa41c4a831f7885cc99f760a7fdf32b9108e8d1f817bb8423a8772d514ccbae7378ead7076b0eb72e0225dd7dd0dba008cf79618db41a435683af2fa4b0f75f791917a036003daa9884916232d10f8e58caa630df435029ff3ad85826e4659523e365f8c773d8ff9f3555bf2ded32da4e07e45a4515b83804bf52b1761cba57f469280e143bb320f32f847635866e6430a4b608e22d88565f6ec5632a5eed2ff8552e9b15ad38919158d81f1ad081507d8c9370a1051cb9dac144d451c7e554f9c49e9f378e7d2d0a523346281b94acbb58b4851c5616b87ca5c1ef610fc82305ed6214a8d098d75f1305e245f82ff5d7e9eccef2774053445ff6574d20f24a5345d75805272a3de251b2c5de533301ad09f273cce57d6ebdaaa5834eb73515616debde45ab5711b4f06c7635d4b760bb143003a2757fd3171282445f4241bb06df2ff3043f3f36e054ef9dec6e395e51b0752f75e88ec1924bd966e55e376676c82a448fb7b8db75ebb3af5834a6573a62c82e673dfcc6cd94cf3c10a9edae3cbb0da10ddf8af48559db93642b5b393dcb9cf6acb17f7cebf0f43fd19cce97d4c4cab834436b130ad6ccbfc15acebba08490a452f65c8a258222a4df5b3f67fd2cba33cfbd51a0cc542eb13dbb0562d44be545bf0a6274c9be186476b25ec42faf18df9d934f85b78acad82b8ff8ed374c100bc0a1690a1966a057d248b598344d109ef26a21c415f376ad3f6e36363981e9b01c55e7fc4dde41c97826a2d01f10aee476c1b56573468e1b6dc07c9eea25b3afc4b2d38a237b7d9696c9afdcceb28df569065eb665d924ca663db901ca6875da6cde8ff001a33391feb4635565e832dc9a98593b8af89c0e17b9e81e93e03ea6b523cea650df215469c82752e0526cab1a6603e19854a6cc89d19790606bf9f2ef0a906a4940fa1e2ede1d0d3862d128abc9fc181fab8afbefb7c0f88a8508686b219a179a765da76769e3acc58a915d39df1458da53e1cd8dba0548e1a87e6d9ed1c0b5c2bc4db249ff08eb6822a2fd7658f95bbdfc26702e3f5b0d4206e0c38cdffc40f06c8f3bb533b9088b4ee626c96d8c2950410afe89005f03931115ad9bdcafeb9fb9b0c48eb78892d289456bc38b685090646acb6e100fa6e4d361ba1798c86e9f92471e56dc872629476a16a7f58616da79093178550806314a35fda0a843e3c331007b1d1db43fbe1869eb88272e06a78e5d4015a9c3a970eaf1265668946e9fcf67fa252c7d3b1058d3b0c7983d10351d720cd0278b3d5f111d2613faa243787d32cfcb7ed4aa510a3dabe007c6b69577d232fa77513189c81d135141ce9397c2bf8285c86e3a8d0fc3b6790dacffe8c4b806464561b215b735ea05a9cccd424a832af2e57aa1f469a5a77f1ca4a5b93cfc839f1e42a1cba0a92506a552c6197385bd74afa4de725401dd19ea81030ee522c1896deefc15ec524a69c17122c780182d1ecf712ee95d0e8ddf74f467ebd2a6fe900986369649df2cf51194315c1a0435e5227e7a6071029a1275a888501b67d0e9eda40290bc3177c282cf7acdd395bcbf7359a855d1b79f41fa5dadbd0c0d5990aacf7c6e2f4f57a14b326713ac4b1e23f4532067c46154e94e101c212d0960fa15a87e657b6c813480d9454ed0a670cd3ab92584b5ffe9ac7b977fbc66b70c652a95dfeeb08c09e7f46dfdadf8fdae50c3350284215a472b79a74d62a45230597a2e798f726cba67037c9a0410871c937f6011ec1b4d39132253acf76aa344455f7d0a229adc22e4cffcbc692aea8a3b745a7110398f5f35335c302d57ab952f63ee12365690e53b9094bccd786837a3d4121a5f5f4c8b9cf5acb600cec93003996bb7aa4c72961c99d8144d658ad7ad226530ff6f29cabfc9f472f11456a14ef5b27933cded642ecdf2730a389476f2043ac9b390f455637f37078e7d460f627ef4e41202776aaa93782855a4de6ae056fb1998a4734835275da39b5aa105f4afee310ed759d5007355c8c2c3eeee509842fd30652f3c058b84da0bf91544b2735dc20cbb393380072e2a9e74a5f3182b8fe7f38e31ef5c307e1631f66fee5546dbc5fc7c40ae597d6008bee88df9e7371a5413cd69c575db496702008744afaa3bb0d114190df8ecf5f862aca0731a85c98055fa54071e019dcc66a64cadff65e3e9ad240c62b05ff8279cc3bf346509bf39a1c127835f723995bfd391616b1b3a37488d6513410eb3536a5f5ea495d2d9f5a9e7bce1072380dec895caf22179d1f15ff71f73d9de591f5bf9132fe3336c49f93bc7bae6d59d494f417701cf0340b5160c53701967c8d776833141ed017793d6c0a73e998c3c961987c1ef463763cc6f58c4e8f728bc2e9d62f32d27ad9268dd6b93fc700da9b1a4623cf49ed42075d239249053acd372986c5d916fa8731f2102c58d830b12d94e0a7d2b345d48e7d9949b385b2a34edac5f836baecbdd0fcb56698cd6ffae5204e3cec3880a6077cf25dfb61f142bb4619fcd0bc033f136aaaf5eabb0db9c8ff5f0215689b32ae318ef0b23c703e2b9fcc4ec956c11b7753b780edee7049bda28696a6e8b4c44b89355b8d73fc84b5bf30fe1823c70c708567de6030d0ff613ce1210b1a96efc01a7ee0231e0ac786b5c08ae03cf5a8f7ebdf52bc580cb1b31612064e7613d81d6ef52b7ee851c42d3471986ae5dc06a9a50d85434a45f88142a49558253959a78c505ea7b19fd58a9583570793fe6f234aa7c2dfc9d688c870291b4dcd23ae73b65bf04ef5f8b0413dfe128bb9388e43f8f44a77d8e543b1c063c5ca0d24261d5c945fc9e3d097fab84fe0f6306f6db7f27e619cbec94fd58a1d4dc5f304b6e212f604cd9fb82e6034b44fb742052bce5634de6447a5aaf50d9cc3eeb0fdc30c85977312d648f3c42fc1d8172a30544cf5e80d098641e2fb29c7633b650c5a21374d4daf92720522c30bbd3bbd3b28b23698fb35c5bdde532d1a219b2ee7bf81ea47fc18c8004f3cc956b077dc6f631885feb09f8deb6e874cfce0c8acb9a90daec5e56b990adb920f8a8725aea0e96ae8543b35cc07122d799a5c6550d0e3c334f902911a3f094cfcf4fbf14f581039f98544f7df4e33e47bffbfce4b5a5f56975844766e0a9722ef51a65838fffa9b89a3af6507c87143bd5c61a3690750dc461154b628283838ddccaac9947a4065f9e334c24d721031f8bf85051a0b8d0b6c99f0741b1928a3c32336aa7e42b26773e1e8720ef862d78abaf9855cfdee5f18cd4761e6064506a22948faf0824676af196dece7759998749e12ea568d82755fc32b64ad8adfe815e2c2a32b8f8c516d758d122f4d006fb64beebb5f0a7a1c5bb90718576dea506252d229c465404ff513bbdadbd92e442e3d86b5d497c25c4fcfc0f174ac5ddf63e434c6e472e969e63fdbf732e98f9509f309a7594507e98c04067f1ce967031618b5d426af72004b1e23b67ef9c0ae299200e3be5bd76b9e95d30ff63d921135d1dfa861e2d1d98e6f94d87d293f7d34421357ed9b7303315df114b357e687186c357aa200ade7d23ecc50c05dbe87e34d25d1d8da9ad1cb2e6f6a1741fa159ca1bff24cbb8c683aa4ccd9199e5a58b8ad4c36c54ffe00f43bdfbce76e29e8c7e44dfc5cb64ac6b2c9099e6be3bdbdb876625949ab0c17b18c278634f5b77463cdc64798c192d04706ff903839cf8cd560d1e75b54ace5725457927b07c3cb350c4485e86c4aede7e7e6be58fb75b45308dd150965e370241e4a3c402f3894b673d0b7f67e3bcf4b7d7aaabe5b35f32767459773164b5b9803fa1e4afaed577c238d72bea9b30374b708b91d14db2049f42f948acb7770b5edf272978c4806862a75a36002f9c34caf4f00e443480563efa1c81dfa2df3ca3314133d1a357ee187d0f374e58d1dd258ec7e44d510648ce1be6e172bf667f149c1c112848f6a09510b928e1cd008ef2ccba13e0e91fcfc49d47fb725f0589ff09aa05211be11be4c5bda3cc2d08b156b630c15b96b2ecb6f7d555aba31986250891ea7c6f1fd00326e36b7440c5b4961d1baa3767a73a49d3ede3d2326f20e2d009901c7156bb38f9db3528da3d6b381549fd9321f1ea10753b8bf1a007c4088d7046b3e7a431fc7431d930600b89030ba7cadbfc7150aef0cc2d5fa014d23e030a47404c1514cebcb78cc78967bb1a53fcc4175ab4c7f47924ebfe358afd344b8df666fdae819afe5784d026eb09121be13ec980b801acafd079d125b22f45e17e49085a1a4840bab6ab8fb92fbb586e5a314c7eb1296bb0c1574dcb6a16904bb30eca8e6a5d27412c7f4ea3f9a27f3ede83d98854696ef4cf8e06d585c99e260f8b1e60de3fb797ee9c5d0c627d2f4c06a9e983294da2640a525b64ee241320a77eee3427075237ccc7ea57b2eacbae01a938296597deebaa09d81c2049dbb90a57d82c4807d6d5a425518fa64110b724fa823d279f8ba8655575c9e7d97ac80562cbf5a511b20c5f6ab952b0b52a8d161015f89860395f7312b57075cb00d879b7a78135992e0b2197d45dac4ca9a849c1be2f14aa9c073096a2a6d6c50aa264b16ac6d31c089ca36d9a6e0789e569353ea52490168b93b8d6fa31f80140b5148c7c2daedbdbce71b7f9f59603d6a4cd894af228c14fba78ff674b0c6931085884c02496fa2e341481ad2109eb3203b91c42aca9024b34931e5ea52cba2412ffeeb875e9617b675780e61c946ca21b658d82665c114f6cfcf07501880e6642eee8f60d7f8347d2552636efd8b89799040fa2cf64f4ebd6b6008aee10bd33c07ba35091db53f0f11f22b44543076b0b59995cce2f1e95f2a7c6805bacd1baa3f9d4f6505f3de53473952a64184a63e0302ef191035a3ce94b1e1ff00c1ed4d71b5df94ea30f0a136ac5af5ac1d9946ebc125f7f94067d4658021e98b039d0301acb82cf6ddedbfe77e976829e82bf55ebd3938a1ddbc48349e11301d9c09520b8c12682e180023d4156fc43bffe14a29d3ffdaaad62fdb87cf83d8c5228efa34deb05a83e78ddf43e05181d02e39ca83fadc77ae6b012e1767c044345f3672c9ecea76325adfd12b37e6ed69106577e9ac9bcafba8f36e6a53bf825dc74135f2e424b36c2feb7f3fb24f46337b50af773fe78fe2565e52276af6b9c4533</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>test_pic</title>
    <url>/test-pic.html</url>
    <content><![CDATA[<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">

<p>微博的图床：<a href="https://pic.lizenghai.com/#">https://pic.lizenghai.com/#</a><br>每日最多上传100张。还可能会失败？<br><img src="http://wx3.sinaimg.cn/large/9cd3e769gy1g6kg8jv0uwj20gi0jyh1c.jpg" alt="aaa"></p>
<p>github图：<br>可能dns污染上不去。<br><img src="/aaa.jpg" alt="testgithub图"></p>
<p>sm.ms图床：官网地址：<a href="https://sm.ms">https://sm.ms</a><br>特点：永久存储免注册，图片链接支持https，可以删除上传的图片，提供多种图片链接格式<br>图片上传限制：每个图片最大5M，每次最多上传10张<br><img src="https://i.loli.net/2019/09/01/himBgnrRaPVld1T.png" alt="20190815084633.png"></p>
<p>聚合图床：官网地址： <a href="https://www.superbed.cn/">https://www.superbed.cn/</a><br>特点：将图片分发到多处备份，借助其本身的CDN加速功能，节省服务器流量，不用担心图片被删除。<br><img src="https://ae01.alicdn.com/kf/H95cba61bf4a14818b70ccb89894b900ci.png" alt="aaa"></p>
]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>天国旅立</title>
    <url>/%E5%A4%A9%E5%9B%BD%E6%97%85%E7%AB%8B.html</url>
    <content><![CDATA[<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">

<p><img src="https://i.loli.net/2019/09/09/IcUw5WsjhbGYmlT.png" alt="Saved_Memory2.png"></p>
<p><img src="https://i.loli.net/2019/09/09/XDAKdzLsoYnP3HF.png" alt="Saved_Memory8.png"><br><img src="https://i.loli.net/2019/09/09/KtRvuZnfELqWC9k.png" alt="Saved_Memory9.png"><br><img src="https://i.loli.net/2019/09/09/QCnb92H8UfmLEkO.png" alt="Saved_Memory10.png"><br><img src="https://i.loli.net/2019/09/09/WYmx4RS1ebr6DIF.png" alt="Saved_Memory3.png"><br><img src="https://i.loli.net/2019/09/09/BV2Fr1oiyPvDxqd.png" alt="Saved_Memory4.png"><br><img src="https://i.loli.net/2019/09/09/ihdkgzsEnYFUTN7.png" alt="Saved_Memory6.png"><br><img src="https://i.loli.net/2019/09/09/YJrthXoDLxFyTGq.png" alt="Saved_Memory1.png"><br><img src="https://i.loli.net/2019/09/09/PlLtiIhN3yRA4ns.png" alt="Saved_Memory5.png"><br><img src="https://i.loli.net/2019/09/09/nz9eSMLa5yUxvfK.png" alt="Saved_Memory7.png"><br><img src="https://i.loli.net/2019/09/09/xagRIqXjJKv2ny7.png" alt="Saved_Memory11.png"><br><img src="https://i.loli.net/2019/09/09/tT4IaXVMRHxGJsS.png" alt="Saved_Memory14.png"><br><img src="https://i.loli.net/2019/09/09/pDMBcbTXQK1Asg5.png" alt="Saved_Memory12.png"><br><img src="https://i.loli.net/2019/09/09/b3wZcoDHPxG21dm.png" alt="Saved_Memory13.png"><br><img src="https://p.pstatp.com/origin/fe8f000115e907fd41cd" alt="Saved_Memory15.png"></p>
]]></content>
      <tags>
        <tag>Gallery</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构题目</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E7%9B%AE.html</url>
    <content><![CDATA[<p><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"></p>
<h1 id="面试题59-I-滑动窗口的最大值（LeetCode）（单调队列）"><a href="#面试题59-I-滑动窗口的最大值（LeetCode）（单调队列）" class="headerlink" title="面试题59 - I. 滑动窗口的最大值（LeetCode）（单调队列）"></a><a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/">面试题59 - I. 滑动窗口的最大值</a>（LeetCode）（单调队列）</h1><p>给定一个数组 <code>nums</code> 和滑动窗口的大小 <code>k</code>，请找出所有滑动窗口里的最大值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [1,3,-1,-3,5,3,6,7], 和 k &#x3D; 3</span><br><span class="line">输出: [3,3,5,5,6,7] </span><br><span class="line">在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; r;</span><br><span class="line">        <span class="keyword">if</span>(!nums.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> max=nums[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> maxindex=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+k&lt;=nums.size();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(maxindex==i<span class="number">-1</span>||i==<span class="number">0</span>)&#123;	<span class="comment">//第一个窗口或者是前一个窗口最大值已不在当前窗口</span></span><br><span class="line">                    max=nums[i];</span><br><span class="line">                    maxindex=i;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k;j++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(max&lt;nums[i+j])&#123;</span><br><span class="line">                            max=nums[i+j];</span><br><span class="line">                            maxindex=i+j;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;						<span class="comment">//前一个窗口最大值还在当前窗口</span></span><br><span class="line">                    <span class="keyword">if</span>(max&lt;nums[i+k<span class="number">-1</span>])&#123;</span><br><span class="line">                        max=nums[i+k<span class="number">-1</span>];</span><br><span class="line">                        maxindex=i+k<span class="number">-1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                r.push_back(max);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>思路：滑动窗口就是在前面加一个元素，后面减去一个元素，这里考虑了减去的元素是不是等于最大的元素，如果是，就找当前的窗口的最大元素，不是的话，说明前一窗口的最大元素仍在窗口，就将前一个窗口最大元素跟新加的元素比较，以确定当前窗口最大元素。</p>
<p>执行用时 :28 ms, 在所有 C++ 提交中击败了89.08%的用户</p>
<p>内存消耗 :15.7 MB, 在所有 C++ 提交中击败了100.00%的用户</p>
<p>缺点：在最大值在现有窗口被去除后找最大值的时间复杂度为O(k）</p>
<p>改进版本</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">       <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; deq;</span><br><span class="line">       <span class="keyword">int</span> n = nums.size();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">           <span class="keyword">while</span>(!deq.empty() &amp;&amp; nums[i] &gt; nums[deq.back()])&#123;</span><br><span class="line">               deq.pop_back();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (!deq.empty() &amp;&amp; deq.front() &lt; i - k + <span class="number">1</span>) deq.pop_front();</span><br><span class="line">           deq.push_back(i);</span><br><span class="line">           <span class="keyword">if</span> (i &gt;= k <span class="number">-1</span>) ans.push_back(nums[deq.front()]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br></pre></td></tr></table></figure>
<p>思路：维护一个单调队列，满足头为最大值，队列里的元素都为窗口元素。每次移动，检查添加元素是否大于尾元素，大于则去除，直到队列里只有比添加元素大的元素。之后检查头元素是不是不在当前窗口，不在则去除。最后头元素就是当前窗口最大的元素。</p>
<p>在窗口数大的时候优化明显,总体的时间复杂度是O(n)。</p>
<p>执行用时 :36 ms, 在所有 C++ 提交中击败了80.64%的用户</p>
<p>内存消耗 :16.3 MB, 在所有 C++ 提交中击败了100.00%的用户</p>
]]></content>
      <tags>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>樱之诗感想</title>
    <url>/%E6%A8%B1%E4%B9%8B%E8%AF%97%E6%84%9F%E6%83%B3.html</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">Hey, password is required here.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="bf018d6108f5f5750daabbd8f44033131939d2b1851dd3b76e09bbdb5775dc48">4630436162ade97ba2718b7d0c4b3b63ab954ca66037664d11f05e9c40a3fbe7a0c0924c663e56eea1af4af31d5db1947aeaea6af819cf706a2f3295b4c2a1bdce8f9e6247244ccf9557756d6be2b0efb7d7ff467b2b8f79d4d6d98d3ce741a2cf53bd6bec3df0c5537b4d77b3f027db37d50a9e8978d47067cb25a7cdcde720e99b5bb439acbab300a65bb7880045322ae61ec7d6e4b6172ad1d24fc2b1b8a5b9818917e1f47ea295168d1e53b11b9bce7d68f244e3e38a92647e878834373b3da8d296e1a8f4c32e6fc83863cc856703e3b916344693b5a93046eba840a9e552a5ff86c9b22ff493637478db62aed418943bbfe8ac45efa46df4918b4ff586296d992ae50a0b62a6b3c9f5f38748afe7f29a8884912b69d8f7b33abfb93daa632aa9457500658aa9feed01436cd71ce775d57acf21597025b8990fe8a26910de66ef83e792864572982bcd7dc4c500d4f1ed027fd8f47d3237b323093f7ecb1a5a05168d96ef178f3ad3beeebfc1e018c6d14ae35e5508847737d2b0614db2dab4389998cfc27d35f5d17373521f1f4cfb5cc9d0d543d3b51781dd7fdc41654e4f23c3cf633a5dac8911bae2e88b1d301bdfccad69f5f5c4dddb09aaa94828a17d4a9d909ca68408953722ac7ad412d817156df57065d76afc44f7e4ab8cd932691b963c408a26986febec5c770cecdab51435c40efe011c98288968deec0cfcf5aa69c38dce8adbf06269cb73737c365e40374e2f9c0e5431c950ee4d69ff37b9aeeffba671ac72b055a7e3eb6f11a413da3d4cfc57e9b9e3c9b1aed3d64006b3a21f0c31e1392b341dcd24d12978d5cbdb85c7bd527249e885758d05f3baa87545ed9ef3524bf111163b9ffa8b0a6f217390e05681e86e5b6c1844d7af40becd21f06328bfa5084ef403f3849b19ca28529334a46934c23f55a42bcc9618853f3cf0194254ad4dfbc4d512f535aaeb63f58d527195dd8d02582272121ef3534668e51657f8e973e22219764dab7c0419a2a9740b267b271692bd743d2d039d740276cf23e2e5ba3d2001d215bb94c3c8dc55bf1cc4f7682c34eb5b66c1a6ed76ec2f37b1918f49f6b6108b5f706f915b2ca1c63796ead8e871082d0686a34d1442a7871f398414948a3c7ce11ac1b42bbdc464bcd6e627ce4736bdde8f5ff52ff3bf41c2e27aee4a49408a50a5cc0c0c2a1024f3268eb8d6c8e467398da31555bf372923272c0bd804d83850cb2852dcac2a9fd06f1bd4893905b4256e73675884e848263cf4eb04d41228599ff553234141d0f35c86d7fb32b53e615453d4d13b3aa71364d9ad156b9b177d2d989ba45291699b41d0eee2647557f322849bc164566bbecc8607d928399836d36f013abe751d72ac35bd987d143f27fc2f814521695306bbb55cd6111a5895f2632fa0975a13877d9d9ce4b43368ac7c4943b0cce8dfe16fa5df5b5a363b3511066a9c9d0f95485b292b59bbb433b04eed1ae0087907f49253d4ecf2f9e6bedb0d6f855bb08eda454da6d72730c40f1354cceb8ed34e0dbe3ae85e18b69d5c8276004af9d96213c0789f26dea5ab00c1262582b7c60a3a1da9efc0214574d923d3caf4cf68722fbbebd70d4443b57bc996c8380ecf89a54d13aeba1b9b6159012a63ab8f18525699f96f7edd697ac428b8d215670d21b26e5708448dbb6c09e5128b5927c81efd5b9dec389ac123a895994cf168fbaf95aac900bd7efcd3f719a6dc18b57696ba166d3d43ee4432334443a8b5f18af4f3db98db9d05f57421255ebc9850da2b8edd3bb22969ec646d4e2fa176216e080e47a439d6fae716cdeab7ca7a26791379f7cd1151a16c3aa1b2053bf992f2ee58158ecf46a42e68055f5b0a4893698173db1b2641f7aa512bb68f03fd252b4972c7912cc5e6e4a3d522ccd4738f0ea49addeb4f5b0df07b1f019613942ad2392df715ce3cbd5ce70083175febb37b0a409868395765edc5e871839fdd384114838e6170fc762205104b3a27c131495e9c58ddde9f8a92f1c93878bca3eab07c4dee80117af7d67ea5db2fce5f93b7cb7654d00d357f6b13bf976d9443efd083fbbc0e607729b01547bfe479230ba16de43336bdfeec3b60fba171ae5332077f80c2aaebe6bcd74c9de3db70e8eeda2e83b9e018efe89591401d7edff574212d0833a72a97008e6eaa9144ce7c129df2886a599e03d3d198a52542bb03d0ae82e576d9610a820bd4efdd277d2324c5266e92f8e8965e696d9de51e5e6cda491ea926482c5fb093b4240c407dbf0410ab0cee590a6bc4d7b67ac622d12e2a2de636a5e1ef337d926044b6efba26e26ccad69d8004c95efdf7ebd44fb40ebf0a661d8bb365bc274a2191fe8b789657b1607c4da00e12d4c2035a23efce28e63036ab5c4284aece364b4fa6a094f16195c271508d13c377b71a8e315e5fbb41baa7f935c6aa8934f73065b707c013078f866696fb70b35b96361210008100fe354817f40d36d17af4c88329f7768dcf882279ce979a5b840b2fe96164117e1cb66a5250068361e5fa3b4a8f1bc821694ed08c2c3a64323862c180bdb4b424f5b4f03f3e144a66b9434d98d688693d4e43c4453a64c620e974c8b076c1905d9e541268edb4cc6736cb946183ec237b9281e0299df203d4ae3a6ae749bdc8bea5cfd768a4ceb03f009303f1366335ca6d6ce88e1b6b849ba0156077634634ba46a25981705af221400ebc64d54579238bb1ee0f91df962971657ac4ad6160372318680e8278516f8caeb978e74360d0562527914090d514a80579a03a70ac2ff88d2aaead738fefacda87a32a1136a8093bb3c4e5eba6e641252212c6e44a663db90a0639725fba26f7b1b9ffc76a14053f8973c2cfa05c690c1df776ae72531276ba6006620686e91675b2ce72f08fdf96c844978000fa95ba36d9b0fd8df187daaeccc3874212c7f1d017113b1dae0171484d92111e580b383f650aa4a30a7b911b16bf93976858b8d85cdc9acb6ea0965b91a9bce71ddf21a502ef74a90e4a08aa8415aed4910d6e0b74f651b93a399b3dd6303a26590ced482d5b8b579ad834ca897a479412b02d662e6aaddccf646167da999ed0b583faa0887778793fd0b631e1846c2abddc95b3e38d029e43f8dde9d720b3731cfe189e8894e06760a76ef89bc2c0e1b3c75ebb9138cc2a54434864dafef7c437be0a673e16fd5e46f3168e79be18dd1ea67e83097f6f20d0528b4c20bb8a0553e8d34a7b45a65d2a8b4ac9b992e696bcf38147e73756ddfd2ee3d7fc1615c1e59396cf4ce166d53a39c5c2960c5e0ab9be99a45d8c9704092d2b36b04d60e1a4a878969f518c0cfc6bfffc4cc362a572c4e3b15256cc6762e4a197e833104fd18fec12284ac2ac772a637ba1a404fd3e79af9be9e2a328942bd3ee08aea3311e4288866a2650818b2089e893c32f7795dd7097ab064c580efda8582f12398e7feacd1ee2c2c23f8dbe5783632b4f50743600b7152f08c5804c2ce59bb1913af77089141859be61dee8cc9f303c7e9be013386806c504aaffbb3a500464152d50f8b9f494adff86922a5d34d1d1add20a7c0959f3d569ea4a59fb1a31d4d653801d62449144da2c35d8702daf25703d16a1fa6c5fe1ac47d306ac2c391e5636a7813a5eba83cd6a0969fd89508787eb9123e4dcf16366c4b5f258edd18ceaed082dda9786c37c301003a12065d12db7ff4a79dbd85c0d676da039ea25a238a11c546bff2805c915ccd063afc3e3fa7f35abce19dce9206f1004727990effe20066672d89f5e05dad659e2358596c87228920010df79ab70c809da067904a01ce686163e418c003dfa633bb524979d85e00b6b35d31a7b1ad7d5decde80e5ade76cf4ddb8256215a77b1cf5afb6040d15ac102fa079d7029d0d45f9837d22a3dd49aaf0b97d054edc6d3db7e8ee3ac2168958dec6acf063baeb2d230c48500f30d7efdde2cf38471e361da63790094ad7dbdf942b0e6115912f536e9e9a4e98de45c6d6b0dc1a548f9a1fb4896883efd66bc216f00510a51266758ad438360ab8b52dfcaca591dfb184b58acfb55bed9b52c7fed782fdf8b7f9bdbaa5ae5222c29d86a585ab1d52bdd90485fcc8a1aa5a2219c0a6e07217140053e6acafc32092142e42e1e17149cc608ad780d69ffac2483bae3d28e3cff97a84c7bff9f96aa5519161f8791170a32391e9e0358c71a03b103f08cea681ebb39ebc5f3e26bff2ce297f77db9a12943de13b3cb00d6c47d84cc155a60344f3f2a92606a979cebda829cd3f6ccc90569142e0cec346b0e308f5a3c399d5f1be3436a8afe61a0e1ecd31e6b104c7110623c88388bd78108496c18e3fc354e2a50259173dc1eb120d848c4075823f05b5848c65df1110c6a2d2511f8875d67435ff2abaa3ef38655fc59e761c64d3659eaf1adfd767728c33444f9cfb08e6cc196281e2674ca19a16006b3ce0bbc9fcbb4692195d72f907a195afd018b293b35922a42a54f0210749c6f55d535928c22702f0285f9bc556daa231450c00254eb19102740583c6a418d86e9fa76f9d88120f3343eb17bc48af86c9598f41bf2906b1d0b2e1c1f3e068af8eeb4d815d9c336fbe16e63a2be799c25980d302d14a2a4317174c9a70b8051bbeba2fba6532e0372a0777a25e4188911bdba861c3708c5f57f56c6a84d921618b446e5976a0ec183e113ff7343b21feea7922e780b54480a6fec25a3c3580995124a637d7e5a756fe5fe3c74573211df2133fadb58f86e240c99df216be51020a51514fec05ceebd54823d739f853c47183940a6fa1984a08f534cf7fcccdb204a31b87ec8cfbbbd6cbfd7f02f3bcda63e745ff4de988436dce61f41dec875bcf217b30fb4f5bcf2e7259d5a3fb7fcb29dd287cd2af7c5459463c201bf51b5754da2f284cdd030c7549ae4bbeae14b6f1a445da4ee3105a64eb69d8d41e4ded20738216a379543a737ced95eeee7928655f488c78b9aa0f6d6fd716a7341d8294e17904ded764e5d6c07dba2d11c3c5e2717d3227c8149ff086ba7942951c57be4e01d1d754c3ce431c7cb4a5ca019d898692ef68c7ad1826dbeafe82dda3b7cd2561a11c29f5a68fc7023ee4b276fdaaba6fb3fee4d5e71826a25d5dc3abf7aba2a8ff66befe3dca62ab981a83d820843f0925696cbffa17db411e63528d3b18a5e5975921abb2363700c1e8564e44c92982b2a894f6b2c43d074cad0416097191502aee7dbd913616e0445bb1d9891a607728dbf62ddf334f6926197933c00034d972a7b620a5d4ff8a46175093d75357e00f79d1d212c1942a06d187e6f4d1f433dc9d40287d42b0d122f85645d3dac15bc01e42ccf65e8c3018cc1607f35646a207f5832da804c720041b4f78f9d1b672d1c11892e99399395184022a74cd31006923935e5b4722728987566935d33feac1233ee676f279f017649a73b3965ebcb3a7eb954f06522db7df16013e5605791e5852b0d9cc4be0dc1554b63fd1b864329e791389f5e9022c2a379fd642aa5d0c1f2d4ccf6ca0627e4d23ea51bc11e1c79788d008ade8a32e508163f18f22d9ff885e21d3b5b46e17ba5b30dcc1406912e212b875b45b6f70226c79bc408c966152aaa67cc3e8cede24960299e15324a05f24b1c934d15fcdb55233ec651346f2598f320a5b2980b4dd5fd33a1767252f57fcc739da5e6a9033cf61f4dedd3a07d3ba645fd7c0f55176a3f920420b1eecc98c36cd5976b22a18201fd1c34bd545adbce2e10a78cf9dfeb5ff9190e08da316aa78b1665bdcaceb31fd7d28854e1fe6a13b031ff98a713997653e1464bc8fd1c4c296b3833ea1ec61855c315ec12005cf44a1d368bc99a13753509b01e07900c2f3d77230ad8238f5a838972ce15638154f0f56c0cbfcd3bdb5fc76020ccf3215b773e7b819d9fdd0575814066d5dd93dc3a110608cb063d50fe25ff0e28ffe9d2d37859bda62071f838a32c9609670d65f03fec68a257f22c3a60564101d9e27cb095b35409e6be220df2571d37d47a69ccd94b374984d9f551894f06a20f96b947145f17c350d794290441de5d9b4562c4d3c237c8e87a94dbd9db1ee3ba49be8cecc16613b9630bc3783c08baa08e44a81f347f4e2eb41621cd93e1e817b8da82c7b0e5ab2054ae5cc2cd5dc00a62d8861079ea8ff2fc39302a0a78618d0c77f9c71ac6f0ec9270dea3f5ad08c550ac50ce92cadb1dbbae069a61549a23b480bb5517ad687e7077023bc80a13b64c289ee9ad58febd02432b8fefa7cc6cff5d33ce5612d89a1eb812235a3ba5fbf79bc72c84779ec4b1552c988d429b88b011489af7ba8c2230a706137d44f2001ac3c27d453e5a9a3bd62f8c374f0d2dabc6dfd7d653facaf951d4f1382d89561de79ed9496699351f75aeb52b4f864a0ef1b5899f6210b6097bf016e491e604aae7a1e5322c993031dab4431c0c49f02b763ff84d6257aa136a75c6dae8a29d60063f3a08250c9e743f28fbde5863d513ff91fe8a5f6e09f395363bd0c09c3b4b42ccb1da13a04c1cc5a6794af9121559d88abbb50e122e7d0d4d99ec20bfbae4fa06d07873bae8d56ee2cd26de34271512af69d6132c62558829bd1999722d9f7577be0e074725691b8f326605a8b66f5baec198288ddb3ed87d0572ec5a349737e7623f7e35468d2bbe4fdf3d5e3782ee0855a468d8574352ae103dd20db9b76afb43f44a8979080f21c7021642d8f9e871dcd226c6bcb80336d985a690bc5744fa21e56fb67527d30f55f105229657ee13d446749eafd613ec7fcd3328f6a8d5db1b7e089aef4de970ef0056926496d76dd9530cbb559043cc9716373b29e9bc69bc358135611e6156006756594b9d72426bf043aa85ffe90c3f6d97c050fd0a7e8022ca315ba12ae0bf5956f21dca8866152a4b5d0377d77fa4d4a6fd4d5588cdfec7841f3f15542bc923e9e195b0ca92d41bc9b8af3c530aef109555a27c6938e4d979d5e9049a7e9308556f674f288d1a9f5512877945e98370d586726c96078b788e71a905b3b5bf0a47ea19438deae56b0d255263364ecec22e8b3db8a94f9366d4274771986c9460f4ab5a075626d9f13d18f83cb292d4d305e840f968044ef825082e02273a45e65867614ad1a0063a5c8ca8398274a4cc9b0a1e6ad0b06270d56e717eba2c6b895fa09a2f1185ce378d777bf47628d02c3832ec135c424f002fc6d3828d47084b02e1fff0dccfe274c946792ad442cf13d9c262671d8be3179e9db3d3962937d2a99d9644c96a7af33f6a1508de543f6f8afefc4bc09935b7c29f0b1a973ce450ac04fee78502c9399aa3a197865b132b8addd7f76cb237cfe23081be8c2f69cd4e34526351bb14d11ec31be1172392263c9a89972196e9ee46088a666dcfbb7c41657367a36cf493a5606f17831eb99824a7200379cbeecc85a557d060f245544da4c57f10618b179f84ec856edfadc6d0298fb1d492915e2ad447ea91108d80d0fa14d0b4b007f1208e724fd18eb8eef052d373ad196fd29db1906099b013d62068fb8f294511d0ddf70814f431c9ff3aebbc4f4f2ec58bcbcf1af0d34d00cb28227dc44d6f9ab7a9300800afcb56bc490d0a2c558a41cd1b857dedf0178a085b137bbc018bf1ea4b12740b7d92b987b763e1cbc7ef1225f9a48aa09d97dd43890c241bf3d69af4c2436b08318155850183810e5fa9e14e14b78dbe44fe62c25b4eb8f0d6c7b1c54fbcb31e905e5d98391f8c42a24e8302793661a1679f76df69738779368044ec90877eee7da3b7c475b2e45a5b244bab154ab7be0c525850c208100b15bd276a1be9f185afae21867ee8afafda0fa936dc0f2fa73c3918d43894e0d37891df21a8e62698c08841837753bec1b8e4f6ae38a4aeffd26142ad566e76081cf42c845756ffc9886ccdaf32506b8aed210433203592b89efcf955697c34817543510f13cf7b538568f832f1107efe1d1083db90f2fce86bcf25fb228c9dca9a56fcb683424c600abb126768bff9c970e5a77f2056abecf6508b5f0d1917d7517598c2b6c909a32cff08b6a7c7ff0f0835b942b128e39bc036bb9272b624e89da66be8396f8a158f95bead7340a64f89bcb5799455682d3a356363fa262cc8478b6e4a816ee459c03023df2a970e84cfee9ec5b7dcc51e52e9470d844b241b4556a97fd86166ed6b03e496ac532d1191bddeed9a8f12582a166abb20117853564cabfe4c0afcd13755af37995466972f1ac13921e7117ee1d646497942e8467137b381270adfb111b39befde7987b9371517b7f374fc058b62c086e3b1c8f9b53182c5379ce5704a2b2984a633ddd22cae726b6f1c9a86dc5f6d473fc9fb343e0ab2f39ff0f68d25f6fa257c0c0faab4777511315ddf7cb7d789bbe36531ad59cb74d5cfadcc85b3e0eba7b08d06da2505252292bbccac39082922bfce20a206690e4c68466c62bf5accc398d281490f97b38d5e3ea390b964c8e9f7e3009cf5d591f62b09d61646365f00bbf304f6607632bdc8e834ef436a52b8ed54f94c98aef3b14510ad23b6c15ef94dad19936a3196dbd101c34bab4fad997719f6855bcbefe42ccc59eca711797047529e625bedcbcb44d01a6285ff8809576b1e936684978672a72dbb73ad2cc4ce35582b45a8aa3a4d7c89808016f53c0ecb4727262b60d9062ce530227307c7917d0b9ec8a9a8434ad03a6304a5f2630d26a2792ad1700eee81178841b5f013d0a982b487789c907577dfbc0a16688551f09cc1</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>路人女主感想</title>
    <url>/%E8%B7%AF%E4%BA%BA%E5%A5%B3%E4%B8%BB%E6%84%9F%E6%83%B3.html</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">Hey, password is required here.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="a625e2e4a4bff315d6a3349ba9a23ab261a65bb42c19fdf268642f7b338cdaa2">4630436162ade97ba2718b7d0c4b3b63ab954ca66037664d11f05e9c40a3fbe7a0c0924c663e56eea1af4af31d5db1947aeaea6af819cf706a2f3295b4c2a1bdce8f9e6247244ccf9557756d6be2b0efb7d7ff467b2b8f79d4d6d98d3ce741a2cf53bd6bec3df0c5537b4d77b3f027db3bb5778c8f47af068154277408221eb124e38623f86e78b0fe85540094ae2cb47fee56c78beeb2cdcd067df2e5b83ccf41131cf6fc8152532f0acb9d62b6999bc265f7e987a5e0fd32b0ccb9b406221efca0d33326e8c23ea360400cee987927396714a0a8017ff68a16d2f5827664e5c12b01f2310a41e0dd0106e71677702f2faeaebe379c570f069ef75487b179c8d2eb31e2ae097fcca1e98c3d614008f95e80068488f3644a2956c989de165f3911bfb97fec9e54b66149639ac9e19d0e033a79f2fb8a7ea67b15f3eff1b2a1103fa8d07630b0c93ac979ac1eeabf18154176381e0a603334dfcf547ccd8e17bc6efc84791758a4b8a23cf42f467f78c94f76de891c32f5000a7c74f7f8f0477246c00d60d7d36951e2a081f287e7f313801b0a819832341611bb534f8e58d6bb3074bb1ea5e32687a66ab117ac789c463ac5febe407741cce0ef247594a1e880890f16683527201103154aade21441e65f48d3b85fab101db080721733c84df2356944ded4a49e07a4e52ecab0593c1b1ab7f449a61bbd0c10ad4e634eea95e7d0f9a67c8aa9c8b6349140b65191a0a47051a24c7819e33148cb3ba5023b1da4fe7efbcc02456a98afd6c4b1b10c27a911973dd00b91cc3bcba54ffcba6c1c822826bd54ada7f9cad96a86bf172f0f329219d79c80d957e5b03d70d022d596f5f1303a3cecbedf5a76a1ae1d6ab99eeff5feabd0454fce43bcab894e6ea9d010396cf151ed5d6b631f2b8e03530665c912428c180f1e8b48deb8e71b6b44f8c5aeda1adedc592ba562964c1eee2d01ad08469fc5c86648b2b20d03337d0f240ef23d44de2d49773b56f8160f0bdfb74eef866b9d1efe6c37d79c9c9c35109b7ce4684150e6f7ceef4d8536b05a25e6f73aa9260b824fcd8ca7aca8ce0c19cc900288fdc9d94ad8a097d6faa89994385a9ba4a07761709a232b2e36e3362b21f6d9c2a7ef5f1d78e1bd55c31de9c1c40df7d0296dbb2bc6edea4ecfb12050edd3633f367e0f1d97327a43194ecee84f15f24aa2dda86d512271bb5ded782aeb5253fe0d5d2d1248f90d45f29d23be68000d0f9f0dbdca64f42b50437bf957bd3e81e98cf56e6eebc9e98eb8b004200200f5bd929373300378a8162abc07f47bdd81b3bb05901aa793d1a5f18fa027544cb8b43ac1f8f332361e7b8fe9416b5871d00b7433b1f944026c325bc0f89fd08e3fff07f7395f92fdb94ddbbd39eff7245431ace6df10bcdbf11cb7371ae9b45b392d778c3926c44b13ccdd914760f7fd06241602abb6bfcdf175715589d4bd01aa9724953b7c6d0ad1ac174cc185331b387c6f485a22c071a8f6599e4a02e407109f597acc68d919182a03bca5ecbf127526f7efbb4f8dc99081c4a05e1d25438f20e03e515df0318e556861176f455267017cb4725bf7c2356da57d7780bb6de2de5a213436d782a4665b19d7259d80a9beace5f75300458a863411104aaaf25581a0237868efd5769d3dc631c9f258cd0e3cc0c8e00ed9aef61e2d605f0d199845d21ddf3d8cd52728194a1f2a2bd4a7e114a5dbfe5076d1efb88ea34d5201b52e96ccf84e66bed936e3de899c94293be44552433ee3ae05f1621c224274561811bde79d0ead038c971589c0ec7bb3053f5d908e14e85621502dc9c3121809856076c024d507a7fae8645fd7085de24c0bec6ba55a34bffa614839ae6d3762934754101e3ee0c240038824084fc0db423dbeef20cb67df8dbe5fd255c8770436a8dae57fa2c48dc0ee9a7b81cd7660964be6bfc970fbb38c01b27bc50659d128efc09e3cb2836f6f0ccbd74cdf7485627ef1a468fa4d59370dcc284b84a695cbf7a9ec5646c1646e285dedbf131ae793cac6b8ffdbec76dfe9754ef60052671046b3ff2dedca1eafb0e3142c448950a8c633b514946fc5637401b66620697920e7a5c734145c7caa16d996161244a24934e3dfd104a04d1199eb6863a6d78697e6f42398975ad6c163f53ad35ee932c077bb96d5b5f82e476a9e850bac74b57a421060fabc7f7abc6e9ce83aae7b2aa5e56014e58d1f4ddae8d40c5d7f4fbfc85398c3fa0f76a3f2dcad2a2822fc5dfe6003f738da7c4d7b8adb2040aead8afe834cf6a8a23f865e8bb681ffe77bac6810e2e6ff36e94c90ebda57f751c0aee727f9f9217286bc3f4ccee1ce18e5c1cd70214413a193420641b55f2a0ae4b0a86a1c612aaf6e15a5d84212f721e1c4833665484a854937d359a9bc21e12ea2145b9a0b66a414c0001c3b77533e36344176a0ae5ad404356bc8d9f54902264bbb3f9abea268ac2d73f5dbc6e3d6d0ad55b6e99d14587645de170a00d671c6c55049fbcebb815d0cb4c370c107330080efd07784dc2fb05a982357b8ea0e99103fc5ddad649b28cd806b4f10c3908ee8ec53848e48d6252da7255b97689b95f72bfd0c5befe4098ae21a7e5e93d65e72c7bc72165ad6b7fe9c598c11deb8623bd35766d134f55dfad58cdd864885dcc291f49b348d07fcea0ff9198580bd57a0b78c5a69ee3b9d17bf4e94cc8fdf92ff477f2e2733439b9dce2acd3b0e15a3b399db4cfe02483ed37d90960ac2fa7ebaf4dd61963691b748c047dfb48c843388765e6bace86babc7a9a238547e9338f8e8aef25389242741c1340840dcc43361814f2034d7fbab36306dc787b19c9503e1ed80922608aabb7922b220f2392468590f960abda29a221858c35aca756679ccc349c4e0e5b1e463bc29ffa27cb34bc2e5ca4cec1b25e16a13ff1dc35596f2e33bd38720ed4176a643e0beea2693bbf2fd6cee4510082d222749f3d67234f00a8f570ded4cc2122f25d3a107a3b3523d5384fc277b652c368ea41294626679a6fba1eca798697cdc7201e0f85192e540c5425f3c0f836cdbf93f1d49a556640db1140ece5c3d59470d85dcd4103d04874f9c7484c248595f983c87ce53d88988b7d74f032da1f363bd20e4eda9b9fadd12309880b92c971d326a37cd5a5d845f7507abd38981e053a34124b15a232a2251ab7a0f953da99a4ef09a1660042f0bd41230c1a3eee69b97fd1878480c70f9899c9bfe3fdcf08f8a51d7982a3f28e429be50bc2e65207596b862c0ac01130e99699eb15215142844f5a054d425e16f44ebe618486466be96b7d13e92b1e50dadd7c8c0d5807b7a965724bf59a3622a43f8a16a4be9d25932ab820875bf505ccc2f5cc38b9a6a447d99d36581a9a577de126ef131392d9ad3189303c80e5b16fd9f5824c95a90a0bb000d2875dddbfda78d398eabd74ad565cf95ec921f347e16eb3ef4f34ac191b9bb39b54fad295a962f4a99b23fd3c8ed57ac3f3f519be3985e5fb11b38c5659805cb93ffec5f2371429145caf03148e31d55c72254126c0aa916fb3bc4be632f25ab55faa664bc2b5aa6913dd3920f3f9c989c9861bfc0f2e08f74a5aa48737e8dadaa6f0b341a0d920b424e62ce47d22f3cdcf365facde0c2dd75d4c2d1c7aa46805e484a140fc9ae6b69b5c3c0e4c1ff867587d50d02f88dc6698396747075432840653c6211114d201ddffea5fd3f1151099f8b12a9643c182254633ebdb53829e9b28b3dd2efbf2f2b2725ad67568578524b67af8c62c85372854caf45b94a8955598503b18cd3cf39f2d151d00a1b3c1364369847436fd23cf52f237559f4689221e6fb4940233b86783fdeaa46606e60b144b375c5cac66f95d5d1dc27c7c27729d3d8b2683d69a5c8d9f51f99fad3d6eaa485d1b2fc640207819f3539180041375e15d57ac1332b837359af73c4b1bd65da1fe50c8b6107ca939a1447fd33633105762f9c4b8d976044142671affaacfb330ee6ab3a112a678aac724d2c0f6cb40fd235833200e9cf98f335e0ea904ea9538ec22899d0838bee68947f667ff077deee602b4100129f7dd337279c9488c9b06a5e01498c068cc13ffd1de70f2ea98b48359275db1b6139a8ec5b7b34c8586acf3ef2d1c508943fc00eccf0e5a967a7d223ac9925457722b44bf43d1a398b846e83b8871e87836828dddf63ae783f45c976179053462fbb552d6e964a923b7bc6c58fb761327c00cc0c6be12a4c4ab6d4cee7bc813569211b56d0e335875b9abafebfdad8ec05122a2d2f944f78de0ab35ec2135d4a54f7e6f22d15990f9dd294ba2b4d4968d84e44aafd30059a978cf57e9d783792ff4269a341a9d7bc28bf9d84101099509cc752525ca080984156f374be62aea42f7de415200bc71b97925be6347427a04fcfe1ed09488644bd6b22f152b430cb2a0da1b345b4ce1ad71d4cddd0a17ac891ecdccd58479761212fd25ec4adfe32fb30a319d307a3d71193c119e1262a22758a8192ddc9c0b5eea667a9b020c34c8600cb142eeff7e5c4f0d30e6d73c288168e7a122806e0fd54a3742d42bafb9f0a12377c8805f513ce8d6aef431f4e74000b8b529a46b8324d2abadb63f0fba594db43f585d533cea2684bbdd623fa5cb8ab6de9a6a5f2b0a8cc4ccc88a65f3fe6dca90a9263b834763ca7e8b878c09e9a98f378afeaa6ad1edea11fbb638456e691c2ba4c6716e7e23f7999667d28d032d1e83edd7e53d865a322ab60335f1a6a750b9c684b826fbeb2931653d35025c863caf15f908e54fe890de2daeb9b856b8c6875dfb5b4ee63a685b2704ef159f28b18c472867189320f0cc3186146bd1d774ed11ed3894d120e5053d06cfe9318576733bb5d59dd54c93f2be49a7dbac37b0aa5f1849ebd4e7953eb944359d9d2f65a74d773e4cad9620d876b2ba23255ec142de4e38ae580e5bc2f3ff19153392f7a462e3c36855ed62a8f27ffaecc434e119706b198ed6889725140abea846f81135a3339651d0ceac2c5dbf94c3bb7ddf1ce11a40b86a61449426f4998eaec7a95f5f6f970703a7a1d914c9be817862a272924b4256e8e911dc2ec744251f4a44bfab836c363c2bae76b76d642b86008e9f86dbe548885605ccd82ee3aa20d304daa5b0a25da507483db4c3b2eb51cca6a6b93b7ebe0b3953411942c41fd3733e4845356c5016e35ac96d77992ed9eea9bf975201d7483a3a2925191dee124c60ac65a57e9555163acbf5ecd94946bf18dd7b9137a732598badfed2afe108f9abfce3f7ef964fc382158f61590ff0bf67704f09fbf0ecadf516071afc0ec6b485b50b56d54845c35047325835377efb95fbc05a6b2c9773590468bd9abab3ccc1a68a284196f73daafb12944ef41fb2d9951d0f138afc1a07123bab3afa85873cc80c79ef0d841c74400dc67c66d2f6335b439f13a1cd40cb2ff01ea0e96b4b38667ca638c621dd01a5d48cc6d5830721ae24b66b6857d0bc600232a1e0962051be9f1e6e9570b6d190173785a29e452f32418aa590599d437bb9ba9008fbd6023a89e1a282b5bee5ee4b812d8097cd9be63e737355e767660a7af7b9484aba4051e0d33f72d0bc72a286facd1d32070e9df0b158e0522e964f03eef7029b86f315da4b872fdd6d2f71be8bee6e68072bffec0a21c1249d6a12ecc72431391a7832eba80618c54d0f6a23731098d975317f22d654b2840c0be164e96337dadb1a6b8a4686b8cc8d06da68db4a370623241ba28a57c1de1d03891a484e9e873f4de7c03519a1cc791c3b93c9ad425ea9129a9fed9011dec9110d0aebf907a83e23aff98658c23d4afd028f873726b85c276792266958c1ceffb3348d087fefef3ee78f336f94a99ed6a91056658f2020339cd8eeba032700c8e00589e1bc2a2a66fab6e9d67266b44b2e14ad300317121d04d107a26abb43829375152093b307e63fd52fd314ab8d5abe748a0455fadf3e55a4b1fe61ff9b7ba483dd97d0d46d6e0752512c32bde01b54656db4ac19c1b4456e579f4634cdc64dc8c32a43291705b1da9b7d097ba45a3923f79cf42a472e51f2c3a7b9069852cf5b974a8ec9b0c1aa1baef110cf49cf6ac7121f5844a0a2a82dbc4a8941e6a5fd929f4d11b2c46ae5be3b6eebf5dae193135970ea4ab1fe0ae5b1005f348de1c05094a7dab91db3077efa0ada359d2b97f74cd089ececf071359d3ed59a1a0ae9bf764a6afc52c4951ef30d18a48ca1555212cb24b598d78cd7eb5ef072c29d1770a69fbb08b053e4fc19d8469f2dff05beae92d9ca4cd003889ad33a69646a33acfd0a2bb2241925392c93b547ed6e6865d173e81eb0aec86403c6693729d3ddb579962a8520a000bf0ae1f7525ee66822f05dccb83f5d77dd34d229e8424c3dcc22d9841ea0f2268bd8896ab79a20d7272d12eb85c68e58511d2bcf730cc41ff4399c8a0f29c5a800aacdedcf13bccca25dc09653ec611cfef775e8e15ccc77c1e733c6a9266df1caf0ba7f0a0d7d648f2b8da15d56bdf6b432ed4fcdf9beed4238842009c0724abc8b1a607591ef02cdce5e1f98d52bc3465733e241f17dabe96634300f9af97d2de03ec9fba207c7f4e6e06e3ddbb8e18f0169b3519dd33034232a300f21d0dd1feca6a08a62987e15e1024b9d45953e88056f61cedf7515be48d9756d8d4e097ca73d43271f583ee81c150404c939748acd74cc6de67b28f8c2dca63de35d8a560e9a7919e3529c7c206aad5acd670f4dcdcfb7d0b70e64e41972d0d66b53e8b150f41d64b836f655a3e54c1f3f0f2f502adef0472a558cdc9fd3a57bb2851c3ff510e43abb432d5f3b10ae8d65c4b0794e32a7e9400856d095c8df81115dc19540c1ae96a81546745f3399ff9dc634f9b27d0c36aeadbe8c546e862427ac49c6c80e6a1d777f3ed9aa517e160df2bc74c3303010e33e9d98ff283d0172a7a6893a80065407f7322ff5716803553c46bd5eea469b32a21ba3cb72ca9f2460f0942b708e1aed10eb4069b2516c862aa2b59e50d2ff4128d66cd3e9fc4d634c2719f13980203a3121140966c036fea7838fabef4c49fbf83aa76ccbcd1c20f0521eb2d5a7b02427bd5b48623fd49d186706a49dc7687cac8813670f80fed6225bda2966c63144a339c729cea030cfabffd5620357398103938f0ac5c6cdebe7076abd4ce281b444c3bdb252e72b174dbaca78b50a92c0bede55517bbcf1e00382a91d8e349d1236d945c420d8c0910b2c38eeb9b5b7ecf1681ae299cc44b9036e2ebdc19819f4bd71e7169f3f406547b53bef7cf6c7361f7a551d1e63cf558c12c5d206a71f53ef624c4acf356282c96b11b57addc6f22a5508e492c751a3ee3cc9b36a35689cb3fd9d41e7b0bcd85f9fc19a9b5f2a065cb43558f2c460e742e50915c4f4757493d02511b54c7254c762958b7fb0ecf8fe580c413882ca7ba6cab8afdaae789415a2e6c3d0946ebee17c3a30b92ab212f3a8a5a43b1a521d39c8810ebbc2a0a1e44750c511390384335906f7cb66951057dddbe3a8d6f1f3270fe6624184d65c3409838c6ddb9d4f0e5f2b3cee1ee6740a5f3f61c9d1ae95c333c3e511e3cea35308d5ba94b2d779492bbdb41f8a10e70e7fb85fb6f23e3e88de0af081e94ac8dcd8da287bf594145aa8a4427fe8f3a35d04f0af3b05645dc02e9486760f6c919b000893fc3a82b6393025ddc318a423932985ce8ca4346f3c2ba728da4a233dc5b503a9a1e115000ebfcd4e7fbc642aca3bdaef2f33ebeac8d0ad7d43b6fd34f8fa6f408d2046390ffb29bbcfe29fe5f04da8ca621a9cda6a2cc840400fa0b7b87c52bc7f3dc887e3f7ae4d7d1078b8a51298a27b8d79b0596b552c79ba63c123648d88095b10cfe5744335236f96edba06e65458b0c0f18781a703e43ce8df64e3b3265bbf5199dd4b3ec92e7478df7ef471c2b95c48e7e541d9e615cd1f9437eb96e808c412a506403b7f3e258452656a6565f54cc53a4c118128e18700de349737b79281c853276c132cab8307c29b0b7684309811b81d1cdd62e441cc248121afe6c796983bb51fbba92bda88308d519169c25ec8575c1d2754a54de4ff64c44465401adddadde2c48ef305940a61cc1b6fa039be179540de3a49b4fd3a34c86e2bdc79170cc0eeccf46267663e8da3d9cd748856c2772367b22805f1d50abff0d15bed4a258cb4ddf24b833f32b6b0459f7de08765b3394cd5284f8efc4639b30c5ee5829066dd4ef9fba515ed8ffc8c2263ea9a8cc9fa5a1d2c26707cf5901d380f48a23cbccc2c4856d19c85f50d061f1dcbe5b0327cc8f2e4602bb5bc30529f05a9990282b6a691f4be36a029f5d335170f6da95c218fd09617353ab6280062f63c6e86467d3009d3aaf40110cb263b4d88fac098401812b94dc009f6dc3469823b24002ded28bbfc41c0905554ed6aa434f20f26ff90f27aeccf8e0ea01513ddc1a03500d58b76e1bd35a4c0f2ed2a4c96cbb385065bb8108b33855a38ba9ee1de2a2d5dcee47a541cf3235753ce544bb5aa8a9c95c26f2e863fb0fe544f26003793c69defcb6687a92f23e7441cc23aa359327906b830eb43f9f52cf4ecffb2e6305709cdab929ccb2ef49220a50ba052d413cc30ee3932d396aac466361746817dcbcad49f13da42dacc7b9b78d151db14245778d500bc4918585e86772936549648d86d8f48878f009f50f11d08463b526cccd55b9c41d6f4aa6f6b86d49d3bf514671dbb42f51af899ede586a56b4657c19718b3fc63cedae7b611b70eb1d84e2df3ed8f45066d78cf47792a3168ff1de0e546245323a8fcfb6290c04cb4932f70390b3433e2c8496ee287537ea312752469a14dbe198d1f1406cb5f7ed7baf2df3868f8ccea72c84b6749dfcb6bdd92244a4dbae710ce7c033982fe4498129187c4d6bcee49c7b5ec59a2571901bb5487a527470f9c9fa34ced2379cd21177f6986f1e1f6eb2b4502bbadbbc5dbacb6807b8a2fa26488ed13d4b8e3f173a44199b47100fc2257e8d789dffbf1281afb97a6c281e089fd10afa054c26b73450c5c6f29c2caa6302bb4fce0c600d41225d04ad9046aaf0f04eaa6757b904b311de88a34539ac30499e4e28d11fbcfd197746d3aef13d6273a77db34f6822ba1ce0890cb8c9907fb6eb5ee7d7ff6640f32a9c0b396adacc2740d0720e0abfd96f1bf8b2a698bc24575133ef0f87ef9a86f1d0d979a9d5fc6b018c80e492135e22068041a19bec8d14ced85e4eb39755070ca631a77889f775aa4269a4aeff4f50314d6cfc544c5fb08f1569b00af4b177665362738e4bdcfd3590c5</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>euphoria感想</title>
    <url>/euphoria%E6%84%9F%E6%83%B3.html</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">Hey, password is required here.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="2e1dd48c431e6fd2981dffeb95e00b37505f88c336b90c64446dc66e34d35c7e">4630436162ade97ba2718b7d0c4b3b63ade7dbb51df32b85ecb15344de6ba4bf5fcc1649ea060c3569061ad7d301c9155273a79b9e02a741188f5dad2581e53ba86085ff1f82ffda42ba27e179bc83f9a7ea0f4e28eb1e9d9f293c2948b1638cd60719458353b93bb941896c3f71d1ab5e76596a79ccc1b02776decef06bd734476375119f3e61963e4a3248c3a8c5cff054c13086dc15eed945eef3188bdfe789eb6a25fab849c05d8442089f88a98bd2eb80983327fd601f816d0eabd64c8378adf3d1ab06d131743d42b196be1438302d0d8d6fcfb6a35b427c7dcad51c6b2ec882ca51153a85462ec726de74c42081247ec6fffbd1b9ef7ef02f80d5d65d6e39eb5188f8554a4eb13ee667a465171ab34164b8fc79ba3e57d7e67a5939f363a35909ede40eb630a947986fe6ec6764d140747f7afc4e2cd784bebb8d27e4091f4a15ef3445769e58457aff3f8b923bd19f7bb9738adab78b20b35e7ab5195540e5f57365a144d8437f097c1f1b66d918748a690e01437310d11cc7e6cf343616b9a5586f5879518a225491dce7555e12acb054e8015093df11cb4f344644efb5d3d9435903a5d4fc27f8f435250c579bc496042579cf52206e97af72aa00892cda003d89c3109199fc74279fe114dc397b1784415c94dd3c4ef67cdee68943b95eee5290fb56a00ec128fe928532e961d7b39ffa0234e9aa7f110c2f39110629e4bbffb3184cd6eaf71c195fbf708d69f7528ced871e14322113d6c4c7f04592b46d8f3b1d964a3ed16c7c384280986dcd45ca5cded5841033761978d7db079e1af4bb83ad87decdeafaa2f30958224da317119923bf1f37405a6c99766d45b0466bdbd011d72a398dd15f4dfeaf55a2cf8822ac314e5662ee1b757e23d62f966e5a202c8cffe3745bfe382cd48a29251fd341aa6246b22936262efc96b968e2eeb2ef68dd561d079ea6c9d302ba1357f7b6f7a437b03f189b391cadde0c394a898696829a81355f85b2a6cfebee94012e28a3082c844559176468ffccf92aa26df5fa2947c544b3084196c68575b9742602216a285a197aa3a413a8b4a971e232df2a6eea9a877428630f3bebdb96519231fdb5d80d6ee383b706b820cc4fc05555d7f8464fd2c2f88320c6ff6d42f00c9202b240c5ba84ba94aa09d263049d85f86127446b20919c750a2273153f0bf5c347d58cf3c34e3c6b0e478cb205be9ac786a659f6aab7db010b3c0cfa4945370befd52553f2029cd03c24aa17ce14501ef0547292252fb10cbf0c3d7b39cd0e2fcf12ffe04772a99c3141212d38c61d91f230ab8692ab2faaa9601ce2ce79e300dd20650adbd24c627c70f4ad80609630d47fded77dd143216b6c3b332b492cbe769220c491f0c71d5a33449eb76789f3ab050c9440f35d242d017d6ff9eafe1cfd99fc0c85d81fe8f7a7c930ffd2df2dcbcbef0e936b9fe615b09b08e940bf937d60bffb1285750da3d812a22d24d3f98ba4ad52878bf760b0515398c23bae5419f28486b124022d0015b5b43fd6e60da914f2492e6944efbab3ffca3bced1ecde60f129885bfc8991a2776c8bf7b7b50c737dab42bd0904a0d5cfa77d18a19da9ed69c5099fb325eea001b15aaf5bd2e838d5fde23dd4fd54eb501caa8179e65f0bc15cc88bd67999eb7549900dcf21dc2304d221d0ad036075a77cae259a18a829acb2130053d7604bdff75736f789b84766109e3161befb3ac728de549f22f982b809bdc26636ff25122047dd8233d8f5d9a8c02d593e5507e96d4946425293d17fd979a68d6b072f776e10020a42e32827788b090916e08c4324a7e27a4b488a73c74b80c1bdc7f5da56ce1e4836cd90cb47fb86da38bfc7988dd329cd057847a8a936a55b00835d2f3f7a0a02b6d4ad5920ee44bccf181869bff2723b2e3e0b65b68fdfc6605b8911ec6be00fc2f967736dfbb821364e0e059625749eca931e87d898a31a91d13e06e55a14857533a5a9c48e17eb80cac4430d80054cac7d988ea6d31cd00fc374f5fd6aaf2fa2f708ec46380f0cd769bc4265755868e424c21df1b40d4d22a14509837423e0db0a261a7b0eca7fa44f1b8c722bbb921d48a28c40cff900c7dbfb6fad66cdd34cc76e613b40a131b629bb5a6bbce67ed55ce68300d9b8079290afd945d23f676b9dee8ff60f0cf22671c4c670731668b109a148f5d86aed60ef9bb38717a1de0d9824310543cd414c905cf35e8af26d3d591c7439c6817308cd7186c68b0b938dd28eea9ef77d59b38afbde783eb4129432506bece7094fa2f709e29a90bec38e0b69ae16eec90d5707426abcc8fb15b6219a4000a3cadc8c0c54010609334184a3b33b0416f5cd1f3d55ddd135036e432339bfab22645add04907e1967eae7f703fe463ddc8c92b9af2c4350dd8bed8c1f5cf86e4725d010f9c2ae3b4830c0c4239312a8b335b03aa3e50d616ce144a64c406ffddc6d94316d9b8079ec7589fb94ba8246d496b5ca0ea590442136d9d803f284e139e8e6297994991322072fd0d5322b3e2f1f360beb2697a24424ac5ad5c6ec4164a637510339f54df2393688bbe9b27aa0f2414c68d1c36ad75b0fbbb4f4532a1d8791e1a2756f8e9a9f7ca61d1b5794bd721b63772b8e0f04b879a786e5cba1b6fba7944c2b59b066e4c58d940f2db390e877c3b17cc80a77847cd47514682105291a069d4c505f4774b16c862b76ccd1d0d6506f83f5756b3caf41c1fb345e0d5182074d8eecb0636ef81af33e3c76e772edaf902be94700492b338ad1f9633f1a44211143b7c78083f41b6772848f02089302023095045fe176c6f3a8caee41ce1acaf7a41665bf20f2eaf8ace3c79dc57cb862b4479bc59ce48b805b6c9deb26f7b486a6809c0e1c77c8b2c7dcee494f2bcadb3871382b1b7a23f1e36dd5b5e0d2652eea62643e6eb4dde4f451ed582dd1b657c3a5369a9f8b717b2d1640f8aa4a60c1ab3c1326f0a8e7db8315516621e18eb4db517d0e7e9711dcf4840ff17f9c64874861cbfe981e881446d5d6a247cbddc3cdab5002823a208ea668f8a1a58e11ff3e77a0a1d0cf92ceea611571ab40e2e05f8a116366597a04d749b0476f5c55d7a57f7f386f85d2b86058fb4bd6e8646f28f84a6e6f1e8f0ec724d1e3e15c8e7629849ed4af131373ea9e5c16e14d860dd2b522123acc942d3eba5d1749f0b446459292742eb0788dc6f008736104b8d1c97bdced4eb0b00a8520e4f26a0560347532fb1707d4f5f7f3af6146e7a20cd1603f1ae3c9bea1b283edd52252b36c08914582a658a23ca097bf6496aa12b8a69007f3c737fa260d2e9f5999b85ed1be7525cae44cc7e37d65a32183804afc166474c18671bf051b5083cfc8aa4f9067d1e562359f27d619076423f20ba9c8b09f153009fe49b7601416ec570c98e27106befa276cc8dea1c02467cd1d71b71970f56a9936b1c89db2c60ecc305fe9b4a9d11a458a9abb35b42f6c84b4d8c31bfcbc7ec0a2e4a7dd64d977cc6d2561fab631b244ab9e821cdb1a8689a4090a25b0ee9e49e183ac1617c5ffffed5d3b8e3dfde403859390677ec957617b2f02598b7632f631bb0dc9a77c0e5fb63438e67fd4cf55d0f6201fa821b0f81bc1e2385dc0ca6f0bb0b17a2e1ec0a35a20bd61de42f4d88ae337d6f957d393f28e52e4b9a024cb915297971f6bd527b104bfe8b873198493fa86e23255dd973443c8121121c437cd10f5d4dfb5741bc6b4cdc549c6d6d2a24fd06bc45e9e06abfe878569489008d9bc8e1b2f059e07cfa15ecf7f7a712f4aaf977b0c7b4537e4f1102b579a54e1790a2514c5e417a79e59e9b496cce1fcbc2513e67d27ce3f7f9d41a587b3cc7db2fd3617d20b46abec489218eddb2efb3fcc229be42f7e5a0c80a39bffdcca6aa7ca56273381f2ce75f53f6563d65e4a3babaec69d24992891738f3e0160711e46fafc457610c42009511257cad8b2dddf157b446a48835e6103817866757bcf8af4aba5d4168253fb614cd57b41e837b8f21b53d8c9b281e8450b3955d3da9ed2f2ef4ef91244531cee8080fac3c24b0682b6d037a2f025ffacdb18c89b458b04a66f22ddc93c0e3523c2c7ecc4bc30d5cb36caf4ceab78031753af818db1493b21c73ede98c9a8cb780a01d9d079f7018dc48622f42ce28a3ce4881bc79f20a77dfb5f0040cdf6d9fcbd0c5682c2192d638b3cf0b953c84631a4e13be5057fcf9a8145e95544783a43bc66ba76e7712bb08d5d41fe76bf089b6a6f40ad91cc68f82578db4409cfc3065c34837638f359e382cd0f9f58afc3b41524ce92d3473099ee8680a49e828756d71ee2f66d45753a29fa9d46f10e9df7582cfe8e00f2faa7847139678cc6045039b6428a9b21578be2ee4fea07b9977d0af6e303f96a7e87ad83effa71683a5ba500f85acbf0f01002c9281f9d83d4f09c93ece11600f0fbe7798d84a3205450c8856a199696ab5874058b09c041cc615dcbd2a7bd52e59a637de5d798d4c6232267dbd616d7e4b648fc793bb9ba14bc67bcd77126250351d39cc529b7055e88bf1d166f57266c1f3d317649cab45821b1bb09e48678b20fa05444ef8dd83e109bb252da49371a4524cb8629ac464d28d3457aa737839c5d84152ff08dfdf14fc3011b780e452801ca3272629d3f4caacf0ee51e01082747a196d817338ff0a2bad652b1e45ccba1beb0eb4554a8a67f07a045795c5da3be28bfd780f228af42bb9d17e9521e1ba4c7591f52ea8c778c2d05f83973b602d9f01e70ff20476651a2e7e3f4be581948aa567d5bbb9b6d45fe6e400d97fc82616d377d5a30cbc1ae84d113978b2816b6b4116a3e307cc96b6bce9b8e75b7124432170554c98f0af449723b6b2b2ecc70de623e0733f297f694a9965cb1f63dadc1189ab745b3d1771b07520f8730ead304c9406bcf3031f04a65314a389b02e47ba8b3fb2d101a981b073c59091dc9e5144dd6621a0de34b3eb4f8651102397352df147cd2aed7b500a7035db95f0862c0a1b43ef955ed298f1ec2fc36a8f3fa78a38e80722b670b8a05a411c227dcb85bdf62caf9deab4d7a4daab6de71a503899a38f0d383ff73231fac5408679b17689c93c499dd9f4346600ff15d5495c0cb3ec64956b82bb1ebff47e57fc10c31c289ed1dd9641d4cf4875f403bd16992172301afc98394f4c39418087f42556e11e5a27c115f6ca240bdb5d3c6dc02898f8ad4be89ddc084b7be4a71de4cdefee242a684d7514958092309f05d53e452e2ea65b4ac5a00696c5bf88997f9ff0eea089842993346fdf0a217251185c42c6630d623de5cc191d9b052a42f9b3a6401a385ad607400a129b51303cf2d055eafce8a3981a6ba57a54fe5feb3e7ac4695386e7afeef04a1a4427a4abd7ccf350688cb6049ba25440acddec2a38d85b5b2b83a54b83dcbb2c2d76965704b474e2e126daec844bcf764d78c9c0a75662c4a55cc44724d25b7f48abe8e0e4e426912d3c3479b7f9413b23a69765efba5892bba0bf30eec0ee80c6035cb3783202d23be944d66fb656adcf01bc54395caf3b1a12b55b61a925f7f61b06c0efa2d36a6d5b4fad635fd836322a7b2c97731d035859ea29610aa8e00b6bdffcbe4feec864e5da743e735e7b74581cc2425e236894dc13c1ea3032db9b92b4df1fa52c2c264f7f0174c2f3dc1947a417fd68fe4da75de36c78f81147dfd474a69f28caa88c05eaf29b87a6c2f8957a13f8ba26bf8641ffdc4034d9d92884c092ff2b537868bed60dfa646e104607488aeb76471ce0597e6156010c065a711fdb2451a12cbc4b427b4e55cc795a7996d4bc943339756291b63768a8e358f0755efcd1dbda6b5e79fa80703765a134f913d5ab0a205b771e13523f64edc0c3bf90b4e802099b7a755ab189a54931fc908fdcc8028a442b422422cfa223d33788aaef081e0909261abe6ebd45042dc3db5767b7a233dc67c159c6eeacd0966b06d607350b4712aa7b6169f6ddb905eb85a0307ebb90358b037a9ebe484a4701f5ab24775420dbaa7df176fb905283030f17bc5434e67c26e45e7b952d290509001acf7c9fe21102ecdd98e242edbbe8ba6fe3dd7900b7580f43c179f7c8437ab9c0534d57262dd870e4ce1617124d90aeec54bd908a053461adae04bb0653085bad3a884d980298e5887cbd065b08718cbc144b319d0b8ffccfdb7c79a66eb7fd5b340002d568aca95b62b99d9f2664724075965039a7a9a4549abf2a842bbb214cb48776ae2367671b15c89bf529823ae1892f02bd9ea2be34a8da32502259a841740e2577c099c8b1de12b4bdc9f29a5d24507e3b68555c8699ad3b9dbf8a3d6fd8c8c944de1be1ce7c574da28aba2ffc694b4f9026dccd90e88299d932fb2029686f83d678b925063b273078fe0566b1353868b38f456fe223b968440e87e0853e3ce5817117c3299e33ea1b53be3ad51bd137719db3218017e3246f7bd520bcc0768563a92226e8258a6a16cce72c77b8ce50513bfbfd3a7e20dfaa02e7993a21aaceaf62f995d8713585457aee744e9f1fe154fa705cd7a5f77cc8ab2a337d756634cdcfbae335f48363c666e06dae4f62ef0016cc18b6755414264525db91bd209ee599abada053feb23dafbc17b24bfe31ca8b08a101b968998598cfedcca28cdcf105054fe72675dd6a5a35f678db4e14dba88e1250ee829b2c4462a1877eb955256181e214efefb88138a5f189b7ad97a1ed9d3bd08fdd3968a446556c2dc8adcdb5cc16d040ba18087d36cfce7cbc11b3baf790cef50532471d1190a04de0c552d72ab37adc466bf596c2e30330dfc77a86a2745e5e76f544d90f5c081a48f71107d60f6ef71d76cf7fa04499a99f5b63ed215eec85c4c53555d66c74ed27aa089b9a7137d1c72e22909940025958ae349366dc7d7a5916da8e7690a248b28d6117f32258a4d963d0812781299ae8a8a395a1938d0bc72ab5221ffc3e94d114e8b730bfaedf098a6051e46deec4cfdef122e08fe51be0e096877c9bf32fb5e6cf894fb3a7cfe0e624d2d73077385160e4ff1f80aa9bbbf7da06e03b8b1f389073c22cb375c19531a489aeed26bc863427ed07fc816837d08e699f431004d1e3d6fd6f7113a86f26065630de60e2b8148c72da529ea3c7d511057b68d25d9473c268edc32c958720cddb9eadce57453797e8444d03bf6c51f92d62dd0385769a268e88b3e698f872bf32d94f7a0950a7f5a4bf2461b3dd3f3049f5014c1560d76c95d9fb84b68f4f08e19eb60fcffcb0eb312aff0138f81b901f76d1327836b628b32039cfa1d20025396e5329d9fb87387d82752b077d507849a4f5838be671ba8c1f450ee13e1375818b576ae1429596f138b6fcb4e318e4a535f94e4eac96aac76c0efff2d93f2312b24e0ea4a1778f7cfafe56fdef165e3905fde631506900fe59c9b3dfd5eb990cfcb724c5881349b8417f747a9528e902609bdb1e8d65b6a2880954782d7ff3e72b790b1dd6cff556df281168958e1587c7154c6fca77f91a74cdf70d876c9551f023d9bc1a9eede93dd22893b5d07ed7d510f4ee4ebbb61433b5c4e7740b08804bdd21c110509b4e9542251c550a85b21bbb0d2cf5c2d5cccebad9bf5583408138edac4f5898c2e1e9bc2780b43fa323c201edf68830fd24da95a3527643291853b6f73044c20b58e398bf39f8e8757643e9f47ab025db069919cf6106d777972388fb42d43bad6f71a0d5188db145f1ff9c5deb0929b0fcb5558e9352fea41606e9fed619cece9753de64fbdc581948809b2be8238351e6f39669f6943135604743b24918e1378acf5825f80d9a81899f0919ce3c4d01ff2fa259f3b8fb49afa13f7a7f919d37d8eda9a12a59fd36245a5c6f6aecd41713e8265b48f7834468e98aefabc3fe9ed4835ccd93aea2e9cf6dda894b055299b65e1c8069e3755cc55527ccf683d5b058896c66f9d19480c9c61eb8bbbe8df98d788e9c497a93a5cdb7bcded23f799abab039d2b07b9b5d61b3e9a622383ac7cbf0d6cd197e3fc6d93cbbe47cb0ea9a56fac27797fc0c39c75bc48e6ce28321c4bcba51b845c0cc9955ec33289ed4e3ad28c80705aec27c8908b9239e0c6e86f986d984b5069a6599d108cb67752098d85e4dcfac604794d9cb1f56da557843c86c10a7d545a0a01eb6bf3a4a725053a1b8897938f3bb86570d2230164669962266caed9b41dfc9f69ac37c543019ebd7888efb9f7a332c8a71e993bb5e228fb4a50265c06715ed1152e802c2e01d8f2e5b72acb956ca06abe1d92f637b4d42e9cecf0d69fd0ce7811884a2247e96c782a2461d52967da8d67371457cf7f0f8e315d397617fe2d50c8173b4b5a70fe0d414966e3a6c0d44b0793a8f76e8aac680fbeafe5ff2c16fee38812d8651efbdf2380b296311752efd345eb9d936c21df91951bcb9d9efe0507a88c96d654fa02785ab3e4e7a36feb964e4fba908543502d5933ccbe95cc843cedfb23201405ebe93077eb66cc6352853237c3620e4683a276207629ac0ad245c3ac0d334303804cd86126a6b43aa09f60272d7712e8ecee56b03db80fd9ef0bdc97d40e006878f4860a0edd4f4167e18d800594680908ab8f72a2fcb3628e31aacf458008fb86490b431e957ae4f0dfd3aeb0d03a7dbbd7aea6e4ccfaec8bbeb26ba5770b67c633851c3c61417f0df702e8a57ecfb75635487ea5fd2552454642cc6913b7a50c0439eed793d844dca8e7cb2149a193af46e74587274880c5f7a95167cbd1d3272eee286910cfed8bdd015f0e6daee2e71a254fc551f6bdd2021c066c19b1d77fa67eb19b1c2a9c24941d69668b7f4302f8680e6542f6a1020b9aec516de982c7e11b81daa1a60e3f7a1b3325a74f96777923a55fe62a13da033e192d119f87137b6c64742f5259a99b1cf61d1c0b612cdd0d023333187c0b0806888b7f1f98fc6b2594516706941becf31517d8b229a8851581b1bd476abb9b37cf2faa28bb3a7e85402c09eb7de0079ded5e57c2bea3d910529d9cd842846e35d96dd96c41e27a0eb303ae5b6bb7cd9ae62e002bd2df514356ade9fb7d3635df8d1a26c12677febea12b81b09a55f468bc8290e9d39b4c0eae50eacaeb80affc48f83fcde84e7aecaf70834800dcaf9600be8165c3c5a7ddec0218b8c9bea1bd337069766766fe85f60ce121e1917a545fcf163e6238eaac507255b0b1f603e2af67f7efa3b992d659056624f32b6560e6fbf83014450d11a7f21973c90b4193c5ba663a18380a62e42d78199ada2ea6fbb82b9c59879278beeaa2b0287f9dd224d852873a7a4ee1a26beb2e6257cab0b862991d2c5ef4cb195d6d17b622266229cf5789cd15c72327db324ad2503a4b2709f50566b267c5d3de7a34966dbf97f7bca072d2a8467051018e6b1c61b5ef8ad20d655c8ace15f421252dfcf389008f82e4ef5d7c9382b0ba0cc14ca11e612e86d56ff5c5287052526acf5de61cb7e2c3edea41e420382a0a204037a4f92b7acc914c1aa8d07ce8c7e1ea0acd8730f14a8b44259534ef78c0e1be4ca5217b9cf141637afae5b5b799f7ca8aca3c31e815e9e6952723999f3a88e022243a81df3748e6ad112487e7f8d115035996b5831e96bbd7edde786ddfaafbd93ddb126e966f1e57aa8cdee7b21a27d55f7ab9ee306ce57ab27805507cf9d732c57a0cd3c387847d0e012484f7e2d749e8761227a5c0516d6faa729b3cf9cc098ca46643471cd50f9a9165f28080c24fae2920f3f2a48f3f120f6941d8f30cb04c5ab37648ffe7f65eb69373824d86390a358a63ca74cd1b688b986f36f3d4e2210ee85603ebf9e7e2831c673ecab9ddd7bf53f941fd3b157454b0f6ac9f641c780e87544f5d21dbccc6665a9f0f6fe190384960396703911353d33b14b46d8701886d71b801998e58782ba8b1e2fe5c1641e0a4a928d2475044df53eea97ba10981357fd9669d1a02551c5077112e34ca0c6e0c6f9f8aac3f1cab78b38606779af289d0279e49a120bfa5f85dc8fa655f62b74491c8cb4f170e7d16b72f625583afea8f6f6e6672a5fe7ee6f87a614f8c11f729e1a204038028858266d95224518cb436f4f7290b49d769bdf4a0c50c9e6f16a6f7358e17cbf844065c459b688ee1f553930b793e527de7bae16a525fdeed8c945b26d43ef7a833fd69a1ca7c78269d42890ffda6436265feb754eb7b173eaaa058160a8034fd440029e2de51c8e450c167e4c6c262dcafbe16494069d78b52b316c699a629f366b6ef75dc02578e7fd8682ba287fd7122e4af7c2930653439dff8921728d18c94f9609aa6333b5f2a429904045d14fa35e7af9a23a5e79ea67c769a5aef61428dec6304d593cc665c0b1cc302ed318ea5c20e536fe1f9ee8982ae431db34df4e848254a6246d8370f59e1b0cb9f5efb51154c5808c9bed9019fe5ff214aefbf97a3398e61b8b369ebafd036609db7eaf2691bbc21f0b9208701de56dc57375b169387ce5e5d780f657458603616ee1577dd607037b93c9d0673d7272ac2fb0037714d538a84ae3a59dc2bae3c3ab184023f22e0a5d65aa6c43b172c5d651bb0feaf84e83f23d0301bcf1b0db7be8ae21f23deceba261ae6b37291716b65fcb321b97df1ea49a24452940127142a89aa5d3a8d9c99c5bd597f9cc2754e21a70bb6fa95d4d77f6176e05c0341290089feae8ad18f11697a5900835c06e37b095d3fb0f0b47fd1c38aff719c044e27b7f24813e5bcd9aed70a4a78603688c2054fdb9c8b4536c8f582cde35459db9203db6b28976c53265e05900cdcab5c26bd5bb06360c095061e9cccd33a902234361bcdf01e0abbd360da7dca38d18ffc3a27267e546b4540030e221de3f44fb1dbeba77cb9b08799517089aae9368063a200d00fb98ea2cf95cd4661718fbd3f22629f5ee00960eda367fdadefb029d6293157984e6827fec77f5b8b088368b51e4420d736dc9dffb35c6c8e2f8497a2e711f611b5b719c3e424c3a2afadf5534b76786855ea198975f5dbc4519234930e2fd9a1238265631b56225277e0b04dbd387aaa205f7b863bd10a93236d0d11c585940b944563e4d205639827f3558148940209a1266b0c1b13a3e380d8f3905da01291662c7bb2750a5e40aa3f3e5bd84707979c3bf781df08828b4e828d3d00eeef63bf04f12522776b20156d0040869dbe61c110fdc0fc72a04db5de082e078d3e49236d3ac095a6379f0a08a3b7e8ec6e2a1881ac0937bd1202ae901dc8a72b4b286378471e02b9ad125aa2847b2feb6b8e29f8c9a190597f51ff75e8d19370e6c7c24a765386042cce49c73fba1e212ad56d221928a1f7e15b9ce546cc6d20674c828c93045c9ef9e18402d323f581cc7014548b636a7b1178a6f83dd88a391d8946844303f252fd83a7bcfcae0897c48afe03dabfb6ef7757f647ef4162ed49582c78cb0071e3870e22c7cfbf5c7ab0cb92946f34a08cbb05f7305ea3184277e92f57aebb693bb18814b11f91fba66847d926335851cef80b55ce085bbff36318a13e37edf2b96fb7e2f8999ced6d3b3f4d405759aac4c94e08e01c47fd0b65d72ba87a1942ea0732d7a14b636d758ec0e662aeac4fa85c6fab713ccec91c61fd1105f765f28761bedf693c01604e42eb39ac06be44c495e4296b95615b55769df4e93ed16ec48e70a03d76af1af0b7e8f0a301f81cbfd760c5f8ad79af59ee780ebf74542a115fa7a9597c39e99a96fa0da15b5a4bb72edea3eab4f67e7ea48c655fe24075b418cbcc531e4b54d121071d2660a150654f94ec4283df7c4d37c31f37822f98a3cb5bf8c7b434f0500a978e8c457082d9229b62b5a5ee4ff8d8f7c4339627676a9da2fa1aaabda05d666ef0f7ffbf001d348da1f2f7858a42b44b16529314bcdc18e81769fb75e74ac4c98e0615b6449091f13c9705f1d8024d9b618ec0bdabeeb2b9e48f07bf43ba8f3f22838cbe7832bd320312897954005d2bad5563c41024a078744230f9ad4427a7021b15748a1762137dd9cde84b967e8059ef213aaabd98c6cc25c78839f64e598fbd07c934eeb1d848170797370ebdf999b538b1ae9370b910dcf0653ffb07cf08f6282d6a395ceafd851fc167d09c49b8e9f7113571807d86edcbc9302806497f45bf2ec2427782a3115bdebb349b448bd8b282c01c9ae6f1e24ff196e6e47ab7e263b35a02345896b1655e0cbaa8a60cee540193346871100caaa6a8c960dd651b43c0aa588669e124c01deabe521666749055a12205aa781aeddae5734f52d0127f89f95010e45600e4b697f8b700f3fd60f38a62f9bda600c711ca90ea7addaa987b9a6c2553c513c7868f81e6343fb79459619289d2c759fe4678a67347bfe6240dcf13b829d0311b44f93a78ae7eb8a06e4e1a77b98c5014ec528dee85e4a62a4a89b14d0150647f519f2c1eb81b919caeea5f81bc31a8b8603b38f74f257d340626c04b85615e3fc90a272abe03c7b538630827876e68940542f3d7ae3dd386b7dbe1fa131ccab09129971de166b6ddd0a3a1abeda954ff530841bb14de829d53685de7a668717c5b01ee7194c549c83d39f92d88f4a3ea8fd014514c1808250942ed1b406b62e58fbc184c346295a15a394be4c85d66949aa8fa6a2b200e49004091368589b3550c6bb5da05fa074f15da5bda6caac6baaf60d0b4ffed190847ec585af60f755d5b229021d1fd16ffe51413e7d196befd4667a356a4d03d0117293ad16e3efe2814ced428ed6108be192b3587230a143fbfb366e5a0097583c6ba47e2c2197851f143c688530c437dad3963bdb4295b44bb863b46cf071101ecdde542e26fef390cf8e8ec6c6892136f4b05ac3de92ff68306f0d3780e65526c7ce2d5a62b9fd7a080bd4ff922b1a7d734e0bbc4f49008370c81f89eaf47c4a851c2f1e172c526b4bf9cd599a8131f68f8a6c8e347d6dceb7dea147a51636dae23c829da1e346bcedd1e1be03e7c74421fdfd68acbd52199ba4b688a18afbaa6abf47bef6fb0e178bcc042da489caab586896f397496e94744fdc0f4a2c5d260448ed5e8260f6192a22c0ff1f461c92b1fa555c13831052af87cf56dda28367ab612850ac343179c302ec8ecdb591074be233c01ac3cda1c5ac81c3d104bae023244240f1c0ecbcf8491729e88565371c0bac49fe5f2ac48635414d9b783382b4cce9c3977944160934b7063bf968ea957ee3554c9aea10810a2077bc4de9d0a6dd8cafa776c36c23202e074b4a27caa182e921d380a6b39a2384512f428d6da453844b0dce232afef4f8b1530a301a5d63867ea6af780c8440153d5bf01fb535a85b0bcffc01d94b9df5d6a2ad05cec97bab2c7e1fc37f6bc6281f6917ce6d36d64a692d55479a23a3ecedd78a62433b9de67b25140d02d8d6284b2988b196f9364c54941d98fae0f2c028b0d43e848e7b99ba121ec6016d27930a76018939d3aa44067c8d377c4db557b8b05a8a209ad5e770cdc695e566415c9a103c85ea19ec40c7571dae5b1a12e0efb742350221a1850a544cb5cd572be7aab8544eedb2f33468f69c4f98fd724eeb97b1b67bf3b088f4f7f8d212b4dc272e8ecf65fa29a3fd982539ad0810711cca4cc3342087a7372eea018daeead5f5caf040c201e3f5fce05ef9f8026b6c130f50797a87f19317b81a13d2e6388904fc5f091210e8a82586e944aa7681709a819477e10454a9391493d222e308af79158dd9ee8ad15e59824a2eed7325f9270abbc6b61a70c520480647611ff5e1e2795fcc6004c1d972c82ffd330b4016db0545dadea1289b299e71c938247d3fab2bafe3e3dd277c0510e2e2bbc65132990c926d6827882317af8bf0bbc6f082ab4f181f8da387df7b41a2e2f1797d1732439c3f0fcbd7eb87bc621e15347162a3fae54f66e438d0c69628405693ecf68453e8070a8abae9fb87b341d785a8bdd2308d48cdd5740ae469c594c6000574fa7e3a93a447e0bd11189fe3e8dcc49fed1465739d3aac6a6b4a30591a3c9f53a6c20b2ecbba72d6195f10ddb46a823e401df53e7d220836ff291aa0c29ddad88e3f160834924e1f87e32b5e2143f001d617269b6a49ec5da66faedc16c0f9afe811be2212133c28eaaee45e1d842f0940c76357d5f1a3ddc516bcce4be47e1239caa27625250c14ea4a167ebff2e2db39428167127be91c2b176173c859c109cb8876511e77041c9f1dc157803276748f23f9e824dd71b8a6ae970ba024f53a0fe6d5b0f31cc9882b4bb8df91f1b244b8a72ce05d84c2ea8d311d246ed38dfb3e524eb24b7b8e6963fdb09d7ad8426a7dcdf36d7db2bc586baa826b0ca0f7bd443e4d581b2ed17c6aa5e8b188b94afa1829e5cac7b93dd917c6e1a92bcdf784c289e87f80b6f43f4086eb429358d9afabdfbdaf2dda060c5d7ac42b501619d7274e94cb13bf7aa13d361db753e2f38de44a3e4b280d9128841eae0f01a71b8b087d89f784ced4cd2b43b002ee32f4559cca6a93ebe7eab1aacfaaf09eb994f9de96e2f13b4b546f42e543ead6b74f5728c593a40c20458906b5048e0e63e36c57bc75a3ba626b56e8cc05dcc748ec7229b4e19bd6b6acb54eb36bb4f0c1aa58daf286ee780b246417af438300fb2224be0fda59f9264367ad2bb346cfa9b0ea0a5af4c281d5292800ba4b06275af1acf221137f10cd22e2c708f9ad880cd8fc1659b6e1db90bbb9aa86a4b8f24f66f62f72122371735bfda8800e3018bc39b5dcd292ef07328dc719dc5e156cc8478e82f8080532450da707a4246e02103fec1805c3ba7304875756450dd2cef0d3788372f2d3cc0dfd7ee940a91c091c132ad7f34affaeabbc1985fff89f7127ea16c265d74287491f75048f6fa5f37922c16f75672127b778f28c647a88837a7f18969c06a75390e772f8049edaa7cae09e6a0173646e8a5476a8ecf349ef44b57050f3df6148ebc382fdcb3c59fa25276ccbf4fda3656af4f9e599bf7860f0daa0d41d687829f2fc21b7a1502f47d6953c20194b1455f92dcd87d3d8a4965aaf665428a93841e09da5624bf9df1c238c5e409ef8df6fbd52aff9cac06ed2dd2ca729d7205fc28648fd4e2dbee5553cb132ee453cdd57b3ec834283df1c14348b05573b87579c1742d64865b7f4c5b9ef711bf98b6c84d56b50152feb5ab4fd99eefabe2d03208635ed5315405fe1e4a681b94872ebd82505e836d5cbc8ae92475fa14b5069d12a712086bc00d24ffe0c410c6b53cc81626af26c0b4187ee234729f18f9af1fdae01ecf1124c4ef80d7ff0efb592f082d3c665d32fd29af48c32218bbddee786426a914b945c7da8eaeee9a264a14c16d13da27bed3e405736df7b70dadf8849d3f6f554ae09e43f45de22b703633c1509576cfddee9c36ae8df60cd53c23b98762cfeadd39149dc28ffea68ba6b5643a5c9bf9b99f2d020eb5951b3011fcfc7c0a2b16f4dac100e5efd4f80542616fd2f1fed01f07235faa4cf0a79d4ecac41e9c7698f4c810403554e43f77fc101652e9db10c5aa1599220ca2aeef6e224e8b02c5c73ad08bfa7e3111203945cb581718e4b84b6cee64512cd9e57f6e61cd1f60837dd1111970d1abb219b74710dde9ea735a23e56d3de9139475896d290b1660351868aec5e54b4acec4ef0229ddc8dbf07e2f3bc888cda2860edad65692b1f62c61ee0cc935f6e838d3c9489e614a7b1f8c4e2615da33969cf80e4c3ed1d471984b753153982dcfdde5bad61bd27d6c72de84354900b32f84743e7aa24f9f9a6fcf3577f4d9afbb7adf130704a21bbbf142fa3c8024130d5b2d0bb84227804b0d1a4cb3cccdb1d030a1ebf02fcc38fdf36b954eb364cde1f8cc686bb7d30be6bc6c515e04cc0ea2b0eea1cb782a8eb79efe1585c3bffad5cc1c14c03320ce283b98be03986ba05312db47105eef538a38c5dd6592fa0e32c391ebff083d9ea992082a3b8aed52d7be7d88c249faeeff75e658b72f483149724429e2057b36846a2f3fc3444ea4bf9d0ce770d544d1350c9148de6483e22449120e8d53ee4cee3de1e5edc70c5e6cf1917cc3f56490080ea1a0107fd390a94bf04bb5e47444ce89ebf6a98dde74a434066e8ddb30bdf97b3364ab27b593e266e52a1a96bf0ea48dafa9338f325754aa6a275fa12b38879a4df3dab59de9974443893e5796580942394084733821f15a10e0bd8a02c9b7769e55901225f4831e5e2a46545d6f6662c8d15de6878f7d2a6b2902eab9c601161e81fbe6dcf9457d049586757ac4ace81ec9e2e44f09566801803e620e383c6a852458f42f22077c955ee5a05010d915c6a6177631186faf713b9e2b376691b0cbeb49c981fd50803d013b29e02ae8483bbc10601a1e490c23e81c0898455344640f9041223d207d01794e33ab28cfa0c479da9fe7b5d48d432125b46f310d7c22716044f9fda2ac00153b81c7814d9bf0bc7cad966ba07bb2990b3e2fdcefc2047d0262b7baf7ea3e5a2cc270366ec110bffb8709bf110435bd28183a9bd7462488a3caf5748299db11d78951af66f0583e837a2a71f540365f4490d9ab9fb03d0d0d567adacb0febe25f4269e8b2a97f5b4a97b6b0f4bbe805f5be9e34ce1107725c0a4d1e476bf564417bec58d89e21292b7700a283b6a85526a30ac40009ae15d620356d2dc8151625ff6f7b9714cb4a674d60028f889aa36425bee3bd28ae23c3beb3dce7578502ce523d62dca604036510b16c60b4502457f79f36c25399c2d2b05d515b0d9b545d56fa04e9cacf23c16f12e69c43cf5b971e3b606a085ba16b395128ad91355b4a23371701f0aa9f22a2dbaa82efbf67112fd1d108d18ced58ee8df169cfbfc5bf4542b09f683ef1a13161e233e0e256f5d16515d3026d04bcb328a75da4c42ab73ea689ab8b1144f1ee087f4c35b1cfd75684cf484e2d4519cc85d8a52767d04a735219d0d41cff188ee77409bfb8053ee43954c26468c803bd7bc232f5206fdf7e96bb48ac93e24f49275ece7705dcd0810e5601a14f0c3220b85d386b06c3729e89a41469a6094081ec285558c7ccc9e038afc4621618e21c8087ed36b90b333cc773252cad376417d374b1004ed63bfb2426d0bb4ea207d42e1e326e4ee52ddbd440ac6d43f7d2d7e192ead3e36ae25018d84c1ab109a1a8c136eb0e9c18cf9fb740a6549ab1e116e18272489d986154f4fd1ac2cbb5b42cc636a2f7866f136ecf4538fa5d5b6c1202d6e87dd3abf217d904f10a71bf711a0b10c8fba4d0b7b29179c8eda4d9e23d627442a9f7a6f1971555242f64574947d700d8fb8e9f724545cc1e61d59a0dc3cf1899dd48b57e2fcb69f2d5e2262550c6bea5e42f66a1b089149841d54ce0f4a8904e64e802524c102c4d82fabca949edb832cf43e16df7b60985d228116935c7e4f0aae36fc52a92119fd7d0fc11faf2fb0347d8a190999458ce7cb7cb77d46fb8fb4d56073a682104cc9b05cbb1fc8aa5664b071f1b33f5d0c12fc6f0e62b228005cb05749401ced02464f94a1b17c2ec6ee3d0640acd55374f030d9d52d6c66db243ef47c19d3a7c63b6d3a2ce855e83a87f234599a2d7631ae7a26f58dca4ef8903dd9e0642f10bc99ecbca83b48860a115423ed65ac6228861cdee07eacdd0c1db0e465227a921be9e937084985e55f7452d14d51aba1df4626ffaefd50180d66649cd4c6c511da9aad5d13a34e1d4e7a0811ece8409673d99e600c6aa26d27bface14fc3522f3cf186013b50097efdc5a5338a76b2d5fcc677922fd152b033a6f2747d58f4dbdce8ff3855518ede35e198923e76d76ad652b0b656675c30b20c4c176e2f51bf789525f79db047911d7de9f28d74e634cd0a7d18b057ca49215acf6d8402aa701e2bfcd57609b080ac1743b74359f49ea943d36a10422a4b211a5275451d4c31c8f7dc4a668787ab17aeb19c56f18794a8433f957b6ae426e497da477619e42fbf382fdd2867c0811ad93eae3c8c1584af203973b3e1e91931e6010e7ad7c995fac5c237d6b2d6c3e606a6d74739f201efd6ddd0760d9aeb0358d98a4ae2c805c1b039fa9d1ec10daa362106d441a63f1d8485e7358c0895097217609173f8f77f9954c6fec1b79b130cfbd38856319e27cdfcd4a08bcc821df13f3098908151c732e3889c21af468a6ce0c40649b48181b2f496cb1e2d4fc8f80d4228658e3c921566df27ac69e7c0cf23168bdc5cf4e3a1861df90ae0f06ab5774da76776461107de21bb72c2b92461e3e739cbb6f6b7afcf233f00aaa4052bfb39dbc9060d077c9340e522fce91ba1c5683932bd6116be655c310716a216d43b133eb32879d80c92d34d1f4b8de08c4496c56e9922a197305f725f662766f966fc07bc1031849f49c5ac7d4cb542a06655b2baa073fcbfdb583e16157be1769a8c398f1d02db0a21de616970b2d08b6db68b3210d41eac335bcd4b6168ab3871256a55b3207353825844a9defaf64c259af77f2b43d5ca35eb83d8de0154849dece4c1c76bd884b2d64150eab72482991bb87525fb360b87fc46d3de9e43ace18e3dad0048ad370054ce784aeaa80271bbea4dc2c2d62788ab58d2c7d0fe114f19cac6ab7304f941d40d606ea6e43094e13af9fb34689089935b74d1a0f6d671c9c9b34fab64c6a0357dec64506f0dc7bc5bf110627ba5d1c374ad61770a64ddd5ce2107c28a265eb546e077b822b0998200f1cd6ef3222d0c77093af4fcfa9a09f6d4ddfbc308f46b3b2c2f52a106bab39f03743e804e37711a90b03666513944b8585b201ccb7fbab03c074aa5aec67ed77a1ad8ce5751780fdaaca3759e1a32c4451fa90fd61628ca1ecea231549416c4dcd1f2a085c8313344eed3df7fe96f8462c24b9155780662df62889fd28287acea45614a6ddfbfa273deabdbda5b17d895f8812ea0bd460bbac5fe150d1eb1482b8e1c3dadc4afa9ea7457ea6101bcff9d613a4753f2cb846b6f4e05e95fc3fae0e0887afb63f5ca0729542a45964545c94c1e30eed247d3f4faec85bee8061163b85c99d26e421975cf194dac5b074274b4766e858fb3deb46a79c39a38b1680d07813cfc2c9e892cad3a4449d4fd05edb3971a1fa44632c41625953abf98517aff41f940db310a713dea155708398b32532579d4be2f0d161fd5e8ef41c87e5a16b3beb0745d91a544547c41fe95b9a541be1e796540c41e4baa55767d11d18fc04d9127853f38cf0422e61d84c4cb1af7665829f1aea58c25c07ec14c9c6484eb4118c2151fb8c52cf6fa8c328b2e49e18f658fe07ccec88d5602fc69bd6b3d41122fffe452877f51a820a6c02864fd4b557013105d576a9a40d6c602883d83117cf575c6f6e2867075fcd7699bbc2fa0a048827eb2cdb1f46396737d284e2a12568abdcd5ae4fbae7a78eacf971d460bbe4ec01c8c52a53ce21b1e06f7d1f3dbe49b8d63d908143628c4d8070f3502126d4c6e3123bdea01028b8cad3b71e3b432d2991093b747bab183c5ac1d55774d69b2c31d6efe21f8e8db361cca8c667d3efbe78fbb2e40bba25b08240228ee6b4da699fa48e54bde1087e6d3361ecf26f7bcb4e3a5906387a5941d488d0dcec9bfe99b0eb98be23950bb04d59f1b939fa182660949aa32e2d8e217beac4d82f5cff7ed7fccc948245d37f4969703ce0d0a335d6a000b690c208a48a2820e2b68b3229469e7a85948606c4890973d885ce81cec0965bc0fee5e1eb8aaa508d4734ff2bb0b4db0f1b4c78fb5f88c9cc9669c046996cf0c33b736b8478595ac75a4374a0936825a5e7dce5ade8c210a6f9a66b9d484a43fb9cb421f3841e1f103529f2a2370fcd86cbf554bdd2a11820248b1f60d99029ed961133d5f273f13308dccde61fc61370ebc726b7225f9a80c4961d5360b722ebf74bc029d466b3eadbc6be833f7711e34dd5a0aed23c1151994fb5fa197221c2fd77d2c26319848f4fe853fe463773a1e58146bb519c63f5f4fbced949478faac7bccb6bccfb1d1f14fcb4b36422dce53f712dc7b012b70d260ec77c7487e5a00873e392503c54b2d214875f2e2d88ba8bc1b6ba8ccbddf3e6f63cdacb030bd1bd29287a9feab04d707054cb2e73ab1ba2ee38ac9b046324a9023ddc250c037d8b5d66067d9e33bb581a9691669c65cdf3a3b3ff327f3dc9f35de9306e47af4945ef2375488e6a2d5985a9f483f7d34a0353a997700dd8aefce70cae3f508a9f32d7378ce5582985ed44df1b4ea7f9e4b94161e390a3484f2967b4c844ab66b1d1a2caa5b093c6774c669168be56dd8c1430cd05aaa98b82795c45887b7cd9be20dfea293a67f9ef615b3f566fdc1e07f4503ac40de86f8e2a45da10e17e0ed6bd0a15bbcd580ed8a44cd5ded1971d6f5c965c95588c377180f98a34ccaea018008ccd998660a660614f5cd6ae04075091dcf6756f251414f8146f93ba56ee484729fef14ae532679368b286e90833f7abe02ed3d9e7ce94d014f02a3074ac688cdd17077fe8f565e562145d58f9aeb4145045f32ddb5e4e7243997a824b3bfab91f87144c876e3a1e3b9ed3b921b8ce0523357630525a2af3925afad580d19b3f2b155b2388e6b7dc638eb914ec95e5598c568fabd3a832e0f003d1d0fe30abe34e3c62a91f3434474e8e21c79b7f1687a7598b0538ab5930864cabcab937a1993397b3dec40f69356c0b6e3768c9434764875db344b0f2163345e499e3c12b941fe4b8f76487189601e42b93483da65ac2f8cc6c05edd3c0d62aafc9ef9cbbaeed9da285b625973b68d65f82b7850436a9404494d55d03b531e3a3fda7ea61542f32419d94a98b0c58b87f12f90046500aba9b2fb06e7114b5a6dc30080714d8d17efc852973713b8cd5c78f9e7aded4ac9f95555cd445524bc1a035287fce35ff39a9c5fddf37e30fb087ab5e640650cebba4d3c2239a840c086be7ead13696983c15a6bdfa91e68a66b39c71db36b9c172b7a3254388aade37ad08b695d9d2ea0df0a34c5f930a00a2d4df9ad7cfbf8a7b87a2c780f510f2e72ced8643c25bd999bfd0cf8f7eb22124795b22a1dbc830c9de90677a9662f51bfd3d85574eac97eeae55aa9ace3dbb9eb1029b4a9beb6b9aa55a4983bdec3886d95d9fd3539de30aa52b01dfe04482d104f114fcce28858d98600b626fd1f09eb346f052c9528ace978446f81cc4290e17cd8c0d70f72c2048daa0d0789257d66c6968296deb9e019e538223b0c5236d3c15e89327225c89be034723e3ea3130160fdc861f42760b1f0ecbc7328c270ae8f583bd036f453332cd4e91d22501bcb7b53497ac286c1e245ea632ebbf1139de436134abe5a29e151cc254c0376cafb895660a2d3bd6d0a5f6ee6d1128fb05b543de2b6bbe64e90fd34a6a4a05930299ff4aee4bac16043f646bd32fc75c24524d84836909e957c13e0c13411ecc717fddd3197cd78f2070ef7ae15a0a49b96e6c25a212a46aed8edab0ca87cf784dee32b766a2795506f09970830f234e87127bf8fe167a7f39f2d3d128fa7f36b6d6f4acb5edd4e6b93a0eaa27fe1b18f3e36bcd5d78a554848d807f3ed57499e6ec622f68352e0340e22315bd79ad07b38baf77fe568243a1cac02a4f808d59fa10b415bcea0bafa20bd0bbd174116cc03512636c4b6dd80014c2d07f2f2d08b6981bb9da9e08dbb694b68531ee408b2387028b7fd994cf58fcab52fa8e39827e1c60cfc4f8e3fd399bbd7fdd2d065954da47a4e2fc9c4dcf574505efcfc2a04efdabe4fd416b39a08acab73d9bb29ce896a08c8b2401f41ce86677100dae77b7c2947748f0e505d18ee3e0c1c181c3797308c1d9d69169e3c7bddff4be2cd8d1d5ceaf78b52d20eedf34d32a2d4f92b081de530bdd336b845a4636bc35970857be5c4b4910b3f3fdcd1c9e6cbc6673de62b269933f59ab8945b82d2eec642d4c4d499243bb02ad52e6e58ebdf07cc4850c3f60fee861ea7bac7efdf04092b15755fcb770a68779baac597618e8cd8362bf09c5559cf92e31e318e4560e0f48af185632170687f1c61f1eb48f0ffbb4efb55da6714f7669c909171c4a6a60cfc8dd9caee935f1da9587a6ec92768d6c86f8fc0c7b540dd73f1bb73581c30d140729cdac0a74ef7192a38043069fc8b8d6a656be4a349515d2269a9882bf3d53c5caf3193a049d269c95c58c94b7b23e110b71a0dd2373e061084b9dc83ca351fdd2012faa677156b9a6203c3cca83529808971490ccd015fdb28e4606f6904306f6351799faffd02d2100fd2e2beec48f78cfcbf19fd40a222925b6f44d3a2cb15ef99b8a347b431717f59704dce436c416e9146da3f054548df70b915185b7fdcea1d7eb5c431e4fa1c479054f015e6b16d4eae91b0664c63980f41983df79b141c66d9fda1bec20d68f4068cd88e6fe314cb107e93d29f6a3b74688754f9e6b9d3c22be12080b853a6149e13a6c4fde956835e778051bffd8a48e1f24d496be4ef174554f86d51beb0bfff833927c3f1a163e502b4796d73de6a1b89e0f01ab5b64ea341e7fe32584538438ad54ab68434ef2ca2308f242c00aff140705433679f8c02ea8f64f5770dbae6b73cd44a0a544b4b063a4f0cbff15a49dd06ca00d5d550c3f94391cb69ecce31f289beb36cfa77afdc3d16f18ddf296830ab1e4f7b48adf33526a56e217ad692562beb15ec069aa4dc4fcbd87143dd52b85e9c51a5f22abcf4cf3d2f92a451ddea81b13d44c0b710c52bf84e0b963d17256304bb6058dcb66cb135b1d29dac0f4ec318cd6bd911b8a0c7eaeceb025ee5c99566946005f7417c0300803d0a48f31520ea47ad368c2a292a32571153886f374abbd672e1f17e7ddf3564335a3eb81cc2611282b651c980709360850187d7ac7e3d329d0e566e69f1dad89c6bd97a9f2fb2c61a2a6fd432a686e5ce612b688b7e0fc7ad3e869513073d62610de38b085a40080f6392b552754ecfa14024dea3cc98ad4e259cff607c59cda9ca46d33f47c2fa666e707e322a58cd27c3ab53089bef2524debaf7c850aabc542a2f1e8222b9023e48bf08457d4ae6a80c722cebfec6e9c6d45b2c80c13934653226b3bddf8a2e09eca076582743f18c14fda0a96feb0aad5b8eebf2f72ae9ed4bb7c0e59e4ca8b848221f51c8db9643fa967a0b17c114060a9dbf554301eebf305dbd9e9efbe7cc33f599f71f37655f38516dc1ecfadf9a9a0ad4e11646472f79b4052daf9ae9170ecc154cdc54839406bb9689e6968a40cf14f7b75a845711a935cdefa389fcfcbc7021f8269f1b078cc61834c0c94e4bdf68017ff39f83bcd5de5b62f33167746c3c5a200de2548c403e07565a38ec11bcf7da2ff837d115f15ac71ea1b62a4ac9ef0a1723d7fab53079691f88b8c1937ddacd8b3860a4c054730106c67eaa09ba74383537cc0bcb71de827590669976169c7b56e45bb1b32467ac5bce0b5ac4b56a44fc0a350d128a6203c3c5c83d330957757d9264717f5e55e2fa1741fed43aa1a44fa5018ee6de9ced1cc74d7b5d9cd317fb0ff6c8b3deb1797ce7b23b9e420f8351dacecbcd901f05f0939715b3ffdff047be5c1a6556f9577abaca27e294a26b7003c051d61645df8edaef024054c6cfacb3e84d3d1c72fdc528e058b701813460d7bf1c43120c64dc1bf28269d8b979f94b1853e71783e03c6e25035f3d7899bddaca04a22aab4e0e5cf03d65abda1894fdef9087f72c9dadd3161f054e58d4c8a093c03d4b4365c636f2928ea7d421a42fadd149b882cd85c7af60e19febe869eb526c8a3b101a639a894dd949ce1c18cc502d0a2e89ae0eab809b5849818264c40a4a371d1b20acc22bae29c76d1ef61b2519f0670217e19ac94f039c5add6a1934b9ab8e03b8a21ccaebf3f4503d5079fa7c0a9551c48002ebc81673e3337315b559308a2ca9a5bd8cfea31c26fc13373a31fbf363a913c8a8b5416244c22138c0e386bcc1c9550fe48e1e335b83356a2cb083647bcc608c0314b1452574fe1f2ceb7cfa5885dfbf02a4b19f5f508e3181f8abb8b348e345ded2fbc9301ef6a73bd9434c1eebbe72c2e75ab73eb9a425e809e500f4601ecab5b035471ccfe5835e73b10b95f91ebca955dee047ba3bd492a6ce41d42c94efa8f63f511b3b984d88438d8a9813c5db6aaea446c73c391cb2680071f659a24db779e6b91c089327a109682a55c45bb22627a34880b08a3c2a73de014235da9aeed2bd73118cfe6a606c300b63b1731517142210e21b62c8281fadcfdb72dd735ecdf972ff94ab05c04ade7483a0dd0b4e9506d71c62a5aef7b1b7b7a2490533337ba84e7a3f8d2537ba1af80dd95cb9c76e98eec54862a62131cdf490ca22f93331494991f15c434ca825d274a44cb356594f201302861032dd888b45891baf0fcd521882f5d08ce81f1bffbbd7f14493eb3a170fcc5b66d1d73d4e7babb16406ff92d3edf4f85dddf78f29f307fcfa8e4fc9c862049d302b2b91f3547a4b008eba4a570f5a6f28d7d463074665ab28930c5916b05e38317c40f1911f65a7a4506d5430f82c421027c753068765c118d0043f4eb20f7445e327ce07688b32594efeda2cb25b1669e5230ba4fbd118c4b6d15736153c16ee40b1aa47919070c2d07b16adcb2bdb4ecfced38df2d7d5c770da0ea1abce6538b3e5a89cc404be48fccd3ed8c153ee4ec1f39bde91b403d905d34bdc930bc27204644fdfd552885e08213a58827a2cb0d993cb297c0ba1594ac7fe4282fbc118e3ca7b7924bc43cda00653ca0602b7aab157b10991940561f48bdebeb06c0e98d600e349f970a404bf247a4609c524347df7647cbec6b922bbe04d4cd5a2a3a5f10e21884e6466fa2ad20ef353f5de07c8a9e4102c20c37a3f691432c0b759fe418c63b655a09d95a5861a8a36ef8cc349842bc6b015688c754aa650768318dabc6ed85619d4535757d74a2a3df1d3b50f74bc028f4925ff4f9325a1c9baf17ddc0bd6aac876ef376b38ce62a1d8932d6c702fad8d8b90326fc46d493c6a6dddaaf018660b773d53d38e6de12a42cb745c564f687194a0ed4c0a341d4f4d83e8bd913afcf4dbf96d34ca438158a75b538b8dda7a482b32cb91e3b44c05e6c45e7cf18e167ec064ba5b694dde080f08220bf1716dd1b340133fa004a6ba0dc44ca870ef04734b106856f2fd66e48af190be5ffbc1d41eedfbaa90bdefb3578b5a0722d3fc25251ee531e5a4a6eb8f2eb4af66e44e2cc864ce344d4668e08b7fc9eb08703bff9fb5d2b15cb7ff90dc231115c2fde0c6182aeece4799445209d1e628d4f533a81da1764b2664e463a5deb1483daa641a13abfcaab044eafc8a36703c11b824294b5da8139c22e7a29f2e2e2506fe7827051e9a170043bf2cbe36ac5a1def91cc13e084f15caae7043457dab32cd30f96f9e867f567e2f2fd73e7e98be42b50d0fb105840f9e300fe5c2c28b1d800bd8c761f8424ccee6c02a3eaebfb552913f936427f38c7cb238777bff243087d720aa83a8828122083efd733f1b6b973f4935a64a6049f1a254624b3512a9fdadc05d93c262aee57e8e8bf1be2e7ddceaa8ae0f1531caaf71eb7ac69db22062180cc03198088cf52035756c5a7e31eda925210d21709764a82a8acb66e32c0aa55772bf9a0cc00939627b62a7f7bc9664e2a15951350ef570ae5c565ae098b06f38d3ba66c0f18397dc5143e0d344c0118be22c91c909d0b2646dc6f8b590e73e2beb658fbfcb53869b391d5dc538699f6808056eaaa98abc8ddfbc93982d170a10ea32ea5ce63bbc261826f834f9202e5a0cd1d9e808609af0139ea17037c4f6396385f98fea8e5dba692a4c268969ed17db88ebe4a4a83b27dbdf4a5fca45b6c202d87bc2133e1f85151bdcc692637a1aa061e4e25e30a92adefbe7fd92498c5b52e99e63a2db11239ecb94638cf2a8fd74fa7a08502209aa586b4e2f7bd54ba3669df52f532f34058bdd1700bb5cc84f38af523fcd47910b0a425d8acde62ff8d8d115205f840aa98a450c1be26b86afc75b3f3cc0b9e2652580c3dfda85a4ea5a45c2445b717b655c6c0a6078a988ab24e17a86e870963d74c19dcac1e2ede0160ad2d1e10be57846bb2577888a4ec2a590198351b91be84e804a90c76c0169995520264290cccd00671ace0e7fa8f1c51e5efb2f8102e6f79295cf0a547fe2a440bd9ad979d08d9bfe318dd0956294be8fecc22e95ffb39dbb29b07a323f5a3d81e50174411ca4f1927f0cf1d94ce2be76d7a268bdb8e126acf7cfdc497d69c7e82d19765d8c1fb668fc8b1d079d721a4fc8502fd861938efc86291762cfa96f652d47dc0ab4228f867f60a7da025915a68975507ced2acc13ce88231729c7d3f700ae0d31ea3e5fa0887cef085e4fe1bdf547fd01ff8ec080aafed2c21184ad43b540ece27fd812b67f4a3ddedaf4c42274e425a1aef8e18661f3e3530218b22271de31e5fc3cfbc18002b286a2c3fe099854019fba109478ee0d6ad9dc931d4d6a1fe9a1cbf1b3c942d9eb7e751e06df3bb6ced535109f5fa6cbd54423f815609109039d99769ecc7fe2e61363cd5874512a1fe46dd45c6f07a36128ba8e8fd0b47ae14e11c688474bfdf5644591568bb83cf2d4f691280f2aea2bbb19bc20a2f279fbc1bc5b35ebce25217d6c3d2486d39a68e604bb68e51bdc16671860487556b7727bb41e023cb621242ee6e1ccc4f9a156798f6e0898fb73bc61f88eff27eea48e00211456cb8ef69b3df7a8cccb2f9e236b1cae0e9dcb02da913603b9ebf78f844d4819b769d0cbd72750ac208185c8004c816c807c1769bcfdea7652a76974245a819bd158fa05046d136b89b81af22416aa46a75f80f781e94339fffd841ab7a01e61bc109bbc7344ffe00197080cfdc29cdbe9ded6da5166c7117bacc3da006ad6880e6f3da7725ebec961cb380c8ba2766d8795bfdc8ed5afc6aa725c7b7b23cf4b9b551674d8176dfbbffbb14b7f42a131968c6de477a05353a66677bdbf0b89648a7bf3dc17a3e1d0a9e10c431844d1dd2924c0ce83875e8dec71e517520c928e99495d11fe1810f293be0d7af04a9b9ff4c3db456795bcbccf04e14d9404e8751ed539e85c892c0f92217694745f199c79c1e51d8d186d2bfc1e953534a5f51dab69b48befa6b347bbd9f2888bd90e64f4be852bc76a33aba3edf06135c8b86f0d3aa5b92c62d5935a22837b85d9933f4bd51d77609ffee946bb87e5a87b85b9a80fe2878fa1849ef5d6023004faf090d8b5a4695f5aa4e51bd8054f58dfe33d412c7b49e0acfd7b3d4952126f12078e80a5ad634629312d5eabeaa1cd5158ec1c66e86cd241b35e5d4f1f831bd070d049fc9f9120b0d77a48479bdbdde3e5beeb4f2f1b9ed3b1f37ce8b0c1b7e912cdee394dfd31a8a9a4f955e66fdf20ae54db181fd855c26ae6950d33990ddefc552e12518e4ec288f6feb6ff00337b496fcb7449432572c5e7b6e1e899ea67d66b7d39b1d5bac355ef1ee03d0fb05a9891e23a21b649544ce9b1c99d239705a302068ed0f60ee88ed25e151c76f445999600322778e676cd4ea14ee31f1827a4198b4a05df0511c491233512bb525f09d77e905d564632af2b3d7176d0633cc95c5e6e3e0a87f8cc28a83a9c9255b02019b9a3c696c03aaa6cabc92686e45795c323a3a54e6535aa88291733584c5283000307c8a10033b415615475e65726eac0ca29c73219c3840adff77b1782d3db64ea03a827a36495cbfecae4d9273c3a362da597fed83f4be8b38c36a8119ef0aa45eea2294cc309c6e62fc463b30acb39eea844180e2fdb79c1fb2c02aa3fea41d4e14d04a834b366290a3b1c53f33c9bd9b96e527af37aad6f9fc9974e1e2f03e9af216d2fb5313c5f969ed02fb599650553f66e108a9ed1e027c52c1b7723a1fddfd51d444c1adcf24443379fd9d7c28f0269d5693b5168c047dfee72d8b22d037eb7668bdf9264ddba328f610f439e6c3d79a4bfbba8b418f48be0314c3be7d5584014b58b3c1b8955db7ef4fee1fad02a8abe18bf6533ced28459e60fee09fb446a5d2f31658d1a345021b6cbe3d7ce255254f0a073901b27c9731236631f1a96e3c7595524e59a9f17c54e64ea920cc78c91950a5570a759ae7bcb5afa41ae6da3f2fe349f5f64e97e9065dad3d7feace0e5b047ad7bf89e347d874bdcca0a1967811fb431d8932166a75d57545335878a83833e5592d107ac64a87a02376fe8a30c0da160a7fb9be17cbc2e1694f7a6e4248170ff10f5d0ac6bfdfcdb03409bbd8875d63b8796904f9ba38a590df4de45e29d4c20a783c5ca8033757e70f3c71f8043ae46cf6540dc6187c8f0c4ec793ca31ff0f06ee05945be9477aa65baf56e9c61f4a8332af8df2a7ef98905096590715321448383d09a2435e67518ef6795afee75f667e5d017e497bcf90e7ed5021c4cdf3bacfcc5eee0cbde92c9503da542e18db139e31054593bfabd74e344329a00900277254907322c063abae7cc16de2fe4c895baee92b0c78dd61ed5d47cc9f105bdaeabcd53500d9970364fdaef69a79aef44a41ae7ed39b2561f4e94adcfa51e851660c2c11777bdbf8ec3565dd06aa1f00d6f0da54e1723b7637aae8710e5c7ad400e2ee0fe92129efa12c97add7cb869a596a0b0f357b342324412c85782606c35d6f761af9219672c48e0ac504a9e1c3742e962116dd518a68ad11c70dea48f8276b20cdcd8963df36d6d51fec452cd234795b6f71e1cc1cd29596c2dcb72b2b614ababb621e22457796a850e55a24602a69485a4691ac130af98f88c3b246d436c9e8be98415a6088938000ffdf5d945c22345fbb593ca760bd1916aba705dfc95ecf7a332f4b0320c2c66b3c8d05d8c0266dedb102440fc1488d0f60431aa943fff8d60a92779078fa4ede899cacdc51a4dde5d10675cb234ef9ffa44a8da35c3e760452f7bd2e224cdf5d1ddb3a2bc74bfd27336c9c5b0ae189d61f082e73fe3369a1d439fb72287a7f1e6a9a3ce9579031dad4cf96caf21d8786898a2fe2a5cfaafa63577dae017e42c5c59985c30a43ae6d72d241bc32f956a9977a5c5c40db281a07159c6fe75f523d41e7e47b1bec837a45f52fe3240e4a014d6585b552a5273dd7821db4073b361d566a489e42351bc6f7c6b4959d2331b9c936f63f1b290920af70a3c27ef70ff9928a0fba3bbce8c7c40bf308dc722f731a21477464a141bdda5a316c8a09a5fe804c7ed47d4777648c78514970a12305f16a31e1414a37b961bf9234eb5f5df4e775a10730b0039ce2c7a12d933bfdf7676237e8fcbeb014d067acd586c18b6277c05aa29cc915b613645a60d9825042ebe8e92548fce0246988642b7c43057ad1b72876ee0b84e00371975a377a243ebbd6f2db9b998c6f9c3e67af2f09acf5e00d83bd4d1f994b0140d93efe005e7cf3e69648dd258e428808869785d1fad705f300160092c44b2b1c164983601d9bf812fe08f143fcc85af271fdee3ffccc569b43c87ca013a79343ff899f7ee2da892a117e04f6391cfff6f0ed306220629d1dd9ae755ddff8bd9cbac5df287272eb7115a65da9ae1f086bb1b4415976d77f0cb2fd2546541281c3a0a12e4bf3bfcccb613e6a3635da36f2ab32c608eacf54292ce1dc6fda43d3faa316f1c5b34e7507d24204579a16484b11523d6b92e13b584b7005d239533b49c489b81c8e93f4014c56d962a192f644a4ef5e0016b87d34414d7bd52deb8d2cdc3eb0eff14768cf583be3947da6350728aba8b909bd6ae8a0a89d5dc81435f66bd5e1a11f429b1f831bd900ab22d8d2531f3aab0f6446704765cb7674794f313e0dbbf79375c6c85f5d8797d84e3b546fee09fc317c0503b95159ca92b0922c348e206d17753a53a232a55ec316bf2fe5fe018536f083d705568ee900273300308de2b4afbf935d6e847dc52fdb20cbadfcdcc938901483ad8958c1bf0ec1ff01a9423b0ad0de00b8f46db910c26dbc456820246a0085c44d9ce273c5cc27e3a3cce4f0cdc615741e2a89468d3fdffccc9c5804464fede78d00be1a9a0c77c7086e82c164c7a0078635114cb531257aa8b4b54e2a2b2d51451b36ab035f1b72992dfa01d1b107a898b0ea84ff155128417948321aaefc37caabe41017ec9770e96b8a2b16296705727d23f801e7809c88a0535b3d02a5a03af18a4225a2c37ccc94a1f90fe3e460d886a5b9e1615d530c03142c0c537349b5b61d8231e0baba1f97affa7e345e8a27aacb5d95575a187d44a952e4bdf83aeea9dfbdd96d1d7baf3849b1494d408fb67191b2a3348aff78fae12e28e4dc0415b22bde46fa8bcadaecf966fb583c2c59dcf8f0449c5374d2cc3396621f6558998c0508c5d878922c1546f09db97b20e039d4457495fc06914b0b715a57a0a4c92c21db14f585e8c534bbbb09b22ddf8b2969f9eee510584629555501167268697d2e805a0a88e56a08a1b2bd07a81a9093625ebb13cfba04d2062581cf7970bdd4f085e170a8e2532329605359a8484907146b529cfd2046210b51df3debed11e19dcdd6f30861cd0dbf7863cd0455124b046e9b23aa62492d7e5c56fc13c71404437489e8e3fe5d888bc0bd6776c889a1542d34ab9d2e225b61b229a9f9eae94aa26775a8b7e8e5948035da924834d5a31efc92c3228b6d296ce9c7694eede2b1f8b584810c5a0917c860229c762cbd91097725b51e8d05c2c9034f4257bc4c1e41ff02938e6dab0f8deff0f235337ae0cf773571d968b7c32440c515d628e29f10a86131f09a34717df8d0f876cc48c36b179b11e45516fc8f39620d1f71378feab2f2891dd9166652defae77769c8b680144ab551267f030863072d4a7267ce62739d796f321eb08d0beb6d2c760756d0562bb95f9411880ad5bd5f9990a439e64d8af52805ce704ff3a476496e0ec6a743fe71efb918feafdc9706727edf1e895b9582d4d23c397c239838b3441f6623223120f39cb0e2c01366c83353f5f1d780c61e0ad6dae2ad503e20f148778ac0c9398832781f1a71cb1ca19472a88309d5ebbf7237b75317d1505d7efccdb9eae60efcaf17e93f0b226614fdc969bd7dfb86c0abe0aba9e5b1d358ec87e6c64f67ac3e1a4da8b2c4ebadd033d05f4ec70845bfb5f51d083753343833183ceccce91040dfd7ee6f7d64a8d202ac2a7d62c090d54ba48c964bbfc8034181726ba52ee4e42860c63afad98cf1b4fd5efaa6e12c2371e035022224a5078bea479311ec20b56d872a92f40230f74a8d5ab0546c7cb0e0ab98f3113c627f77acf00b4e3e1da5f869aa3417d891766cf8a2a7f7848625c036ff8e7e8a212a3cd4ff3f08db33af2864227467b27990418149747cc6335aa9d494245e6909d44e85c46a142ec661c647ce6fdd79054601e622e9bb895ceea68ce561422e973266677102037f0a7deb1e18aa75c367c939a3c66e54bbd8f34e53be7909ba83816d05ebb8e7ee9e7dffc94d60fabe1158925300b018e0e8544b53e0968c99e5bb422bf89aed8bb157eb4cc484715ccc177d778ebae4ff4f8051e19866c99b8e2d1dd34873bd269b55880ee4c3e8a3a2c3bcfd739d5896a89718f4bc68aba1443cb04f8f5f9b4a56a9950df8e7b59f899d34a31e7af3f515f6f821dac02dc011e8d8100fa692381a9ddfa241b98e6eff052f8539ef0f3c6215fb287b0fb9b04f3fe1eb012dd0594d39abc2f8f291b017fa581eda2f701a67ea1c1800b71dfa760fa888ab4892ab188e007d1c6c1a9e3d856cbb069f505ad993a509b688e61917146df0086ba4e36884eb6ce9c5bf4cc42447a28b019adebe616c1732c9e628a8c738112408d45d5e06bbfd3aca128eba5712a668c302b09932d0f3fa22c2a7ca6099b5fbcdf40808a16e6bf66a43ed44b7e7112a9984e1160c123d919fa082cc5133c61ed2f1f1c24e9060bf60af58bea7e3be979d11857342cf4e9818d7440158ebc335ffd6ed0627ac53a6c5a1df79ec3f14fb738f98a7d42ba6aa5e10abd6ca826bb382cafff5745eed7f6d518822001d5bca2fc7aa3436ef5ba00c5be143f65edeb6433af5c3b94ab7c36ac22a8877febf8ea3ae7e5e57c3833a51f6f6eb336037165051718fb8a4a79dda02f6776738db1b76283425668f18a5cbd86ffb4b7ad45c2033d875717b446a393589647fe1e1a5459f27847db74737c4d11dc6b089d70dfd1115dccb2536acacb93f2f68f8a279bac2fc2e8ec383ae8e3d73088b11b444a5cfdb995aae1a431e912ae4a098661ad9e110e59c4b40bd73108354222f18e17397b5ff6aac1b1b9559a0bf737969d1eb1a4cb9940139de04d690eb9616c4b2b399d53c00370f30491c38397dccb635052080b8cd5ae794b82b321de7a7957a95b65dd911a0f039724fa9eb292e2b00a94b8def45350a1ea8e342fcf54c9ea37cedb3ddd73e56596ca930291d90aa37bfd41643e7077edfb97976a3e5d6a9090301dec23776c6dbdfce0001d7c3f22bb149b9724fde870bd5a8976a735e62ba56bfc84e9bb9d13aab7b20b57ba3bf7527c9087a30350839563853fa72e31e85d84d3c6da85db4bb2988bfd0261d4f4457983c58c17d166264f0643f196268cc891129b5802285d220821cd814a40a83c5fa123cf7bcc356cc565b184f773a9f3b849b5adf5ea688bb9adf3cf0d6cc0ed10f4d0fe6497a5de75a23f0d806aa4ed8a35faffb41f88f1c1414d117c96b22a51c9680a468cb8c5d8e6d9b6d6aa930c0beb598816f495d6ca8476ff2dbc8a0b7f6c6d8e5f161ac7096b4495d14900c212bee3dd87994c6b10bf1d25dd380e4ab07a8d6fad83117b9ff0d0682985616fdc3a6092f3bc6b15279f5a90d8f4abd5c628655cff368b7cbbd45caef38454c2a38534001323ba4e4846e7604cac14cece4d40726eebf303a7ed0c9fa1b90f406c438b073e14af404df83a392ca68266cc213e3925ca81f84217fb0d1c063f8469ad03a32d342633419bb9fb0be998d78ad9b0798b39286cba66fee0ed631c14dda01457e1b5ce7a8b654f8503054e01c9afa691fdffcf6a3e9ccbf42855f1ca6af14fad78347207b00de826210f3ac25bffc1c56d76f48bc02ff05acaecf9be437008f7975381058d49593e487551be946fe1d39f1d036fad2c7caa1bba99039b4aa6f48d5f625d456a3228479f2d6375d5f5220e7fd9ded2ede00a62ac4b2061fa30b2d1c4fde670821e6a53f9e65ef4d3ce300ee053cd29e9e5b6dd69cb7471c240991b83f72b74219c9a8f06089998433239d58b5a8e8710ac0d79f9ea7881d319068714eddd9457e132a6e7d52801683cfd806b5d4db58995a00d8aa72826aa1b3776707ac67611e08d3534febad800de35ad736cf7ed60a7fd583db3163fb3ba778a69b4bfab2d555f4bb2360aa9fd626c33c8bfddbac56221e5b503780a7713bbbc65e9a15b57c6c9670143463777cd3c4d4f52551d5ee528305606d5c951afae0458c7c5317d5a585295e53a2f35dab8481f892a056b6ef98e11ea869cce8dad365858888dc7d2a6a914b2cb761cdc102e8c77e12100f805300e5409ce8f95315a7bab889c8bbc6a1c13cf5b3a1b17af081a53ec64ecfa9bea803f2ca0aa52df83c50459eb44593d47bb392720612054eafba6094cf291a501b56fed109e0b77ef28770b041b29c0133eb5b12d48f9fcee367e028bc817401f5acadca43f29ba043c4260102c0eadb7cee18ae7a10f11e60c6bddc9e615a2ccfc6d0f955840d572415bf919b7d5cb68f2603cbd7bd24b83958df0c4138038dd16155e244d14c1bde1182ad1f14110f882963712c356336d5ae4a2e0c73dda45ac0f5cb081d2af1ec045f1af969705b1937683ed287346a44525cc9e8abf810f59361726d2d47b25d77d90df6fd7bf0b1c3adf6ed14f0f47112f77755b49983b2cf9d141178db6aa091b6a74f25f2908e09815e2bb0a5648072f729bb6a1a0670454d6cc5c57f4a56d662021aa9aff90e70516f8a88bb7aa3fce35df9a6249112e211426956e6af955b417b1bb21393583f8265e2d30129cefa8952a1a923e388394f671dbb73afa74578eaab311cc43bb885faa6fd692c82648c6d80a3d5a98295cf16a9dd4ba8c6bf605b57f2c136794cdf1a1148e85f830ec3a260c83749797c03bcfe2ebbcbe357c9f69a26e7f9c45b0c550b72575d490a3506b34155a265edfefe87543d8dbedc2a4f95efe300cde7a6a4a7541ab8b9b41f9ee5c0461e9f14cbdbb0911d2d171962d286c195c8ca9412019e95e2af25cb7329f264c010c51c0fb0a0fe7e7c6cd773d78b928c8af485eeb5fe872c20c811e1208ea4b6be7e2cdc5cd07c79f8dd468ba012311a3e1bbb9757fd5c44f95af9fe1e76592871b2b17a6db660d6c5de3cd4e748727cbc237781c501af1d2bcbaefde092bb5d0f06e1c475ba86d5d138f987e098dba345e64b9e83fd0ea8124c5020bd22e41cae7375aa115bac74de8f84d876c0e94e77454a0f78ff5bcac592b480a9387edfb3af40b463c85482d707b62c5b27a702639ae478c7759e8e9f6524d38bb5a813c831cf36428b0dac15bfb1527f2f341c63c135cc01b2cf43838390c838ed381d37f3159ca1107125d4adf6fee0214707fa400270c533d51b50488dd93a5086124deb40c640f9f798479f01502f5d2c5ffff480524a37741cd7616ff46d78c0710c392d22b83e5e111657e676c393efc8fbf490bb313ab30d33b443626b8868691a524e7a568d8b7e6615f2025ccbfe779c7f71c89a5065a598de8b7ddc1f71367b5ff4bbbf6d0775f903d11e0b7b72782eecd78f0cf63fca3124fae965b89f772a5491675a43570e27a68d3785e2627648ca95174c32bf94e5732749250ce384485ab8c8f5e529ebbbeaba29e9a560b7b541dd561d6c5950efd0fd86ec11848d9e791c2e3fd080964727efef0e30f6e48a8009e3dfb99452fdc3fed6b17173addd7166a8991b1a99c19412388c1090894da822d1f207dffaf357b9fb5fd91f1d58579bc773b7855432c16a3ed225f7a7c60bb172a1eb9135d3dc5ba582d309034a55023ee15e11312c7162841f17543c7564e70162e2ded9408eafc82c09415cf44b35ff6710cfbeefb556961efb0fd024a48c0f14212995e719d2965b1ba9bcbf3aeaf9a96f2d6f5c30ee95b4eba644e31fa5d0114548b3355af8ca3196022500597eb2ffa82fa05da76252ad710ebb01500eee49f373c6d64d43b4ee67aa333467e1f9ded93614ca93b0e5405f42efc19ada67ff8c0c6d6582635bfc8f11277f9d1190ea4910943f420c2e70eace277b54f45611f115de95c754616d9b46a2d6fdf9debbcc85fa76b1662c43bacffca7b49227315fa0bd67e5c665a49a4fe6f74cc8a6b1c4b949095a24a4917f66a15ec66bbde22cf63dfaa4b2952769ba41f896baebd38122d7692988694a76106bc49fe29695c5272cdf3a062ca258c5649f7e217c90bd74b3ed47a0422bf8979514fc2bdbd1b300ee2e2d69a9923b1aa7f6753eb517321a9cd4ae48174916915517c5e78ed64294477fffd0e4e2d770b46adee62c72d234d4b19eb9093d955b2f366af7dcabe787cfa2a7d939de878f98c8b2ebdf4221b8327224a8412e8663dfca67e282391a28f9d2a149edb645433accfa9ff25e7113a426f61e655e614efde978a09f8561e5a626153826d7a5c9defab2eacae3cce3b0129370ad91ceaf2e30c0c8d4d68b9dc10415899b9a3c1b56878f3426edfff9ebba654434630152195efb0a77234c386b17ead08e5a2912c0c6313a12154a2d2621ae27778e9a21fa1fc4400a3f751a3b69b936937c855e316c17bdd2ebc06960dc5cb0d784447c18a3f4051c03a04a1339f2a359a14d27bef44446287b54385a4f20ad7221d8194b785e0a1b0fdb0273a62d3f8af1471af762fc4d7a0bf37e352f7879a17290f4a7e4c107cb0a33c560f07c523ef0242d050d891e6d9979df59ca12b0eb196bf8416d4e6be3ba28d14102e0b05dccad4c78485f2a5fd16a78872ee62b68f633f26bfb1ed8234b7d1de9ee436730aaad58aaa4fdd4bdec52e81b2c662b7826c0a4199997039d622cbf57b72d0baf5a590e821bacf428fc953978117dfe6fb1471087f5058185497b1280910eddc4d7f6b3b921b9573aadfca0c4717dc0a2958a6254026d24bb3e1c7b6bba71d6b9eb326e7c48d068b0f07267c7524531cb5b81e69e0b45a172f6a123d05f94fdea04ec8b3f9d16bbaf11349d88169f262515b2ae1eb80372ed125afa9fa3150656f1e587acb1c65cef26c550d13021cf744ece912efc43320cbeac717c7542232b5c108c752b423cf1c3be42791fcb191a55b752cdb868a90c53ac878974031ae729a83c597339f0bb2d0a44237973162b868f281dbe1c8fa68bc773f3dcd8be61a86fea5bd3612ee78f1ad4cca6c6a510f652f97a7ac6adb7bb104120b6602cee802bb45bbd2e3853c3b2973f1a9daf8a1f0591f9fcf8cd87927cd650b31f744ae1e9bc7bd844c2f845015053ca9a5cbbe2efb39f8377325974ff8f3d109b58d0ecbb23b5abba97bffbc8926d90be27f708b6772543ee9b974a11b111cea04aa5fb368523e9dbb6ad314bf6f5393a0308cf145c6cf17d197544d3ac865d60dc4ebbaced45167397fffd259263131722e7013555b2c1229b16a675e82fbfa26dd9b35f7397e9fb034a43bffe3fedcd70c0681d2d393c078c6c45f50fbfa466c1612749b4b7719035361cb691a0e39a6cafb5f9cebddb9d790c3e0d359f9fcb83c32b11c545fbf3f2e09355f34bda3f98107a71d04d39219885b90ecfda9bf81c00cf6533d3be976c936ff89cbe70b27b67c76fa66a41b0a2644d9241604bb365a4aa3332f2813ff8fd6883303f4d4f6725148bd86f0a8331b02701d3eba0a252e57e283f13f42cc02ae38fb5dfb6930449a9abeb9277903cd5a3f3a07b28d200673676a55dd09f87403ef567fb65767ca529893e0c275d9a98fdb282b650abfbe7400d70750da7a3472cf9153fd3c3684de6b24304d99818fa1b3c7677231289460c9a2163091d9b9b44644166d85e0526c74cd8453d228ef9a5ec0bc4ec517e396c13cc3e93c55dda41bdc2ab2f596dbf949b23480b8535435a08a409b7c60875032f05a5e95c65a6bc8af4a557c2fc3860a384e655a82682bbb4c430d0211aba501b36d2d6e402a3dcf7114ec3633354f02d567ae75a4cc7292742b3e99d3002363d8d395493d7dd38f6997dda03011639734dd6ece9084f9cf801b319cedd3196929eeefbb9a414d414738d4963d1ff3ba45eeaec211aeae6a0c06630a43f2ba247ad337764fbe990f7eec14aaaf6204a7f9360a7baa10e542a0c8a9e4d8c521642392dcb1ae5e56d4ba3373208f99def28c2a46fd2ca7372f836fbe08eb994b71ea0243d77cbdd981520c4952ebe0d379bd18e541dc70751d4f97cf05b47df268b9ce2677c26b0012d865e9b02aa71910d614aa030372bc308219dc3024fea03bec900bbea5f81f320474fc2d6b30d54fbc684f6d57f413150faee5e721a6f8a94239291083165b37fc83badae83bdcad5855e5a5ac1123dc28be1544a4ea7269abcc6847e50de756b20578ad937a2c7e9dacd437b7bca5bd2b0a66f02441e7e4e74396a9a4cd125377585aa69be26b82ce8e15aafdf128889ab13d95d2e7748a4a00bf84b309f29380708d292f3628bf2f34395f4b9ab2ceb7ea8fdbaf4e46eda068aab9ea50f4ae91282eb82eb65f3362ca71f8fbe3cb9d20d4474aa724aa1738d139ea23e32364054b4112eb642b27c5d56f78ce252395f083de878c938717e78e5e1c8b2657ac455c7ac8dbc5c5125e5f1418406faffd58777512ef98d4e088fcc9440607d747742f1ac1471f59f75d8f6214255d3a6064df49595c554a21ec30ab76a2791f084c68117f87de8a11b7ceafc306492abd7287a2a4bae9bf8a3c88e5d4a68925e4e844023133029bd182beb0f5e1d7102c02d2d3bfb06431d012c1c936cd96940f54352aa8e6f0dbe91e9812ece0cae8a9b31dfeb1ea01e9ee5eab241529ffa98336d9d7b3cd966c9d9259634c0d80fefb5a53a2d65974fdcdafe022aa4127c3cee84619ce716e10e043c2462c838f0e495a4ff4c905b08c96013e54ec659a2add9e25288657f8299c51dd25f597eccb9c3a9f470bde5a6d97c3fd5ce9566dd4a07501e951eefc9f2b4cddf228a73917f67e9586d44220f4d4014eff46ba627bf0d1a9252dd8080f1cd76b129f0826ea9d04e3597e8f84e5ccd795482c3ccaaa29d30c5bd644e7802ef1a5d3449295742b0774af8165f2041b09960c57962ca63e37e5fd3b2db8b622a825c69e01a4094f61f8a6d6da8ba714ddd41539ae3d72d5cd3a61223c78a8ae996a070fe88aa219787266f0398fca55f036157fabefc8b5a3157c83f0924a9b69ae914f6c4494c72179476272e18a864cc552a904d3324b21db3fb3c606d435671db8fcaf36326b04c13b85a8ec8445bea4568c34ebd86284b282fd5ccdc24c2d6912211e5f2dba1875c65dd4605800b2ecce1a6678978c8eda4b86b26d79f02b74aa215412251b22d7d8d12334e26a67088511a7fa91419076706179ab7c0a9b93c88bd6fd12d9f9a9ff9c78b8c1ebf6b4d4a38d76fea8f73567be7a43f85569f32ec60f14421289a3ab8cc36e8f9ed9e6ce294d62f662114b396d7a0ddda0bf8e15714788ca8f55a1fb673173bddc5cf5351d19d3e94f66aad04a8d9b5900df3b15c3e266d89d3e8d915f9b631e847e593e48bf39c59e578be263eb04155241628dd82a5bced58efc1daf52d60ca01f2145e99542c53b1c8ffd912d6d34659033c6d973b364913efe22c1928ba65c39719f27539929bacc1678f5ca6c99e28992219e5ad8dabbbdcec629ff27b7adb955f16a6ca8c4d8c074acfd8eaf6c581fd764c9d51494a29d97961d4fb72f4ca80135b4bcd5ca8ff661112e96eed416004489f7979cbbc075f78452ead52d08883bbc70c42af1887cf89b310c61b3d4f117b2ecb219aeac899f742ee0d29f3129dbf8b0e1b3ffac9086530f5676350255f3390645e2a982046477e28b098f8469c0b8e93044c3501196d68e1e38451ce07b2a61bc8e4ee1419f6587978fa86e200292e36d0acc24865e0914d29cd646e177dbc16490ba47dd2cdd9c1b44a4639656361f3cf8978477e3e1324a0d7d84b1bbf598b2ed186cb7cf5537cb3e0abc01c596c41bad92e888b2e4a18bb76ef0269b4bc14bb0d847fe8fc089c3140356075afacc3daf029b4e7070fa0df4433d89a9c2dc2972c01d205048d4f8531368f561821ab3beee396f6543b57fffb7f0aba5a458ad3bcd73cceb714542ce5090e8937bcc004a470f945d0eae60300fffc7bd0981f12406ab77450a8b99c1f204ded30c4c7777c258cd075c640dcad6d15414ce0ab97ec70e0bfa59c2649e8ea6988c162d86a8bb87ff95808ffe4faa1dbdbf3d5ca18f59469d8d162cc46721d485b9c10283d43ab5f76349075e4afee7614a9acef97478cbb54f36f45ef042b44e57c631721ee878ea423d38b61426cb35afe417f1a407ffc97cd385cffe047c17b52434f494191ec27fc0c082f2267c5497f894baf656c926a29fd4eed4ec72285f86f56a475bce4c2eb69c4b52b6d3e01da0f63119c06115169c2a52e3e7e5f6fb96026a9f3e7b3d39780ffbb20357dc9d98294ec145b485e3ffe8dd394acbeb815ae5447350b354301630fd348e8c5526089dd248f59076bac821376f2568739f7a2ec3555583d7d596b98f5222e6085b41f8415760609357eea89bdb0b3ec7e7ec9309df509238def048e3255ff4d3f672c616569c824424f39ceb07e524deec365b5392a2cd37ef2acb7e09c7e87d5d041e9a76eddcd82c00a4c94009c357e0eaa185fd426fc6e4d808e070c43bf84675962c83144fce194a7d72056b021e08816ca6fc3164ffa1a01a09479211cdd172696c5a82617116b6345ca51af0451bd964e3a7f78104b9148add3ff5346648e97d66df48ff62ad63d3e539fd249d9e64eaa91b805a4b2749fc5f43ed3abc6281ee694f4e3d5401900b4e1f52184ca9bf9d47ee7f875c42feee9636f0e0e40678b735ff1ca8106d51846ee0103c6b69cccbbc9fc8a23b13a20593af1ed5a9591c776b200c433734e0028b4391ec256a021018088f13989eb038f41e9e09fcc0c2bab2eb161c57d8dfede874e9c6150d64d5f72cfb2b05cb4704949ed1de9d6c55b6fd13edbe16fc38c00d629472772a9ec734919d5f29c1019b9616b6ea3de3222b9075e5ffc619076784f212df0fc2be85452cc445aa3fb769b9f1c4626193866c58f5f849e46a3da5424bade4071afb9fd7b3d0af9b88a864cfe4a0262109d55287d05fd35d969481600e6e026104838cd32e2a79fc4751c04b5d667c73ad79984af22fc9d17e48fb5e7c0fe714ed18e2abfd007f0f56c2b1408a78bf39e7c300d4fadbcfba51cfc47012dc65215645ac2e3af09cdacab2f7e8e560823d53b52932646c942c7067e6b7d41a39ea26723c7dc6215bbc043ff6500a3837417252316a745c4657c00c6eace1d0e5e2ff320dd44bfa0e061b1cc3d0aabe9c6f5c26bde0fe048d252fcf815deb22d82a75f97b9e341a70fae2a2c65162824f0646ff7a19f9ae1794a1d5d5537bdc311cd7e27f7bc5bce22fb5688df0768087dbed843de0ab658ce2b8556ac831bc21ac02dc40b4721351a80e62671df94e8ce4cb1f8a377f90ad4c4f0f9fbc40e88ce03b77a8f3a791aa3715a160e2e25ee89f816e2541e27189e0949f11426db1f528aa5fc998fb2ab6d1548ca308726fd82380aaf54567a5041f7e5f708c36955c89bee4f856c027e3096dea7b23a7f7a2223d069c126fb82cda88ca68fe9b4130c0fd515349bc42743e58e214c2876f6965b732f2483325cf4f3212c26b79de52a62540f902ea2313b7412e76659b13ddf8c1f808c6b516b7d234b5df0b67c9bbcb9c4592bc1565664419a2434bccb5d9f350e503a8deb4ab7a6883de83c5762a229df10e80f2f3cf127c1e703567c6aa8477f9be3d67cedb96e675f060abccfb4660d976bc410c3a1ea03c2126f9e2f51552148b7ea308a4fd0c3f6306f1e625b71db54ec818e47f569de2af2a74be3f2267a42bda311da2aa3a3e1a43293c5515af0b88a715267ce68d1ef93566f08221ef7ddda2a94945375442912e72b85ca6565e6bf66e0d97452e71921cc60d9cf7ccbc4f42e2886d4eca25f385d1e7b9f8439c775721f416d2ff02b880126cff4e64093c7aafcd17a119e9b0d551a3d94e08b7df58dc0895f64e2871e5cbe81c8896e3f25aa360dd3ee00f8d488a1909284ee806f7492ca32b239982d6cf0a4bff149e955a4d846ca475f032a6d76de5d8ff9d1098b41c7d305523a72a60045a3339e737f630f0da75e0ca818ad8e8af4f42a9e581ed60430fd005476a83f92db3018a37dda497396024121c1a8fab10a3650e987dcb5dfaf3e612daefde808169c16bc3cee9bd68a766ae2a351a275c3fac28e4c508da7a2e2a011e0a472402cd59ec3538593c06080f9ffc68d70af1c0dc075f75295b0a3a4ce8ddc0d30bf150d51c3d4281b1200d6920a0abc8324ae1301894253e9332ccbb43d1aca215f922750ed0d299d8686a9e86c15bb4adc47fceeda34aa5dc82b92542e2b1627eb672bdb28caa325b7d36e7244d2fc40d482a80bf97b481aec2eb81e85fc0e4587ce4dfb3cd5851cba453a9224b5b80a7f6dca290f50bbe7a6dfad38b4b8a5ecbd07f36bc19ca3abe8592c6427c72033f677156793a5e604f28bdf0a164b4c424dfd087ebfbf79c08851d91214532cf193ba4514d164eda55746f34f78c71f69a3bbfd12a91c56591a709348f1d908f87e6f1d82da6afe72e789cd4046e0e657a853e16d7281d79302de6cab73fab0d595b2c417970915b5dd1ff70e4596edc5f3e939243e3109459e1082e280200487b3e990c3f4686a6d936a708eb182cbcc292dca5f402e3649c819fc3197256d201bd5f0f52000dccbd3d65a2923a2e40b084cf019b16b7471366bd054e635da7e7adc47fe6a1e86e81fea0cd5031297073efe7de8530c3235d639da3905fa240312eb23118fcace6ddc62407364a129def9b3d0178a95d92bef4b5d8be6dff9c37cf8cccf3a0ab2a4700f64339f81af44094f374eb81ee0ee7d5b7eec83f4522954cba0d24d32cca8b7eaac881c4b935a51bea64382d3362852194ef6373a6c7010a615abfaf26074bbc77c1aef09de0400262a2d30525b344ade143392d8088f611f806d11ab9a05fbbacd50d4e090d61c7cd4a524aaa97544805e0dc4a67c98f9dc041ec1280fe2e5f743060b4aeccac3851ac925692fe272eac427877710533968d9f7ce7920c04c676006433af12bde8dedf139e73362dae428f34caddf03dbdc78b0d5f7863688d18dafa2029ae56bacd6f387feb6a5d6286b5517d5c37b7970d380897edaabdeda186d59687236dbfb0d6e5ad733673a868175dd838d4e0b2b0bd9d158e5044dbbb2d6ffbec8e6a055a3687ecdab83ff483c87045a4d26534768107f802efc794a08dd56f6377cccbf0d76adeee7e6efbc929064b10ed83d69cb0494914370ce1bb6f40a2bc9ea7287950f367c5fe3ce803666bb8680c4a9e7421e7eff905bef5e8ed4c37560945f37fb8130c8f362227aab47b762253953537445eb5a0cc52e195deb920f0b8435abdc4b4a3</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>排序专题</title>
    <url>/%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98.html</url>
    <content><![CDATA[<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">


<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123; <span class="comment">//选择排序 //超时</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> min=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;nums.size();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[min]&gt;nums[j])</span><br><span class="line">                    min=j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(min!=i)</span><br><span class="line">                swap(nums[min],nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void bubbleSort(vector&lt;int&gt;&amp; nums)&#123; &#x2F;&#x2F;冒泡排序 &#x2F;&#x2F;超时</span><br><span class="line">    for(int i&#x3D;1;i&lt;nums.size();i++)&#123;</span><br><span class="line">        bool flag&#x3D;false;</span><br><span class="line">        for(int j&#x3D;nums.size()-1;j&gt;&#x3D;i;j--)&#123;</span><br><span class="line">            if(nums[j-1]&gt;nums[j])&#123;</span><br><span class="line">                swap(nums[j-1],nums[j]);</span><br><span class="line">                flag&#x3D;true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!flag)return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.size();i++)&#123;	<span class="comment">//i代表现在要插入的元素的序号</span></span><br><span class="line">            <span class="keyword">int</span> j=i,tmp=nums[i];		<span class="comment">//</span></span><br><span class="line">            <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;nums[j<span class="number">-1</span>]&gt;tmp)&#123;</span><br><span class="line">                nums[j]=nums[j<span class="number">-1</span>];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;            </span><br><span class="line">            nums[j]=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;  <span class="comment">//希尔排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> grap=nums.size()/<span class="number">2</span>;grap&gt;<span class="number">0</span>;grap=grap/<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=grap;i&lt;nums.size();i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp=nums[i],j;</span><br><span class="line">                <span class="keyword">for</span>(j=i;j&gt;=grap&amp;&amp;nums[j-grap]&gt;tmp;j-=grap)&#123;</span><br><span class="line">                    nums[j]=nums[j-grap];</span><br><span class="line">                &#125;</span><br><span class="line">                nums[j]=tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">random_device rd;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> leftIndex,<span class="keyword">int</span> rightIndex)</span></span>&#123; <span class="comment">//快排</span></span><br><span class="line">       <span class="keyword">if</span>(leftIndex&gt;rightIndex)</span><br><span class="line">           <span class="keyword">return</span> ;</span><br><span class="line">       <span class="keyword">int</span> left=leftIndex;</span><br><span class="line">       <span class="keyword">int</span> right=rightIndex;</span><br><span class="line">       <span class="keyword">int</span> index=rd()%(right-left+<span class="number">1</span>)+left;</span><br><span class="line">       <span class="keyword">int</span> privt=nums[index];</span><br><span class="line">       swap(nums[index],nums[left]);</span><br><span class="line">       <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">           <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[right]&gt;=privt)right--;</span><br><span class="line">           nums[left]=nums[right];</span><br><span class="line">           <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[left]&lt;=privt)left++;</span><br><span class="line">           nums[right]=nums[left];</span><br><span class="line">       &#125;</span><br><span class="line">       nums[left]=privt;</span><br><span class="line">       quickSort(nums,leftIndex,left<span class="number">-1</span>);</span><br><span class="line">       quickSort(nums,left+<span class="number">1</span>,rightIndex);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>非递归版</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> len=nums.size();</span><br><span class="line">       <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">helper</span><span class="params">(len)</span></span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> seg=<span class="number">1</span>;seg&lt;len;seg+=seg)&#123;<span class="comment">//seg是现在处理的区间大小，从小到大</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> start=<span class="number">0</span>;start&lt;len;start+=(seg&lt;&lt;<span class="number">1</span>))&#123;	<span class="comment">//处理seg大小的区间，从左到右</span></span><br><span class="line">               <span class="comment">//(注释s=start) k是总区间现在的处理序号，s1是左区间现在的序号，s2是右区间现在的序号</span></span><br><span class="line">               <span class="comment">//初始化时，左区间[start1,end1),右区间[start2,end2)</span></span><br><span class="line">               <span class="keyword">int</span> start1=start,end1=min(len,start+seg);</span><br><span class="line">               <span class="keyword">int</span> start2=min(len,start+seg),end2=min(len,start+(seg&lt;&lt;<span class="number">1</span>));</span><br><span class="line">               <span class="keyword">int</span> k=start;</span><br><span class="line">               <span class="keyword">while</span>(start1&lt;end1&amp;&amp;start2&lt;end2)<span class="comment">//两个区间都还有数，选择小的放前面，直到其中一个放完</span></span><br><span class="line">                   helper[k++]=(nums[start1]&lt;nums[start2])?nums[start1++]:nums[start2++];</span><br><span class="line">               <span class="keyword">while</span>(start1&lt;end1)	<span class="comment">//如果左区间还有数,全部放入</span></span><br><span class="line">                   helper[k++]=nums[start1++];</span><br><span class="line">               <span class="keyword">while</span>(start2&lt;end2)	<span class="comment">//如果右区间还有数,全部放入</span></span><br><span class="line">                   helper[k++]=nums[start2++];</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="built_in">std</span>::swap(nums,helper);		<span class="comment">//合并好的数放回原数组</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>递归版</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">       <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">helper</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">       merge(nums,helper,<span class="number">0</span>,nums.size());	<span class="comment">//左闭右开</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; helper,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(right-left&lt;=<span class="number">1</span>)<span class="keyword">return</span> ;		<span class="comment">//小于等于一不需要合并</span></span><br><span class="line">       <span class="keyword">int</span> mid=left+((right-left)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">       merge(nums,helper,left,mid);	<span class="comment">//归并左半部分</span></span><br><span class="line">       merge(nums,helper,mid,right);	<span class="comment">//归并右半部分</span></span><br><span class="line">       <span class="comment">//(注释s=start) s是总区间现在的处理序号，s1是左区间现在的序号，s2是右区间现在的序号</span></span><br><span class="line">       <span class="keyword">int</span> start=left,start1=left,start2=mid;	</span><br><span class="line">       <span class="keyword">while</span>(start&lt;right)&#123; 	<span class="comment">//直到处理完总区间全部的数</span></span><br><span class="line">           <span class="comment">//当右区间到头或者，左区间还有并且左区间对于右区间满足条件，辅助数组放左区间的数</span></span><br><span class="line">           <span class="keyword">if</span>(start2&gt;=right||(start1&lt;mid&amp;&amp;nums[start1]&lt;nums[start2]))</span><br><span class="line">               helper[start++]=nums[start1++];</span><br><span class="line">           <span class="keyword">else</span> helper[start++]=nums[start2++];	<span class="comment">//辅助数组放右区间的数</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;right;i++)	<span class="comment">//合并好的数放回原数组</span></span><br><span class="line">           nums[i]=helper[i];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.size()/<span class="number">2</span><span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        maxHeapify(nums,i,nums.size()<span class="number">-1</span>);	<span class="comment">//初始化大顶堆，nums.size()/2-1第一个父节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.size()<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">        swap(nums[i],nums[<span class="number">0</span>]);	<span class="comment">//将最大的换到后面</span></span><br><span class="line">        maxHeapify(nums,<span class="number">0</span>,i<span class="number">-1</span>);	<span class="comment">//将前面的数继续堆化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maxHeapify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dad=start;</span><br><span class="line">    <span class="keyword">int</span> son=start*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(son&lt;=end)&#123;</span><br><span class="line">        <span class="keyword">if</span>(son+<span class="number">1</span>&lt;=end&amp;&amp;nums[son+<span class="number">1</span>]&gt;nums[son])	<span class="comment">//找到儿子中最大的</span></span><br><span class="line">            ++son;</span><br><span class="line">        <span class="keyword">if</span>(nums[dad]&gt;nums[son])	<span class="comment">//父节点已经大于子节点，退出</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            swap(nums[dad],nums[son]);		<span class="comment">//继续往下堆化</span></span><br><span class="line">            dad=son;</span><br><span class="line">            son=dad*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><p>注意不能处理负数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxBit</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums)</span></span>&#123;		<span class="comment">//找到数组中最大的数十进制有多少位</span></span><br><span class="line">        <span class="keyword">int</span> maxval= *max_element(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(maxval&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            maxval/=<span class="number">10</span>;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k=maxBit(nums),radix=<span class="number">1</span>;<span class="comment">//radix基数，1开始，个位开始</span></span><br><span class="line">        <span class="keyword">int</span> len=nums.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">10</span>)</span></span>;	<span class="comment">//十进制数每个位10个可能</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">tmp</span><span class="params">(len)</span></span>;	<span class="comment">//临时数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;++j)&#123;		<span class="comment">//有多少位就循环几次</span></span><br><span class="line">            fill(count.begin(),count.end(),<span class="number">0</span>); <span class="comment">//处理新的位时，将count数组置0，重新计数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> num:nums)</span><br><span class="line">                ++count[(num/radix)%<span class="number">10</span>];	<span class="comment">//每个元素找到自己的基数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count.size()<span class="number">-1</span>;++i)</span><br><span class="line">                count[i+<span class="number">1</span>]+=count[i];	<span class="comment">//将count数组的所有位叠加前面位的和</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)	<span class="comment">//从数组后面开始找，保持算法稳定性</span></span><br><span class="line">                tmp[--count[(nums[i]/radix)%<span class="number">10</span>]]=nums[i];	<span class="comment">//从count数组找到自己的位置，填入临时数组</span></span><br><span class="line">            <span class="built_in">std</span>::swap(tmp,nums);		<span class="comment">//将临时数组赋值到nums数组</span></span><br><span class="line">            radix*=<span class="number">10</span>;			<span class="comment">//处理下一位</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>处理负数的方法</p>
<p>思路1：这里将负数处理成正数（所有数加上最小值的绝对值，不过可能会溢出）</p>
<p>思路2：将负数和正数分开，负数处理成正数，反向拼接到正数，（未实现）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxBit</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> maxval= *max_element(nums.begin(),nums.end());</span><br><span class="line">       <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(maxval&gt;<span class="number">0</span>)&#123;</span><br><span class="line">           maxval/=<span class="number">10</span>;</span><br><span class="line">           ++count;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> minval=*min_element(nums.begin(),nums.end());</span><br><span class="line">       <span class="keyword">if</span>(minval&lt;<span class="number">0</span>)</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span>&amp; num:nums)&#123; </span><br><span class="line">               num+=(<span class="built_in">abs</span>(minval)+<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       <span class="keyword">int</span> k=maxBit(nums),radix=<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> len=nums.size();</span><br><span class="line">       <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">       <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">tmp</span><span class="params">(len)</span></span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;++i)&#123;</span><br><span class="line">           fill(count.begin(),count.end(),<span class="number">0</span>);</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">auto</span> num:nums)</span><br><span class="line">               ++count[(num/radix)%<span class="number">10</span>];</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count.size()<span class="number">-1</span>;++i)</span><br><span class="line">               count[i+<span class="number">1</span>]+=count[i];</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">               tmp[--count[(nums[i]/radix)%<span class="number">10</span>]]=nums[i];</span><br><span class="line">           <span class="built_in">std</span>::swap(tmp,nums);</span><br><span class="line">           radix*=<span class="number">10</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(minval&lt;<span class="number">0</span>)</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span>&amp; num:nums)&#123; </span><br><span class="line">               num-=(<span class="built_in">abs</span>(minval)+<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><p>思路：建立一个(max-min)+1大小的数组。对数组的每一个元素都可以找到对应的x-min的位置</p>
<p>该数组记录每一个数到底有多少个。然后通过寻找这个数组，就可以确定元素在排序后的位置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给出一个例子:[5,1,1,2,0,0]</span><br><span class="line">该计数数组的变化为：</span><br><span class="line">         2 2 1 0 0 1 &#x2F;&#x2F;记录了数组中对应的个数</span><br><span class="line">         2 4 5 5 5 6 &#x2F;&#x2F;前一个元素加到后面的元素 countArray[i+1]+&#x3D;countArray[i];</span><br><span class="line">nums:5 ::2 4 5 5 5 5 &#x2F;&#x2F;找元素5找到6，6-1就是5在排序好的数组的位置，更新数组为6-1</span><br><span class="line">nums:1 ::2 3 5 5 5 5 &#x2F;&#x2F;找元素1找到5，5-1就是1在排序好的数组的位置，更新数组为5-1</span><br><span class="line">nums:1 ::2 2 5 5 5 5 &#x2F;&#x2F;找元素1找到5，5-1就是1在排序好的数组的位置，更新数组为5-1</span><br><span class="line">nums:2 ::2 2 4 5 5 5 &#x2F;&#x2F;找元素2找到4，4-1就是2在排序好的数组的位置，更新数组为4-1</span><br><span class="line">nums:0 ::1 2 4 5 5 5 &#x2F;&#x2F;找元素0找到2，2-1就是0在排序好的数组的位置，更新数组为2-1 </span><br><span class="line">nums:0 ::0 2 4 5 5 5 &#x2F;&#x2F;找元素0找到1，1-1就是0在排序好的数组的位置，更新数组为1-1</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CountingSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// int maxnum=*max_element(nums.begin(),nums.end());</span></span><br><span class="line">        <span class="comment">// int minnum=*min_element(nums.begin(),nums.end());</span></span><br><span class="line">        <span class="keyword">int</span> maxnum=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> minnum=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            maxnum=max(maxnum,nums[i]);</span><br><span class="line">            minnum=min(minnum,nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> offset=maxnum-minnum+<span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countArray</span><span class="params">(offset,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)</span><br><span class="line">            ++countArray[num-minnum];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;countArray.size()<span class="number">-1</span>;i++)</span><br><span class="line">            countArray[i+<span class="number">1</span>]+=countArray[i];</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">tmpArray</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">            tmpArray[--countArray[nums[i]-minnum]]=nums[i];</span><br><span class="line">        nums.assign(tmpArray.begin(),tmpArray.end());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假如对数组nums进行桶排序，nums的长度为L，最小元素为A，最大元素为B。</span></span><br><span class="line">   <span class="comment">// 则gap为(B-A)/L+1，桶的个数为(B-A)/gap+1。</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> maxval=*max_element(nums.begin(),nums.end());</span><br><span class="line">       <span class="keyword">int</span> minval=*min_element(nums.begin(),nums.end());</span><br><span class="line">       <span class="keyword">int</span> gap=(maxval-minval)/<span class="number">2</span>+<span class="number">1</span>;				<span class="comment">//桶大小</span></span><br><span class="line">       <span class="keyword">int</span> bucketCount=(maxval-minval)/gap+<span class="number">1</span>;		<span class="comment">//桶数量</span></span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; buckets(bucketCount,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">auto</span> num:nums)&#123;			<span class="comment">//装桶</span></span><br><span class="line">           buckets[(num-minval)/gap].emplace_back(num);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bucketCount;++i)&#123;</span><br><span class="line">           mergeSort(buckets[i]);				<span class="comment">//桶内排序，随意一种排序</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;buckets[i].size();++j)&#123;</span><br><span class="line">               nums[k++]=buckets[i][j];			<span class="comment">//桶拼接</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="STL中的Sort"><a href="#STL中的Sort" class="headerlink" title="STL中的Sort"></a>STL中的Sort</h1><p>快排在几乎数据几乎顺序的情况下，时间复杂度达到O（<script type="math/tex">N^2</script>）。</p>
<p>堆排序的时间复杂度稳定在O（<script type="math/tex">NlogN</script>）。</p>
<p>插入排序在数据几乎顺序下的情况下，时间复杂度可以近乎O（<script type="math/tex">N</script>）。</p>
<p>了解到以上三点。可以设计出一个泛用的算法。他就是std::sort。</p>
<p>具有以下特点：</p>
<ul>
<li>在数据量很大时采用正常的快速排序，此时效率为O(<script type="math/tex">NlogN</script>)。</li>
<li>一旦分段后的数据量小于某个阈值，就改用插入排序，因为此时这个分段是基本有序的，这时效率可达O(<script type="math/tex">N</script>)。</li>
<li>在递归过程中，如果递归层次过深，分割行为有恶化倾向时，它能够自动侦测出来，使用堆排序来处理，在此情况下，使其效率维持在堆排序的O(<script type="math/tex">NlogN</script>)，但这又比一开始使用堆排序好。</li>
</ul>
<p>具体实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first != last) &#123;</span><br><span class="line">        <span class="comment">//传入首尾迭代器，类型，log10（长度*2）</span></span><br><span class="line">        __introsort_loop(first, last, value_type(first), __lg(last - first) * <span class="number">2</span>);</span><br><span class="line">        <span class="comment">//插入排序，传入首尾迭代器</span></span><br><span class="line">        __final_insertion_sort(first, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先执行__introsort_loop，然后在执行插入排序</p>
<p>看看__introsort_loop</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Size</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> __introsort_loop(RandomAccessIterator first,	<span class="comment">//传入首尾迭代器，类型，log10（长度*2）</span></span><br><span class="line">                      RandomAccessIterator last, T*,</span><br><span class="line">                      Size depth_limit) &#123;</span><br><span class="line">    <span class="keyword">while</span> (last - first &gt; __stl_threshold) &#123;   <span class="comment">//__stl_threshold是宏，等于16，说明区间小于16就退出了</span></span><br><span class="line">        <span class="keyword">if</span> (depth_limit == <span class="number">0</span>) &#123;					<span class="comment">//传进来的最大深度被减完了,每一层减一</span></span><br><span class="line">            partial_sort(first, last, last);	<span class="comment">//说明深度太高，调用堆排序</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        --depth_limit;		<span class="comment">//最大深度每一层减一</span></span><br><span class="line">        RandomAccessIterator cut = __unguarded_partition			<span class="comment">//调用快排，传入了首尾迭代器和快排的pivit</span></span><br><span class="line">            <span class="comment">//__median函数，它的作用是取首部、尾部和中部三个元素的中值作为pivot</span></span><br><span class="line">          (first, last, T(__median(*first, *(first + (last - first)/<span class="number">2</span>),</span><br><span class="line">                                   *(last - <span class="number">1</span>))));</span><br><span class="line">        __introsort_loop(cut, last, value_type(first), depth_limit);	<span class="comment">//递归右区间</span></span><br><span class="line">        last = cut;			<span class="comment">//右区间递归完，右端点改为中点，改为递归左区间，这种调用可以减少递归调用，改为循环调用。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看看快排。也就是上面的__unguarded_partition,返回一个根据pivit把左右区间分割开的中间点的迭代器</p>
<p>注意下面的first和last不需要判断越界，选择了首尾中间位置三个值的中间值作为pivot，因此一定会在超出此有效区域之前中止指针的移动。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">RandomAccessIterator __unguarded_partition(RandomAccessIterator first, </span><br><span class="line">                                           RandomAccessIterator last, </span><br><span class="line">                                           T pivot) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (*first &lt; pivot) ++first;	<span class="comment">//比pivot小，first右移到比pivot大的元素</span></span><br><span class="line">        --last;	<span class="comment">//一开始是end，需要左移，后来的是已经交换过的元素，所以左移</span></span><br><span class="line">        <span class="keyword">while</span> (pivot &lt; *last) --last;	<span class="comment">//比pivot大，last左移到比pivot小的元素</span></span><br><span class="line">        <span class="keyword">if</span> (!(first &lt; last)) <span class="keyword">return</span> first;	<span class="comment">//二者相遇，退出</span></span><br><span class="line">        iter_swap(first, last);		<span class="comment">//交换</span></span><br><span class="line">        ++first;		<span class="comment">//已经交换过的元素，所以右移</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>返回来看上面的__introsort_loop函数</p>
<p>它有两种方法退出，</p>
<p>一是</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (last - first &gt; __stl_threshold) &#123;   <span class="comment">//__stl_threshold是宏，等于16，说明区间小于16就退出了</span></span><br></pre></td></tr></table></figure>
<p>二是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (depth_limit &#x3D;&#x3D; 0) &#123;					&#x2F;&#x2F;传进来的最大深度被减完了,每一层减一</span><br><span class="line">   partial_sort(first, last, last);	&#x2F;&#x2F;说明深度太高，调用堆排序</span><br><span class="line">   return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一种对应了区间小于16，第二种对应深度太大，调用堆排序。</p>
<p>两种方法退出后都会执行__final_insertion_sort 也就是插入排序。</p>
<p>先看下堆排序partial_sort。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> __partial_sort(RandomAccessIterator first, RandomAccessIterator middle,</span><br><span class="line">                    RandomAccessIterator last, T*, Compare comp) &#123;</span><br><span class="line">    make_heap(first, middle, comp);</span><br><span class="line">    <span class="keyword">for</span> (RandomAccessIterator i = middle; i &lt; last; ++i)</span><br><span class="line">        <span class="keyword">if</span> (comp(*i, *first))</span><br><span class="line">            __pop_heap(first, middle, i, T(*i), comp, distance_type(first));</span><br><span class="line">    sort_heap(first, middle, comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">partial_sort</span><span class="params">(RandomAccessIterator first,</span></span></span><br><span class="line"><span class="function"><span class="params">                         RandomAccessIterator middle,</span></span></span><br><span class="line"><span class="function"><span class="params">                         RandomAccessIterator last, Compare comp)</span> </span>&#123;</span><br><span class="line">    __partial_sort(first, middle, last, value_type(first), comp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看完了堆排序，这里可以看出堆排序和快排都会将数组中最小的放在第一个小区间中，堆排序无疑最小是第一个元素，快排到16大小区间之后，最小的元素必然在第一个16大小区间内。</p>
<p>了解到这点后，现在要看退出__introsort_loop后执行的</p>
<p>__final_insertion_sort函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> __final_insertion_sort(RandomAccessIterator first, </span><br><span class="line">                            RandomAccessIterator last) &#123;</span><br><span class="line">    <span class="keyword">if</span> (last - first &gt; __stl_threshold) &#123;	<span class="comment">//长度大于16，0到15用__insertion_sort 16到末尾用__unguarded_insertion_sort处理</span></span><br><span class="line">        __insertion_sort(first, first + __stl_threshold);</span><br><span class="line">        __unguarded_insertion_sort(first + __stl_threshold, last);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>	<span class="comment">//小于16，执行__insertion_sort</span></span><br><span class="line">        __insertion_sort(first, last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看看这两个函数的区别</p>
<p>__unguarded_insertion_sort</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> __unguarded_insertion_sort_aux(RandomAccessIterator first, </span><br><span class="line">                                    RandomAccessIterator last, T*) &#123;</span><br><span class="line">    <span class="keyword">for</span> (RandomAccessIterator i = first; i != last; ++i)	<span class="comment">//从头开始找插入点</span></span><br><span class="line">        __unguarded_linear_insert(i, T(*i));		<span class="comment">//这个函数在下面有//不带检查的插入</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __unguarded_insertion_sort(RandomAccessIterator first, 	<span class="comment">//从这里开始</span></span><br><span class="line">                                RandomAccessIterator last) &#123;</span><br><span class="line">    __unguarded_insertion_sort_aux(first, last, value_type(first));	<span class="comment">//传入首位迭代器和类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>__insertion_sort</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> __unguarded_linear_insert(RandomAccessIterator last, T value) &#123;	<span class="comment">//不带检查的插入</span></span><br><span class="line">    RandomAccessIterator next = last;</span><br><span class="line">    --next;</span><br><span class="line">    <span class="keyword">while</span> (value &lt; *next) &#123;		<span class="comment">//边找边将元素后移，注意这里next不可能越界，因为第一个元素比value小</span></span><br><span class="line">        *last = *next;</span><br><span class="line">        last = next;</span><br><span class="line">        --next;</span><br><span class="line">    &#125;</span><br><span class="line">    *last = value;	<span class="comment">//找到就插入</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __linear_insert(RandomAccessIterator first, </span><br><span class="line">                            RandomAccessIterator last, T*) &#123;</span><br><span class="line">    T value = *last;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; *first) &#123;		<span class="comment">//要插入的比第一个还小</span></span><br><span class="line">        copy_backward(first, last, last + <span class="number">1</span>);	<span class="comment">//后面全部后移一位</span></span><br><span class="line">        *first = value;	<span class="comment">//插到最前面</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        __unguarded_linear_insert(last, value);		<span class="comment">//不带检查的插入</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> __insertion_sort(RandomAccessIterator first, RandomAccessIterator last) &#123;	<span class="comment">//这里开始</span></span><br><span class="line">    <span class="keyword">if</span> (first == last) <span class="keyword">return</span>; </span><br><span class="line">    <span class="keyword">for</span> (RandomAccessIterator i = first + <span class="number">1</span>; i != last; ++i)	<span class="comment">//第二个开始找插入点</span></span><br><span class="line">        __linear_insert(first, i, value_type(first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插入完就结束算法。</p>
<p>具体的可以参考这篇<a href="https://feihu.me/blog/2014/sgi-std-sort/">博客</a>,部分内容从此摘抄。</p>
]]></content>
  </entry>
  <entry>
    <title>计算机网络运输层笔记</title>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82%E7%AC%94%E8%AE%B0.html</url>
    <content><![CDATA[<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">

<p>`<strong>运输层</strong></p>
<p> <img src="https://i.loli.net/2020/06/11/8uy5a2vfp1lMSNx.png" alt="运输层.png"></p>
<h1 id="运输层协议概述"><a href="#运输层协议概述" class="headerlink" title="运输层协议概述"></a>运输层协议概述</h1><h2 id="进程之间端到端的逻辑通信"><a href="#进程之间端到端的逻辑通信" class="headerlink" title="进程之间端到端的逻辑通信"></a>进程之间端到端的逻辑通信</h2><h3 id="复用"><a href="#复用" class="headerlink" title="复用"></a>复用</h3><p>·        发送方不同的应用进程都可以使用同一个运输层协议传送数据</p>
<h3 id="分用"><a href="#分用" class="headerlink" title="分用"></a>分用</h3><p>·        是指接收方的运输层在剥去报文的首部后能够把这些数据正确交付目的应用进程。</p>
<h2 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h2><h2 id="运输层的端口"><a href="#运输层的端口" class="headerlink" title="运输层的端口"></a>运输层的端口</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>·        软件端口</p>
<p>·        16位65535</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>·        服务端端口</p>
<p>•      熟知端口号（0-1023）</p>
<p>•      登记端口号（1024-49151）</p>
<p>·        客户端端口（短暂端口号）（49152-65535）</p>
<h1 id="UDP-User-Datagram-Protocol）用户数据报协议"><a href="#UDP-User-Datagram-Protocol）用户数据报协议" class="headerlink" title="UDP(User Datagram Protocol）用户数据报协议"></a>UDP(User Datagram Protocol）用户数据报协议</h1><h2 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h2><p>不需要先建立连接（不可靠）</p>
<p>相比ip数据报增加的功能</p>
<p>·        复用和分用</p>
<p>·        差错检测</p>
<p>面向报文（直接使用应用层报文）</p>
<p>没有拥塞控制（用于多媒体通信）</p>
<p>n对n通信（n=1或多）</p>
<p>首部（8字节）开销小</p>
<p>不用套接字</p>
<h2 id="首部"><a href="#首部" class="headerlink" title="首部"></a>首部</h2><p>源端口2位</p>
<p>目的端口2位</p>
<p>长度2位</p>
<p>校验和2位</p>
<p>·        首部和数据部分一起校验</p>
<p>伪首部12位</p>
<p>·        计算校验和</p>
<p>·        不传输</p>
<h1 id="TCP（Transmission-Control-Protocol）-传输控制协议"><a href="#TCP（Transmission-Control-Protocol）-传输控制协议" class="headerlink" title="TCP（Transmission Control Protocol） 传输控制协议"></a>TCP（Transmission Control Protocol） 传输控制协议</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>提供面向连接的服务（不多播或广播）</p>
<p>·        只能点对点</p>
<p>可靠交付的服务</p>
<p>全双工通信</p>
<p>面向字节流</p>
<p>·        随时截断发送给上层</p>
<p>•      根据拥塞情况和窗口值决定发送大小</p>
<h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><h3 id="连接的端点：套接字socket"><a href="#连接的端点：套接字socket" class="headerlink" title="连接的端点：套接字socket"></a>连接的端点：套接字socket</h3><p>·        TCP 连接 ：：= {socket1, socket2} = {(IP1: port1), (IP2: port2)}</p>
<h2 id="可靠传输的工作原理（使用协议降低出错）"><a href="#可靠传输的工作原理（使用协议降低出错）" class="headerlink" title="可靠传输的工作原理（使用协议降低出错）"></a>可靠传输的工作原理（使用协议降低出错）</h2><h3 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h3><p>·        每发送完一个分组就停止发送， 等待对方的确认。 在收到确认后再发送下一个分组。</p>
<p>·        情况</p>
<p>•      </p>
<p><img src="https://i.loli.net/2020/06/11/gGUXlkcuzNnqeAm.png" alt="clip_image002.png"></p>
<p>•      </p>
<p><img src="https://i.loli.net/2020/06/11/dZvIzsNBw2q8liR.png" alt="clip_image004.png"></p>
<p>•      A只要超过了一段时间（超时计时器）仍然没有收到确认， 就认为刚才发送的分组丢失了，因而重传前面发送过的分组 。 这就叫做超时重传。</p>
<p>•      注意事项</p>
<p>•      发送方暂存已发送分组</p>
<p>•      分组标号</p>
<p>•      设计重传时间长于往返时间</p>
<p>•      确认丢失和确认迟到</p>
<p>•      重复的确认收下就丢弃</p>
<p>•      重复的分组收到后丢弃，然后发送确认</p>
<p>·        信道利用率</p>
<p>•      </p>
<p><img src="https://i.loli.net/2020/06/11/mPD2n7856eWlc4O.png" alt="clip_image006.png"></p>
<p>•      </p>
<p><img src="https://i.loli.net/2020/06/11/gbGycatLwp6K4ov.png" alt="clip_image008.png"></p>
<h3 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h3><p>·         </p>
<p><img src="https://i.loli.net/2020/06/11/EV6JAHmnpouwtIv.png" alt="clip_image010.png"></p>
<p>•      累积确认</p>
<p>•      接收方不必对收到的分组逐个发送确认， 而是在收到几个分组后， 对按序到达的最后一个分组发送确认</p>
<p>•      缺点</p>
<p>•      不能向发送方反映出接收方已经正确收到的所有分组的信息。</p>
<p>•      go-back-N</p>
<p>•      优点</p>
<p>•      容易实现， 即使确认丢失也不必重传。</p>
<h2 id="TCP报文段的首部格式"><a href="#TCP报文段的首部格式" class="headerlink" title="TCP报文段的首部格式"></a>TCP报文段的首部格式</h2><h3 id="报文段"><a href="#报文段" class="headerlink" title="报文段"></a>报文段</h3><p>·        TCP报文段首部的前20个字节是固定的（图5-14), 后面有4n字节是根据需要而增加<br> 的选项(n是整数）。 因此TCP首部的最小长度是20字节。</p>
<p>·         </p>
<p><img src="https://i.loli.net/2020/06/11/pVDPEubF5m1RL7Y.png" alt="clip_image012.png"></p>
<p>•      源端口和目的端口 各占 2 个字节，</p>
<p>•      序号 占 4 字节。</p>
<p>•      确认号 占 4 字节=序号+长度+1</p>
<p>•      希望下一个发送分组的序号</p>
<p>•      数据偏移 占 4 位（0-15）可加长到60字节</p>
<p>•      首部长度</p>
<p>•      保留 占 6 位， 保留为今后使用， 但目前应置0。</p>
<p>•      紧急 URG</p>
<p>•      当 URG 置 l 时， 发送应用进程就告诉发送方的 TCP 有紧急数据要传送。 千是发送方TCP 就把紧急数据插入到本报文段数据的最前面， 而在紧急数据后面的数据仍是普通数据。 这时要与首部中紧急指针(Urgent Pointer)字段配合使用。</p>
<p>•      确认 ACK (ACKnowledgment) 仅当 ACK= 1 确认号字段才有效。 当 ACK=0时， 确认号无效。</p>
<p>•      推送PSH (PuSH)</p>
<p>•      不等缓存满直接向上交付</p>
<p>•      复位RST ( ReSeT)</p>
<p>•      当RST= 1时， 表明 TCP连接中出现严重差错（如由于主机崩溃或其他原因）， 必须释放连接， 然后再重新建立运输连接。RST置l还用拒绝一个非法的报文段或拒绝打开一个连接。RST 也可称为重建位或重置位 。</p>
<p>•      同步SYN</p>
<p>•      同步SYN ( SYNchron ization) 在连接建立时用来同步序号。 当SYN = 1 而 ACK= 0 时， 表明这是一个连接请求报文段。 对方若同意建立连接， 则应在响应的报文段中使SYN= 1 和ACK= 1。 </p>
<p>•      终止FIN</p>
<p>•      终止连接</p>
<p>•      窗口 占2字节</p>
<p>•      窗口字段明确指出了现在允许对方发送的数据量</p>
<p>•      检验和</p>
<p>•      跟udp的伪首部一样</p>
<p>•      伪首部第4 个字段中的 17 改为6<br> (TCP 的协议号是 6),</p>
<p>•      紧急指针 占2字节</p>
<p>•      紧急指针仅在URG= 1时才有意义， 它指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据）。无视窗口</p>
<p>•      选项 最长40字节</p>
<p>•      TCP 最初只规定了一种选项， 即最大报文段长度MSS (Maximum Segment Size)</p>
<p>•      窗口扩大选项 3字节 （16+s）偏移量</p>
<p>•      时间戳选项 10字节</p>
<p>•      计算往返时间RTT</p>
<p>•      防止序号绕回(处理序号超过2^32的情况)</p>
<p>•      选择确认选项</p>
<p>•      待续</p>
<h2 id="TCP-可靠传输的实现"><a href="#TCP-可靠传输的实现" class="headerlink" title="TCP 可靠传输的实现"></a>TCP 可靠传输的实现</h2><h3 id="以字节为单位的滑动窗口"><a href="#以字节为单位的滑动窗口" class="headerlink" title="以字节为单位的滑动窗口"></a>以字节为单位的滑动窗口</h3><p>·        根据窗口值构造发送窗口</p>
<p>•      </p>
<p><img src="https://i.loli.net/2020/06/11/jVUJ6yrOawzovEm.png" alt="clip_image014.png"></p>
<p>•      P3 -P1 =A 的发送窗口<br> P2 -P1 =已发送但尚未收到确认的字节数<br> P3 -P2 =允许发送但当前尚未发送的字节数（又称为可用窗口或有效窗口）</p>
<p>•      时延影响，发送窗口一般小于窗口值</p>
<p>•      对于不按序到达的数据应如何处理， TCP 标准并无明确规定，若丢弃，增加网络负担</p>
<p>•      第三， TCP 要求接收方必须有累积确认的功能， 这样可以减小传输开销，可以将要发送的数据合并确认信息，但不应推迟太久</p>
<h3 id="超时重传时间的选择"><a href="#超时重传时间的选择" class="headerlink" title="超时重传时间的选择"></a>超时重传时间的选择</h3><p>·        自适应算法</p>
<p>•      TCP保留了RTT的一 个加权平均往返<br> 时间RTTs( 这又称为平滑的往返时间，</p>
<p>•      新的RTTs = (1 -a) x (旧的RTTs) + a x ( 新的RTT样本）0&lt;=a&lt; 1</p>
<p>•      报文段的往返时间RTT</p>
<p>•      超时重传时间RTO</p>
<p>•      RTO = RTTs + 4 x RTTD</p>
<p>•      RTTD 是RTT 的偏差的加权平均值</p>
<p>•      新的RTTD = (1 - β) x (旧的RTTo)+βx|RTTs-新的RTT样本|<br> 这里β是个小于 1 的系数， 它的推荐值是1/4</p>
<p>•      往返时间的测量</p>
<p>•      Kam算法</p>
<p>•      在计算加权平均 RTTS时， 只要报文段重传了，就不采用其往返时间样本。 这样得出的加权平均RTTS和RTO就较准确。</p>
<p>•      修正</p>
<p>•      文段每重传一次， 就把超时重传时间RTO增大一些。 典型的做法是取新的重传时间为旧的重传时间的 2 倍。 当不再发生报文段的重传时，才计算超时重传时间。</p>
<h3 id="选择确认SACK"><a href="#选择确认SACK" class="headerlink" title="选择确认SACK"></a>选择确认SACK</h3><p>·        解决接收到的字节流序号不连续的问题</p>
<p>·         如果要使用选择确认 SACK, 那么在建立 TCP 连接时， 就要在 TCP 首部的选项中加上“ 允许 SACK” 的选项</p>
<p>·         由千首部选项的长度最多只有 40 字节， 而指明一个边界就要用掉4字节（因为序号有 32 位， 需要使用4个字节表示）， 因此在选项中最多只能指明 4 个字节块的边界信息。 这是因为 4 个字节块共有 8 个边界， 因而需要用 32 个字节来描述。 另外还需要两个字节。一个字节用来指明是 SACK 选项， 另一个字节是指明这个选项要占用多少字节。 如果要报告五个字节块的边界信息</p>
<p>·        4个边界，两个块 用了4*4字节+2字节（sack+sack长度）</p>
<h2 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h2><p> 发送方的发送速率不要太快，要让接收方来得及接收。</p>
<h3 id="利用滑动窗口实现流量控制"><a href="#利用滑动窗口实现流量控制" class="headerlink" title="利用滑动窗口实现流量控制"></a>利用滑动窗口实现流量控制</h3><p>·        通过控制窗口值控制速率</p>
<p>·        发送方的发送窗口不能超过接收方给出的接收窗口的数值。 请注意， TCP 的窗口单位是字节， 不是报文段。</p>
<p>·        为了防止0窗口后的新窗口丢失</p>
<p>•      发送方 持续计时器</p>
<p>•      发送一个零窗口探测报文段</p>
<p>•      若为窗口仍为0</p>
<p>•      持续探测</p>
<p>•      若为窗口不为0</p>
<p>•      继续传输</p>
<h3 id="TCP-的传输效率"><a href="#TCP-的传输效率" class="headerlink" title="TCP 的传输效率"></a>TCP 的传输效率</h3><p>·        发送时机机制</p>
<p>•      第一种机制是TCP维持一个变量， 它等于最大报文段长度MSS。 只要缓存中存放的数据达到MSS 字节时， 就组装成一个TCP 报文段发送出去。 </p>
<p>•      第二种机制是由发送方的应用进程指明要求发送报文段，即TCP支持的推送(push)操作。 </p>
<p>•       第三种机制是发送方的一个计时器期限到了， 这时就把当前已有的缓存数据装入报文段（但长度不能超过MSS) 发送出去。</p>
<p>·        Nagle 算法</p>
<p>•      若发送应用进程把要发送的数据逐个字节地送到 TCP 的发送缓存， 则发送方就把第一个数据字节先发送出去， 把后面到达的数据字节都缓存起来。 当发送方收到对第一个数据字符的确认后， 再把发送缓存中的所有数据组装成一个报文段发送出去， 同时继续对随后到达的数据进行缓存。 只有在收到对前一个报文段的确认后才继续发送下一个报文段</p>
<p>•      规定： 当到达的数据已达到发送窗口大小的一半或已达到报文段的最大长度时， 就立即发送一个报文段。 这样做， 就可以有效地提高网络的吞吐量。</p>
<p>·        糊涂窗口综合征</p>
<p>•      现象</p>
<p>•      TCP 接收方的缓存已满， 而交互式的应用进程一次只从接收缓存中读取1个字节（这样就使接收缓存空间仅腾出1个字节）， 然后向发送方发送确认，把窗口设置为1个字节（但发送的数据报是40字节长）。 接着， 发送方又发来l个字节的数<br> 据（请注意， 发送方发送的IP数据报是41字节长）。 接收方发回确认， 仍然将窗口设置为<br> l 个字节。 这样进行下去， 使网络的效率很低。</p>
<p>•      解决</p>
<p>•      接收方等待一段时间， 使得或者接收缓存已有足够空间容纳一个最长的报文段， 或者等到接收缓存已有一半空闲的空间。 只要出现这两种情况之一， 接收方就发出确认报文， 并向发送方通知当前的窗口大小。 此外， 发送方也不要发送太小的报文段而是把数据积累成足够大的报文段， 或达到接收方缓存的空间的一半大小。</p>
<h2 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h2><h3 id="拥塞控制的一般原理"><a href="#拥塞控制的一般原理" class="headerlink" title="拥塞控制的一般原理"></a>拥塞控制的一般原理</h3><p>·        拥塞</p>
<p>•      定义</p>
<p>•      在某段时间， 若对网络中某一资源的需求超过了该资源所能提供的可用部分， 网络的性能<br> 就要变坏。 这种情况就叫做拥塞(congestion)。</p>
<p>•      任意增加一些资源不但不能解决拥塞问题， 而且还可能使网络的性能更坏。拥塞常常趋千恶化。</p>
<p>•      原因</p>
<p>•      复杂</p>
<p>•      某个结点缓存的容量太小时， 到达该结<br> 点的分组因无存储空间暂存而不得不被丢弃。</p>
<p>•      理机处理的速率太慢可能引起网络的拥塞。 简单地将处理机的速率提高， 可能会使上述情况缓解一些， 但往往又会将瓶颈转移到其他地方。</p>
<p>·        拥塞控制</p>
<p>•      定义</p>
<p>•      防止过多的数据注入到网络中， 这样可以使网络中的路由器或链路不致过载。</p>
<p>•      是一个全局性的过程</p>
<p>•      拥塞控制与流量控制的关系</p>
<p>•      关系密切</p>
<p>•      流量控制往往是指点对点通信量的控制， 是个端到端的问题</p>
<p>•      </p>
<p><img src="https://i.loli.net/2020/06/11/Rw6FqG42QnVoJLN.png" alt="clip_image016.png"></p>
<p>•      方法</p>
<p>•      开环控制</p>
<p>•      在设计网络时事先将有关发生拥塞的因素考虑周到， 力求网络在工作时不产生拥塞。</p>
<p>•      闭环控制</p>
<p>•      监测网络系统以便检测到拥塞在何时、 何处发生。</p>
<p>•      把拥塞发生的信息传送到可采取行动的地方。</p>
<p>•      调整网络系统的运行以解决出现的问题。</p>
<h3 id="TCP的拥塞控制方法"><a href="#TCP的拥塞控制方法" class="headerlink" title="TCP的拥塞控制方法"></a>TCP的拥塞控制方法</h3><p>·        四种方法共同使用</p>
<p>•      慢开始(slow-start)</p>
<p>•      由小到大逐渐增大发送窗口（指数增加）</p>
<p>•      拥塞窗口cwnd每次的增加量=min (N, SMSS )</p>
<p>•      N 是原先未被确认的、 但现在被刚收到的确认报文段所确认的字节数。</p>
<p>•      拥 塞 避 免(congestion avoidance)</p>
<p>•      拥塞避免算法的思路是让拥塞窗口cwnd缓慢地增大， 即每经过一个往返时间RTT就把发送方的拥塞窗口 cwnd 加1,而不是像慢开始阶段那样加倍增长。 因此 在拥塞避免阶段就有“加法增大” AI (Additive Increase)的 特点。 这表明在拥塞避免阶段，拥塞窗口cwnd按线性规律缓慢增长， 比慢开始算法的拥塞窗口增长速率缓慢得多。</p>
<p>•       快重传(fast retransmit)</p>
<p>•      发送方只要一连收到3个重复确认， 就知道接收方确实没有收到报文段M3, 因而应当立即进行重传</p>
<p>•      </p>
<p><img src="https://i.loli.net/2020/06/11/84hODIkWaSi6LZR.png" alt="clip_image018.png"></p>
<p>•      快重传可以使整个网络的吞吐量提高约20%。</p>
<p>•      快恢复(fast recovery)</p>
<p>•      发送方调整门限值ssthresh = cwnd / 2</p>
<p>•      拥塞窗口cwnd= ssthresh</p>
<p>•      开始执行拥塞避免算法</p>
<p>•      概要发送方控制拥塞窗口的原则 是：只要网络没有出现拥塞，拥塞窗口就可以再增大一些， 以便把更多的分组发送出去， 这样就可以提高网络的利用率。 但只要网络出现拥塞或有可能出现拥塞，就必须把拥塞窗口减小一些， 以减少注入到网络中的分组数， 以便缓解网络出现的拥塞。</p>
<p>•      发送方又是如何知道网络发生了拥塞</p>
<p>•      判断网络拥塞的依据就是出现了超时。</p>
<p>•      慢开始门限 ssthresh</p>
<p>•      cwnd&lt; ssthresh时， 使用上述的慢开始算法。</p>
<p>•      cwnd&gt; ssthresh时， 停止使用慢开始算法而改用拥塞避免算法。</p>
<p>•      cwnd= ssthresh时， 既可使用慢开始算法， 也可使用拥塞避免算法。</p>
<p>•      </p>
<p><img src="https://i.loli.net/2020/06/11/ACFKPpbcMh4TLUu.png" alt="clip_image019.png"></p>
<p>·        流程图</p>
<p>•      </p>
<p><img src="https://i.loli.net/2020/06/11/mwjQfucqle7pkgP.png" alt="clip_image021.png"></p>
<h3 id="主动队列管理AQM"><a href="#主动队列管理AQM" class="headerlink" title="主动队列管理AQM"></a>主动队列管理AQM</h3><p>·        略</p>
<h2 id="TCP的运输连接管理"><a href="#TCP的运输连接管理" class="headerlink" title="TCP的运输连接管理"></a>TCP的运输连接管理</h2><h3 id="运输连接"><a href="#运输连接" class="headerlink" title="运输连接"></a>运输连接</h3><p>·        连接建立</p>
<p>•      要解决的问题</p>
<p>•      要使每一方能够确知对方的存在</p>
<p>•      要允许双方协商 一些参数</p>
<p>•      能够对运输实体资源</p>
<p>•      主动发起连接建立的应用进程叫做客户(client),<br> 而被动等待连接建立的应用进程叫做服务器(server)。</p>
<p>•      过程</p>
<p>•      三次握手</p>
<p><img src="https://i.loli.net/2020/06/11/lED46Aticw5K71x.png" alt="clip_image022.png"></p>
<p>·        数据传送</p>
<p>·        连接释放</p>
<p>•      过程</p>
<p>•      四报文握手</p>
<p><img src="https://i.loli.net/2020/06/11/hjVpKM3yqG9RFmZ.png" alt="clip_image023.png"></p>
<p>•      A必须等待2MSL的时间</p>
<p>•      为了保证A发送的最后一一个ACK报文段能够到达B。</p>
<p>•      防止已失效的连接请求报文段” 出现在本连接中。</p>
<p>•      数据传输结束后，通信的双方都可释放连接。</p>
<h3 id="TCP的有限状态机"><a href="#TCP的有限状态机" class="headerlink" title="TCP的有限状态机"></a>TCP的有限状态机</h3><p>·         </p>
<p><img src="https://i.loli.net/2020/06/11/5jDLVlCMArvtFca.png" alt="clip_image024.png"></p>
<p>•      粗实线箭头表示对客户进程的正常变迁。<br> 粗虚线箭头表示对服务器进程的正常变迁。<br> 另一种细线箭头表示异常变迁。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>计网笔记</tag>
        <tag>运输层</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode笔记</title>
    <url>/leetcode%E7%AC%94%E8%AE%B0.html</url>
    <content><![CDATA[<p><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"></p>
<meta name="referrer" content="no-referrer">

<p><strong>以下题目均为leetcode的题目，仅作为个人笔记，侵权必删。</strong></p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="Easy"><a href="#Easy" class="headerlink" title="Easy"></a>Easy</h3><h4 id="删除最外层的括号"><a href="#删除最外层的括号" class="headerlink" title="删除最外层的括号"></a><a href="https://leetcode-cn.com/problems/remove-outermost-parentheses">删除最外层的括号</a></h4><p>有效括号字符串为空 (“”)、”(“ + A + “)” 或 A + B，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。例如，””，”()”，”(())()” 和 “(()(()))” 都是有效的括号字符串。</p>
<p>如果有效字符串 S 非空，且不存在将其拆分为 S = A+B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。</p>
<p>给出一个非空有效字符串 S，考虑将其进行原语化分解，使得：S = P_1 + P_2 + … + P_k，其中 P_i 是有效括号字符串原语。</p>
<p>对 S 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 S 。</p>
<p><strong>思路：栈判断是否组成完整的原语，直接substr消除最外层的符号。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeOuterParentheses</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> stackint=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;S.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(S[i]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                stackint++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stackint--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(stackint==<span class="number">0</span>)&#123;</span><br><span class="line">               res=res+S.substr(left+<span class="number">1</span>,i-left<span class="number">-1</span>);</span><br><span class="line">               left=i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a><a href="https://leetcode-cn.com/problems/min-stack">最小栈</a></h4><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p>
<p>push(x) —— 将元素 x 推入栈中。<br>pop() —— 删除栈顶的元素。<br>top() —— 获取栈顶元素。<br>getMin() —— 检索栈中的最小元素。</p>
<p><strong>思路：设计一个辅助栈，给每个元素都配上一个当前最小值，跟随原来栈来增减.</strong></p>
<p>$\textcolor{red}{注意点:辅助栈要先放入一个最大值，在第一个元素放入的时候方便更新。}$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    Deque&lt;Integer&gt; MainStack;</span><br><span class="line">    Deque&lt;Integer&gt; assistStack;	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MainStack=<span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        assistStack=<span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        assistStack.push(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        MainStack.push(x);</span><br><span class="line">        <span class="keyword">if</span>(x&lt;assistStack.peek())</span><br><span class="line">            assistStack.push(x);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            assistStack.push(assistStack.peek());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MainStack.pop();</span><br><span class="line">        assistStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> MainStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> assistStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="比较含退格的字符串"><a href="#比较含退格的字符串" class="headerlink" title="比较含退格的字符串"></a><a href="https://leetcode-cn.com/problems/backspace-string-compare">比较含退格的字符串</a></h4><p>给定 S 和 T 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 # 代表退格字符。</p>
<p>注意：如果对空文本输入退格字符，文本继续为空。</p>
<p>示例 1：</p>
<p>输入：S = “ab#c”, T = “ad#c”<br>输出：true<br>解释：S 和 T 都会变成 “ac”。</p>
<p>思路：模拟，遇到‘#’就判断栈是否为空，不空则弹出，遇到其他符号就入栈。</p>
<p>时间复杂度O(n+m)</p>
<p>空间复杂度O(n+m)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">backspaceCompare</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; s1;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; s2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!s1.empty())</span><br><span class="line">                    s1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> s1.push(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;t.size();k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t[k]==<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!s2.empty())</span><br><span class="line">                    s2.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> s2.push(t[k]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s1==s2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>思路2：从后往前遍历，每次都先jump到有效位置，进行比较。</p>
<p>注意：①跳过的时候要看跳的时候是否有‘#’。</p>
<p>​            ②要两个字符串分析完才能结束。</p>
<p>时间复杂度O(n+m)</p>
<p>空间复杂度O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">string</span> &amp; str ,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i]==<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                count++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(count)</span><br><span class="line">                --count;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">backspaceCompare</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=s.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> j=t.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>||j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            i=jump(s,i);</span><br><span class="line">            j=jump(t,j);</span><br><span class="line">            <span class="keyword">if</span>(i&lt;<span class="number">0</span>||j&lt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(s[i--]!=t[j--])<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i&lt;<span class="number">0</span>&amp;&amp;j&lt;<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="整理字符串"><a href="#整理字符串" class="headerlink" title="整理字符串"></a><a href="https://leetcode-cn.com/problems/make-the-string-great/">整理字符串</a></h4><p>一个整理好的字符串中，两个相邻字符 s[i] 和 s[i+1]，其中 0&lt;= i &lt;= s.length-2 ，要满足如下条件:</p>
<p>若 s[i] 是小写字符，则 s[i+1] 不可以是相同的大写字符。<br>若 s[i] 是大写字符，则 s[i+1] 不可以是相同的小写字符。</p>
<p>思路用栈保存要保留的字符，遇到相同的（不同大小写的）就弹出，否则加入。</p>
<p>时间复杂度O(n)</p>
<p>空间复杂度O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">makeGood</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size()&lt;<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=s.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st.empty())</span><br><span class="line">                st.push(s[i]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]-<span class="string">&#x27;a&#x27;</span>==st.top()-<span class="string">&#x27;A&#x27;</span>||s[i]-<span class="string">&#x27;A&#x27;</span>==st.top()-<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">                st.pop();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                st.push(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">while</span>(!st.empty())&#123;</span><br><span class="line">            ans+=st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>优化后的 string当st用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">makeGood</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!ans.empty()&amp;&amp;((<span class="keyword">char</span>)(ans.back()) ^ s[i]) == <span class="number">32</span>)</span><br><span class="line">                ans.pop_back();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ans.push_back(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="二叉树的后序遍历"><a href="#二叉树的后序遍历" class="headerlink" title="二叉树的后序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal">二叉树的后序遍历</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode* prev=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="literal">nullptr</span>||!st.empty())&#123;	<span class="comment">//栈中还有节点或者根节点不为空可以继续遍历</span></span><br><span class="line">            <span class="keyword">while</span>(root)&#123;</span><br><span class="line">                st.emplace(root);	<span class="comment">//先存所有左孩子</span></span><br><span class="line">                root=root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root=st.top();	<span class="comment">//取出最后的左孩子或者是root本身</span></span><br><span class="line">            st.pop();</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right==<span class="literal">nullptr</span>||root-&gt;right==prev)&#123;	<span class="comment">//右孩子为空或者右树已经访问完毕</span></span><br><span class="line">                ans.emplace_back(root-&gt;val);<span class="comment">//访问根节点</span></span><br><span class="line">                prev=root;</span><br><span class="line">                root=<span class="literal">nullptr</span>;	<span class="comment">//取下一个栈中的节点</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                st.emplace(root);	<span class="comment">//存放根节点</span></span><br><span class="line">                root=root-&gt;right;	<span class="comment">//访问右树</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">二叉树的中序遍历</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="literal">nullptr</span>||!st.empty())&#123;		<span class="comment">//栈中还有节点或者根节点不为空可以继续遍历</span></span><br><span class="line">            <span class="keyword">while</span>(root)&#123;</span><br><span class="line">                st.emplace(root);		<span class="comment">//先存所有左孩子</span></span><br><span class="line">                root=root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root=st.top();	<span class="comment">//取出最后的左孩子或者是root本身</span></span><br><span class="line">            st.pop();</span><br><span class="line">            ans.emplace_back(root-&gt;val);	<span class="comment">//访问根节点</span></span><br><span class="line">            root=root-&gt;right;    <span class="comment">//访问右树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="二叉树的前序遍历"><a href="#二叉树的前序遍历" class="headerlink" title="二叉树的前序遍历"></a>二叉树的前序遍历</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="literal">nullptr</span>||!st.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root)&#123;</span><br><span class="line">                ans.emplace_back(root-&gt;val);</span><br><span class="line">                st.emplace(root);</span><br><span class="line">                root=root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root=st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            root=root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="medium"><a href="#medium" class="headerlink" title="medium"></a>medium</h3><h4 id="反转每对括号间的子串"><a href="#反转每对括号间的子串" class="headerlink" title="反转每对括号间的子串"></a><a href="https://leetcode-cn.com/problems/reverse-substrings-between-each-pair-of-parentheses/">反转每对括号间的子串</a></h4><p>给出一个字符串 <code>s</code>（仅含有小写英文字母和括号）。</p>
<p>请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。</p>
<p>注意，您的结果中 <strong>不应</strong> 包含任何括号。</p>
<p> <strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;(ed(et(oc))el)&quot;</span><br><span class="line">输出：&quot;leetcode&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;a(bcdefghijkl(mno)p)q&quot;</span><br><span class="line">输出：&quot;apmnolkjihgfedcbq&quot;</span><br></pre></td></tr></table></figure>
<p>思路1：栈，遇到左括号进栈，右括号出栈的同时将左右括号之间的所有元素反转。</p>
<p>最后将左右括号去除。</p>
<p>时间复杂度O(<script type="math/tex">n^2</script>)</p>
<p>空间复杂度O(<script type="math/tex">n</script>)，栈空间</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                st.push(i);<span class="comment">//序号进栈</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> head=st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                <span class="comment">//反转中间元素</span></span><br><span class="line">                reverse(s.begin()+head+<span class="number">1</span>,s.begin()+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> ans=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch:s)	<span class="comment">//去掉括号</span></span><br><span class="line">            <span class="keyword">if</span>(ch!=<span class="string">&#x27;(&#x27;</span>&amp;&amp;ch!=<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">                ans+=ch;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>思路2：先用栈遍历来记录每个括号对应的括号位置。然后遍历时每次遇到括号就跳转到对应括号，反方向遍历。每个括号会遍历两遍，每个元素会遍历一遍。</p>
<p>时间复杂度O(<script type="math/tex">n</script>)</p>
<p>空间复杂度O(<script type="math/tex">n</script>)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">int</span> len=s.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">pairs</span><span class="params">(len)</span></span>;		<span class="comment">//记录每个括号对应的括号位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                st.push(i);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> head=st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                pairs[i]=head;</span><br><span class="line">                pairs[head]=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dir=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">string</span> ans=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;len)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>||s[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                i=pairs[i];	<span class="comment">//跳转到对应括号</span></span><br><span class="line">                dir=-dir;	<span class="comment">//方向反转</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans+=s[i];	<span class="comment">//保存元素</span></span><br><span class="line">            &#125;</span><br><span class="line">            i+=dir;	<span class="comment">//跟着dir方向走</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><h3 id="easy"><a href="#easy" class="headerlink" title="easy"></a>easy</h3><h4 id="和为s的连续正数序列"><a href="#和为s的连续正数序列" class="headerlink" title="和为s的连续正数序列"></a><a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/">和为s的连续正数序列</a></h4><p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p>
<p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：target &#x3D; 9</span><br><span class="line">输出：[[2,3,4],[4,5]]</span><br></pre></td></tr></table></figure>
<p>思路:滑动窗口，三种情况。</p>
<p>① 当当前窗口比target小时，窗口右端点右移。</p>
<p>② 当当前窗口比target大时，窗口左端点右移。</p>
<p>③ 当当前窗口等于target时，窗口左端点右移。</p>
<p>其中要一直保持左端点小于右端点。</p>
<p>注意：右端点上界为target/2+1,超过之后两个数相加就肯定大于target。</p>
<p>时间复杂度O(target)</p>
<p>空间复杂度O(1)</p>
<p>求和公式版：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; findContinuousSequence(<span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">1</span>,r=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(r&gt;l)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum=(l+r)*(r-l+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(sum==target)&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; newlist;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=l;j&lt;=r;j++)</span><br><span class="line">                    newlist.emplace_back(j);</span><br><span class="line">                ans.emplace_back(newlist);</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;target)++r;</span><br><span class="line">            <span class="keyword">else</span> ++l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>移动窗口调整sum版</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; findContinuousSequence(<span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">1</span>,r=<span class="number">2</span>,sum=<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">while</span>(r&gt;l)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum==target)&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; newlist;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=l;j&lt;=r;++j)</span><br><span class="line">                    newlist.emplace_back(j);</span><br><span class="line">                ans.emplace_back(newlist);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum&lt;target)&#123;	<span class="comment">//注意加的顺序</span></span><br><span class="line">                ++r;</span><br><span class="line">                sum+=r;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;			<span class="comment">//注意减的顺序</span></span><br><span class="line">                sum-=l;</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="medium-1"><a href="#medium-1" class="headerlink" title="medium"></a>medium</h3><h4 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串</a></h4><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>
<p>思路：滑动窗口，set存放窗口内的字母。 将i , j分别作为窗口的左右边界，没有遇到重复的就 j 右移，直到遇到\n或者在窗口内存放的字母。i右移直到遇到刚才j遇到重复字母。如此循环，在过程中记录窗口大小。</p>
<p>时间复杂度O(N)</p>
<p>空间复杂度O(|<script type="math/tex">\sum{Z}</script>|)字符集大小</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>,ans=<span class="number">0</span>,len=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt; st;	<span class="comment">//窗口里的字母</span></span><br><span class="line">        <span class="keyword">while</span>(r&lt;s.size())&#123;</span><br><span class="line">            <span class="comment">//窗口找不到当前右边界字母并且右边界没到字符串末尾</span></span><br><span class="line">            <span class="keyword">while</span>(r&lt;s.size()&amp;&amp;st.find(s[r])==st.end())</span><br><span class="line">                st.insert(s[r++]);	<span class="comment">//加入窗口并更新边界</span></span><br><span class="line">            ans=max(ans,r-l);	<span class="comment">//更新窗口最大值</span></span><br><span class="line">            <span class="keyword">while</span>(r&gt;=l)&#123;</span><br><span class="line">                st.erase(s[l]);</span><br><span class="line">                <span class="keyword">if</span>(s[l++]==s[r])<span class="keyword">break</span>;	<span class="comment">//刚才删掉了与有边界遇到的相同字符可以退出了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="hard"><a href="#hard" class="headerlink" title="hard"></a>hard</h3><h4 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/">最小覆盖子串</a></h4><p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</p>
<p>注意：如果 s 中存在这样的子串，我们保证它是唯一的答案。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;ADOBECODEBANC&quot;</span>, t = <span class="string">&quot;ABC&quot;</span></span><br><span class="line">输出：<span class="string">&quot;BANC&quot;</span></span><br></pre></td></tr></table></figure>
<p>思路：当没有覆盖t全部字母时，right右移，覆盖完了，left左移，记录区间长度最小值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;&amp; Scount,<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;&amp; Tcount)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it=Scount.begin();</span><br><span class="line">        <span class="keyword">while</span>(it!=Scount.end())&#123;</span><br><span class="line">            <span class="keyword">if</span>((it-&gt;second)&gt;(Tcount[it-&gt;first]))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            it++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; Scount;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; Tcount;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Scount.find(t[i])==Scount.end())&#123;</span><br><span class="line">                Scount[t[i]]=<span class="number">0</span>;</span><br><span class="line">                Tcount[t[i]]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Scount[t[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans=s.size()+<span class="number">22</span>;</span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!(right&gt;=s.size()&amp;&amp;!check(Scount,Tcount)))&#123;</span><br><span class="line">            <span class="keyword">if</span>(!check(Scount,Tcount))&#123;</span><br><span class="line">                <span class="keyword">if</span>(Scount.find(s[right])!=Scount.end())&#123;</span><br><span class="line">                   Tcount[s[right]]++;</span><br><span class="line">                &#125;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(right-left&lt;ans)&#123;</span><br><span class="line">                    index=left;</span><br><span class="line">                    ans=right-left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(Scount.find(s[left])!=Scount.end())&#123;</span><br><span class="line">                    Tcount[s[left]]--;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans==s.size()+<span class="number">22</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> s.substr(index,ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="medium-2"><a href="#medium-2" class="headerlink" title="medium"></a>medium</h3><h4 id="解码方法"><a href="#解码方法" class="headerlink" title="解码方法"></a><a href="https://leetcode-cn.com/problems/decode-ways/">解码方法</a></h4><p>一条包含字母 <code>A-Z</code> 的消息通过以下映射进行了 <strong>编码</strong> ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;A&#39; -&gt; 1</span><br><span class="line">&#39;B&#39; -&gt; 2</span><br><span class="line">...</span><br><span class="line">&#39;Z&#39; -&gt; 26</span><br></pre></td></tr></table></figure>
<p>要 <strong>解码</strong> 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，<code>&quot;11106&quot;</code> 可以映射为：</p>
<ul>
<li><code>&quot;AAJF&quot;</code> ，将消息分组为 <code>(1 1 10 6)</code></li>
<li><code>&quot;KJF&quot;</code> ，将消息分组为 <code>(11 10 6)</code></li>
</ul>
<p>注意，消息不能分组为 <code>(1 11 06)</code> ，因为 <code>&quot;06&quot;</code> 不能映射为 <code>&quot;F&quot;</code> ，这是由于 <code>&quot;6&quot;</code> 和 <code>&quot;06&quot;</code> 在映射中并不等价。</p>
<p>给你一个只含数字的 <strong>非空</strong> 字符串 <code>s</code> ，请计算并返回 <strong>解码</strong> 方法的 <strong>总数</strong> 。</p>
<p>题目数据保证答案肯定是一个 <strong>32 位</strong> 的整数。</p>
<p>思路：动态规划，dp[i]表示0-(i-1)为之间的解码可能总数。第i个字符它可以跟i-1个字符合并为一个数也可以自己作为一个数。</p>
<p>注意：以上两种情况可以同时满足。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(s.size()+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;	<span class="comment">//空串</span></span><br><span class="line">        <span class="keyword">if</span>(s.size()&gt;=<span class="number">1</span>)</span><br><span class="line">            dp[<span class="number">1</span>]=(s[<span class="number">0</span>]==<span class="string">&#x27;0&#x27;</span>?<span class="number">0</span>:<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=stoi(s.substr(i<span class="number">-2</span>,<span class="number">2</span>));</span><br><span class="line">            <span class="keyword">if</span>(tmp&gt;=<span class="number">10</span>&amp;&amp;tmp&lt;=<span class="number">26</span>)	<span class="comment">//说明是两位数</span></span><br><span class="line">                dp[i]+=dp[i<span class="number">-2</span>];</span><br><span class="line">            <span class="keyword">if</span>(s[i<span class="number">-1</span>]!=<span class="string">&#x27;0&#x27;</span>)			<span class="comment">//除了自己是0以外，都可以自己作为一个数解码</span></span><br><span class="line">                dp[i]+=dp[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="股票的最大利润"><a href="#股票的最大利润" class="headerlink" title="股票的最大利润"></a><a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/">股票的最大利润</a></h4><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">买卖股票的最佳时机</a></p>
<p>与上面一道题相同。</p>
<p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？ </p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。</span><br><span class="line">     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格。</span><br></pre></td></tr></table></figure>
<p>思路：当天的最大利润=今天的价格-历史最低价。dp[i]表示前i天最多能获得的利润。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.size()&lt;<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dpnum=<span class="number">0</span>;    <span class="comment">//前0天能获得的利润</span></span><br><span class="line">        <span class="keyword">int</span> historyMinCost=prices[<span class="number">0</span>];  <span class="comment">//历史最低价</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.size();i++)&#123;</span><br><span class="line">            <span class="comment">//前i-1天最大利润和今天能获得的最大利润比较</span></span><br><span class="line">            <span class="keyword">int</span> curMax=max(dpnum,prices[i]-historyMinCost);</span><br><span class="line">            <span class="comment">//更新历史最低利润 </span></span><br><span class="line">            historyMinCost=min(historyMinCost,prices[i]);</span><br><span class="line">            <span class="comment">//更新前i-1天的记录</span></span><br><span class="line">            dpnum=curMax;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dpnum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="hard-1"><a href="#hard-1" class="headerlink" title="hard"></a>hard</h3><h4 id="最大子矩阵"><a href="#最大子矩阵" class="headerlink" title="最大子矩阵"></a><a href="https://leetcode-cn.com/problems/max-submatrix-lcci/">最大子矩阵</a></h4><p>给定一个正整数、负整数和 0 组成的 N × M 矩阵，编写代码找出元素总和最大的子矩阵。</p>
<p>返回一个数组 <code>[r1, c1, r2, c2]</code>，其中 <code>r1</code>, <code>c1</code> 分别代表子矩阵左上角的行号和列号，<code>r2</code>, <code>c2</code> 分别代表右下角的行号和列号。若有多个满足条件的子矩阵，返回任意一个均可。</p>
<p><strong>注意：</strong>本题相对书上原题稍作改动</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[</span><br><span class="line">   [-1,0],</span><br><span class="line">   [0,-1]</span><br><span class="line">]</span><br><span class="line">输出：[0,1,0,1]</span><br><span class="line">解释：输入中标粗的元素即为输出所表示的矩阵</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ul>
<li><code>1 &lt;= matrix.length, matrix[0].length &lt;= 200</code></li>
</ul>
<p>思路：压缩二维数组的列使其为一维数组，然后动态规划求一维数组的最大字序和，就可以求出该二维数组固定高（这里的高就是二维数组的高度）的子矩阵的最大值。</p>
<p>然后套两层循环来遍历所有的高，i为上高，j为下底，有了i和j就可以唯一确定矩阵的高。</p>
<p>时间复杂度O（<script type="math/tex">nm^2</script>）</p>
<p>空间复杂度O（<script type="math/tex">n</script>）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getMaxMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r1,c1,r2,c2,maxval=INT_MIN;			<span class="comment">//初始化矩阵最大值</span></span><br><span class="line">        <span class="keyword">int</span> m=matrix.size(),n=matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> tmp1,tmp2;		<span class="comment">//用于保存求一维数组最大字段和的起点。</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">colsum</span><span class="params">(n,<span class="number">0</span>)</span></span>;		<span class="comment">//压缩后的一维矩阵</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)&#123;			<span class="comment">//遍历上高</span></span><br><span class="line">            fill(colsum.begin(),colsum.end(),<span class="number">0</span>);	<span class="comment">//上高变化时，将一维数组初始化</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;m;++j)&#123;		<span class="comment">//遍历下底</span></span><br><span class="line">                <span class="keyword">int</span> sum=<span class="number">0</span>;			<span class="comment">//开始求最大字序和</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;++k)&#123;	</span><br><span class="line">                    colsum[k]+=matrix[j][k];</span><br><span class="line">                    <span class="keyword">if</span>(sum&gt;<span class="number">0</span>)&#123;		<span class="comment">//前面的+现在的 可以变得更大</span></span><br><span class="line">                        sum+=colsum[k];</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;			<span class="comment">//抛弃前面的，从现在开始重新计算</span></span><br><span class="line">                        sum=colsum[k];</span><br><span class="line">                        tmp1=i;		<span class="comment">//记录上高</span></span><br><span class="line">                        tmp2=k;		<span class="comment">//记录左边界</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(maxval&lt;sum)&#123;		<span class="comment">//更新答案</span></span><br><span class="line">                        maxval=sum;	</span><br><span class="line">                        r1=tmp1;		<span class="comment">//拿到之前记录的上高</span></span><br><span class="line">                        c1=tmp2;		<span class="comment">//拿到之前记录的左边界</span></span><br><span class="line">                        r2=j;			<span class="comment">//记录当前的下底</span></span><br><span class="line">                        c2=k;			<span class="comment">//记录当前的右边界</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;r1,c1,r2,c2&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="奇怪的打印机"><a href="#奇怪的打印机" class="headerlink" title="奇怪的打印机"></a><a href="https://leetcode-cn.com/problems/strange-printer/">奇怪的打印机</a></h4><p>有台奇怪的打印机有以下两个特殊要求：</p>
<ul>
<li>打印机每次只能打印由 <strong>同一个字符</strong> 组成的序列。</li>
<li>每次可以在任意起始和结束位置打印新字符，并且会覆盖掉原来已有的字符。</li>
</ul>
<p>给你一个字符串 <code>s</code> ，你的任务是计算这个打印机打印它需要的最少打印次数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;aaabbb&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：首先打印 &quot;aaa&quot; 然后打印 &quot;bbb&quot;。</span><br></pre></td></tr></table></figure>
<p>思路：动态规划，<code>dp[i][j]</code>代表i到j至少需要打印的次数。</p>
<p>首先压缩字符串。aaabbb等价于ab，连续相同的字符串可以看做一个字符</p>
<p>推导<code>dp[i][j]</code>，</p>
<p>当<code>i==j</code>时显然等于1</p>
<p>当<code>s[i]==s[j]</code>时在打印<code>i</code>时可以打印<code>j</code>，所以<code>dp[i][j]=dp[i][j-1]</code></p>
<p>当<code>s[i]!=s[j]</code>时，可以将<code>i-j</code>分割为 <code>i-k</code>和<code>k-j</code>(i&lt;=k&lt;j)</p>
<p>后往前推版本</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strangePrinter</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="keyword">char</span> pre=s[<span class="number">0</span>];</span><br><span class="line">        str.push_back(pre);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;s.size();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==pre)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            pre=s[i];</span><br><span class="line">            str.push_back(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(s,str);	<span class="comment">//压缩s</span></span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;	<span class="comment">//从后往前推导</span></span><br><span class="line">            dp[i][i] = <span class="number">1</span>;<span class="comment">//长度1的都为1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123; 	<span class="comment">//j往后拓展</span></span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>];	<span class="comment">//j-1在前一步推导过了</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> minn = INT_MAX;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt; j; k++) &#123;</span><br><span class="line">                        <span class="comment">//k+1&gt;i并且i&lt;k&lt;j所以都是推导过的</span></span><br><span class="line">                        <span class="comment">//分割成i-k和k+1-j的，找最小次数</span></span><br><span class="line">                        minn = min(minn, dp[i][k] + dp[k + <span class="number">1</span>][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    dp[i][j] = minn;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>向后推版本</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,INT_MAX/<span class="number">4</span>));</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;	<span class="comment">//右边界j往后推,右边界小于j的都被推导过</span></span><br><span class="line">           dp[j][j]=<span class="number">1</span>;			<span class="comment">//长度1的都为1</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=j<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)&#123;	<span class="comment">//i在j的基础上往前推，左边界小于j，大于i的都被推导过</span></span><br><span class="line">               <span class="keyword">if</span>(s[i]==s[j])	<span class="comment">//在给j打印的时候打印i</span></span><br><span class="line">                   dp[i][j]=dp[i+<span class="number">1</span>][j];	<span class="comment">//dp[i+1][j]是前一步推导</span></span><br><span class="line">               <span class="keyword">else</span>&#123;</span><br><span class="line">                   <span class="keyword">for</span>(<span class="keyword">int</span> k=j;k&gt;i;k--)</span><br><span class="line">                   	<span class="comment">//i&lt;k&lt;=j，所以k-1&lt;=j-1,dp[i][k-1]已经推导过</span></span><br><span class="line">                   	<span class="comment">//同理，i&lt;k, dp[k][j]也推导过</span></span><br><span class="line">                       dp[i][j]=min(dp[i][j],dp[i][k<span class="number">-1</span>]+dp[k][j]);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>根据长度推导</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,INT_MAX/<span class="number">4</span>));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)	<span class="comment">//长度1的都为1</span></span><br><span class="line">          dp[i][i]=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>;len&lt;=n;++len)&#123;			<span class="comment">//区间长度</span></span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=len<span class="number">-1</span>;j&lt;n;j++,i++)&#123;	<span class="comment">//保持[i,j]长度为len</span></span><br><span class="line">              <span class="keyword">if</span>(s[i]==s[j]) </span><br><span class="line">                  <span class="comment">//i可以和i+1-j的左边界一起打印或者</span></span><br><span class="line">                  <span class="comment">//j可以和i-j-1的右边界一起打印</span></span><br><span class="line">                  dp[i][j]=min(dp[i+<span class="number">1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">              <span class="keyword">else</span>&#123;</span><br><span class="line">                  dp[i][j]=INT_MAX;</span><br><span class="line">                  <span class="comment">//i-k和k+1-j的长度肯定小于i-j,所以一定被推导过</span></span><br><span class="line">                  <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;j;++k)</span><br><span class="line">                      dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+<span class="number">1</span>][j]);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>递归版</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strangePrinter</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = str.size();</span><br><span class="line">        <span class="comment">//dp[i][j]表示从第i个字符到第j个字符（包括两端）需要的打印次数</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">1</span>,n,dp,str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; dp, <span class="built_in">string</span>&amp; str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[l][r] != <span class="number">-1</span>) <span class="keyword">return</span> dp[l][r];<span class="comment">//说明已经求得直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> dp[l][r] = <span class="number">0</span>;		<span class="comment">//无效区间</span></span><br><span class="line">        <span class="comment">//求区间l到r-1,最后打印r, r自己打印</span></span><br><span class="line">        <span class="keyword">int</span> res = helper(l, r - <span class="number">1</span>, dp, str) + <span class="number">1</span>;	</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> m = l; m &lt; r; ++m) &#123;</span><br><span class="line">            <span class="comment">//r到m打印加上m-1到i打印</span></span><br><span class="line">            <span class="keyword">if</span> (str[m<span class="number">-1</span>] == str[r<span class="number">-1</span>]) &#123;</span><br><span class="line">                res = min(res, helper(l, m - <span class="number">1</span>, dp, str) + helper(m, r - <span class="number">1</span>, dp, str));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[l][r] = res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><h3 id="easy-1"><a href="#easy-1" class="headerlink" title="easy"></a>easy</h3><h4 id="整数反转"><a href="#整数反转" class="headerlink" title="整数反转"></a><a href="https://leetcode-cn.com/problems/reverse-integer/">整数反转</a></h4><p>难度简单2799</p>
<p>给你一个 32 位的有符号整数 <code>x</code> ，返回将 <code>x</code> 中的数字部分反转后的结果。</p>
<p>如果反转后整数超过 32 位的有符号整数的范围 <code>[−231, 231 − 1]</code> ，就返回 0。</p>
<p><strong>假设环境不允许存储 64 位整数（有符号或无符号）。</strong></p>
<p> <strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：x &#x3D; 123</span><br><span class="line">输出：321</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：x &#x3D; -123</span><br><span class="line">输出：-321</span><br></pre></td></tr></table></figure>
<p>思路：将个十百千位依次读出，然后重新组成一个反转的数。</p>
<p>注意反转后可能溢出INT范围。</p>
<p>①在组成过程中，可以判断组成前的数是不是大于INT/10，大于的话，继续组下一位的时候就会溢出</p>
<p>②由于INT_MAX的个位是7,INT_MIN的个尾是8。</p>
<p>那么当x的最高位大于7并且x是与INT_MAX有相同的位数时，反转出来就会溢出。</p>
<p>但是这种情况在本题不存在，由于x是INT范围内的数，那么x与INT_MAX有相同的位数时，x的最高位必然只有1，2两种选择。</p>
<p>所以只有情况①才可能溢出。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ans&gt;INT_MAX/<span class="number">10</span>||ans&lt;INT_MIN/<span class="number">10</span>) <span class="comment">//溢出</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            ans*=<span class="number">10</span>;	<span class="comment">//腾出个位来</span></span><br><span class="line">            ans+=x%<span class="number">10</span>;	<span class="comment">//将x的末位添加到ans</span></span><br><span class="line">            x/=<span class="number">10</span>;		<span class="comment">//删除x的末位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="mindium"><a href="#mindium" class="headerlink" title="mindium"></a>mindium</h3><h4 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">顺时针打印矩阵</a></h4><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure>
<p><strong>限制：</strong></p>
<ul>
<li><code>0 &lt;= matrix.length &lt;= 100</code></li>
<li><code>0 &lt;= matrix[i].length &lt;= 100</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> m=matrix.size();</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">int</span> n=matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dir=&#123;n,m<span class="number">-1</span>,n<span class="number">-1</span>,m<span class="number">-2</span>&#125;;<span class="comment">//初始化第一圈要跳的步数</span></span><br><span class="line">        <span class="keyword">int</span> xx[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;	<span class="comment">//x的变化方向</span></span><br><span class="line">        <span class="keyword">int</span> yy[]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;	<span class="comment">//y的变化方向</span></span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">0</span>,y=<span class="number">-1</span>;	<span class="comment">//要先从外面跳进去</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)&#123;	<span class="comment">//决定现在的方向</span></span><br><span class="line">                <span class="keyword">if</span>(!dir[i]) <span class="keyword">return</span> ans;	<span class="comment">//不需要跳了，返回答案</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;dir[i];++j)&#123;<span class="comment">//开始跳dir[i]步</span></span><br><span class="line">                    x+=xx[i];</span><br><span class="line">                    y+=yy[i];</span><br><span class="line">                    ans.emplace_back(matrix[x][y]);</span><br><span class="line">                &#125;</span><br><span class="line">                dir[i]-=<span class="number">2</span>;<span class="comment">//内层每个方向要跳的步数减少二</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="把字符串转换成整数"><a href="#把字符串转换成整数" class="headerlink" title="把字符串转换成整数"></a><a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/">把字符串转换成整数</a></h4><p>写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。</p>
<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p>
<p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p>
<p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p>
<p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p>
<p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p>
<p><strong>说明：</strong></p>
<p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p>
<p>思路：模拟遍历。</p>
<p>判断越界的时候利用<strong>已获得的前缀和当前数字</strong>去比较INT最大最小值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strToInt</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> isNagetive=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(str[i]==<span class="string">&#x27; &#x27;</span>)i++;  <span class="comment">//跳过前面的空格,这里不会越界,因为最后有\n</span></span><br><span class="line">        <span class="keyword">if</span>(str[i]==<span class="string">&#x27;-&#x27;</span>)&#123;        <span class="comment">//负数</span></span><br><span class="line">            i++;</span><br><span class="line">            isNagetive=<span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[i]==<span class="string">&#x27;+&#x27;</span>)i++;   <span class="comment">//正数</span></span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;str.size();++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=str[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(tmp&lt;=<span class="number">9</span>&amp;&amp;tmp&gt;=<span class="number">0</span>)&#123; <span class="comment">//当前是数字</span></span><br><span class="line">                <span class="comment">/*现在的前缀大于最大(小)值前缀,或者现在的前缀等于最大(小)值前缀并且</span></span><br><span class="line"><span class="comment">                最后一位大于7的时候越界*/</span></span><br><span class="line">                <span class="keyword">if</span>(ans&gt;INT_MAX/<span class="number">10</span>||ans==INT_MAX/<span class="number">10</span>&amp;&amp;tmp&gt;<span class="number">7</span>)&#123; </span><br><span class="line">                    <span class="keyword">return</span> isNagetive?INT_MIN:INT_MAX;</span><br><span class="line">                &#125;</span><br><span class="line">                ans=ans*<span class="number">10</span>+tmp;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">break</span>;    <span class="comment">//遍历到不是数字了,返回答案</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isNagetive?-ans:ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="easy-2"><a href="#easy-2" class="headerlink" title="easy"></a>easy</h3><h4 id="叶子相似的树"><a href="#叶子相似的树" class="headerlink" title="叶子相似的树"></a><a href="https://leetcode-cn.com/problems/leaf-similar-trees/">叶子相似的树</a></h4><p>难度简单142</p>
<p>请考虑一棵二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个 <em>叶值序列</em> 。</p>
<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/16/tree.png" alt="img"></p>
<p>举个例子，如上图所示，给定一棵叶值序列为 <code>(6, 7, 4, 9, 8)</code> 的树。</p>
<p>如果有两棵二叉树的叶值序列是相同，那么我们就认为它们是 <em>叶相似</em> 的。</p>
<p>如果给定的两个根结点分别为 <code>root1</code> 和 <code>root2</code> 的树是叶相似的，则返回 <code>true</code>；否则返回 <code>false</code> 。</p>
<p>思路：前序遍历可以按左到右遍历这些叶结点，判断是不是叶结点按顺序加入数组，判断两次得到的数组是否相同得出答案。</p>
<p>时间复杂度O(n+m)n,m分别为两棵树的节点数</p>
<p>空间复杂度O(max(k1+n1,k2+n2))k1，k2分别为两棵树最大深度,n1,n2为叶值序列长度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">leafSimilar</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1,v2;</span><br><span class="line">        preorder(root1,v1);</span><br><span class="line">        preorder(root2,v2);</span><br><span class="line">        <span class="keyword">return</span> v1==v2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode* root,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        preorder(root-&gt;left,v);</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left&amp;&amp;!root-&gt;right)</span><br><span class="line">            v.emplace_back(root-&gt;val);</span><br><span class="line">        preorder(root-&gt;right,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="medium-3"><a href="#medium-3" class="headerlink" title="medium"></a>medium</h3><h4 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">树的子结构</a></h4><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p>
<p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p>
<p>思路：遍历找到A树所有B树根节点相同值的节点，以A树上的节点作头节点（A‘树），同时遍历A‘树和B树判断B是不是A‘的子结构。</p>
<p>另外的思路：bfs找A树所有B树根节点相同值的节点，再判断。</p>
<p>时间复杂度：O(MN)M为A的节点数，N为B的节点数</p>
<p>空间复杂度：O(M),当树 A 和树 B 都退化为链表时，递归调用深度最大。当 M ≤N 时，遍历树 A 与递归判断的总递归深度为 M ；当 M&gt;N 时，最差情况为遍历至树 A 叶子节点，此时总递归深度为 M。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!A||!B)<span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">//因为B为空不是子结构，而且A为空时，必没有子结构</span></span><br><span class="line">        <span class="comment">//判断A，B树是不是同根的子结构或者看看A的左子树和右子树有没有B的子结构</span></span><br><span class="line">        <span class="keyword">return</span> isSame(A,B)||isSubStructure(A-&gt;left,B)||isSubStructure(A-&gt;right,B);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSame</span><span class="params">(TreeNode* a,TreeNode* b)</span></span>&#123;</span><br><span class="line">        <span class="comment">//实际是遍历B树与A对应</span></span><br><span class="line">        <span class="keyword">if</span>(b==<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//当前节点相同时，继续判断左右子树</span></span><br><span class="line">        <span class="keyword">if</span>(a&amp;&amp;b&amp;&amp;a-&gt;val==b-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> isSame(a-&gt;left,b-&gt;left)&amp;&amp;isSame(a-&gt;right,b-&gt;right);</span><br><span class="line">        <span class="comment">//当A先为空时，或者A与B不同时，返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>超级压缩版</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> A&amp;&amp;B&amp;&amp;(isSame(A,B)||isSubStructure(A-&gt;left,B)||isSubStructure(A-&gt;right,B));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSame</span><span class="params">(TreeNode* a,TreeNode* b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!b)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(a&amp;&amp;a-&gt;val==b-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> isSame(a-&gt;left,b-&gt;left)&amp;&amp;isSame(a-&gt;right,b-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">二叉树中和为某一值的路径</a></h4><p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p>
<p><strong>示例:</strong><br>给定如下二叉树，以及目标和 <code>target = 22</code>，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      5</span><br><span class="line">     &#x2F; \</span><br><span class="line">    4   8</span><br><span class="line">   &#x2F;   &#x2F; \</span><br><span class="line">  11  13  4</span><br><span class="line"> &#x2F;  \    &#x2F; \</span><br><span class="line">7    2  5   1</span><br></pre></td></tr></table></figure>
<p>返回:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">   [5,4,11,2],</span><br><span class="line">   [5,8,4,5]</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>思路：简单的回溯，记录路径累积值和路径，当target与累计值相同时，保存路径。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;ans;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pathSum(TreeNode* root, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        dfs(root,<span class="number">0</span>,target,tmp);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root,<span class="keyword">int</span> curval,<span class="keyword">int</span> target,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp)</span></span>&#123;	</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">nullptr</span>&amp;&amp;root-&gt;right==<span class="literal">nullptr</span>)&#123;		<span class="comment">//叶结点</span></span><br><span class="line">            <span class="keyword">if</span>(target==curval+root-&gt;val)&#123;</span><br><span class="line">                tmp.emplace_back(root-&gt;val);				<span class="comment">//加入叶结点</span></span><br><span class="line">                ans.emplace_back(tmp);						<span class="comment">//保存路径</span></span><br><span class="line">                tmp.pop_back();								<span class="comment">//回溯</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ; </span><br><span class="line">        &#125;</span><br><span class="line">        tmp.emplace_back(root-&gt;val);				<span class="comment">//加入当前结点</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)dfs(root-&gt;left,curval+root-&gt;val,target,tmp);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)dfs(root-&gt;right,curval+root-&gt;val,target,tmp);</span><br><span class="line">        tmp.pop_back();			<span class="comment">//回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/">二叉搜索树与双向链表</a></h4><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p>
<p>思路：中序遍历，将前一个节点的右节点指向当前遍历节点，当前遍历节点的左节点指向前一个节点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        dfs(root);	中序遍历</span><br><span class="line">        <span class="keyword">if</span>(head)&#123;	<span class="comment">//如果有链表头结点</span></span><br><span class="line">            head-&gt;left=pre;	<span class="comment">//链表头结点右孩子指向最后遍历的节点</span></span><br><span class="line">            pre-&gt;right=head;<span class="comment">//最后遍历的节点左孩子指向链表头结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//pre前一个遍历的节点，head链表头结点</span></span><br><span class="line">    Node*pre =<span class="literal">nullptr</span>,*head=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> ;</span><br><span class="line">        dfs(root-&gt;left);</span><br><span class="line">        root-&gt;left=pre;	<span class="comment">//当前遍历节点的左节点指向前一个节点</span></span><br><span class="line">        <span class="comment">//前一个节点的右节点指向当前遍历节点</span></span><br><span class="line">        <span class="comment">//pre为空，root就是链表头结点</span></span><br><span class="line">        <span class="keyword">if</span>(pre)pre-&gt;right=root;</span><br><span class="line">        <span class="keyword">else</span> head=root;</span><br><span class="line">        pre=root;</span><br><span class="line">        dfs(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="hard-2"><a href="#hard-2" class="headerlink" title="hard"></a>hard</h3><h4 id="寻找两个正序数组的中位数"><a href="#寻找两个正序数组的中位数" class="headerlink" title="寻找两个正序数组的中位数"></a><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">寻找两个正序数组的中位数</a></h4><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums1 &#x3D; [1,3], nums2 &#x3D; [2]</span><br><span class="line">输出：2.00000</span><br><span class="line">解释：合并数组 &#x3D; [1,2,3] ，中位数 2</span><br></pre></td></tr></table></figure>
<p>思路：找出两个数组中第k小的数来代替找中位数。（两个数组长度总和为偶数则找第k和k+1个数，否则找第k+1个数（k=(len1+len2)/2））。</p>
<p>这里两个数组找第k小的元素的方法是：</p>
<p>从数组1找从index1开始第k/2个的数。</p>
<p>从数组2找从index2开始第k/2个的数。</p>
<p>比较大小，小于等于的那一行的可以排除是第k小的可能性。（因为它最多大于k-2个元素）</p>
<p>怎么排除？</p>
<p>修改相应index（index1，index2）index修改为newindex+1，还有k要减去减去元素的数量。</p>
<p>一直遍历，会出现2种情况。</p>
<p>情况1：找完了其中一个数组，还没找到第k小元素。也就是其中有一个数组所有元素都比第k小元素小。</p>
<p>这时候直接找长数组的index+k个元素就是所求。</p>
<p>情况2：k==1，说明找到了，直接拿最小的index的数。（这里肯定会剩一个以上，因为只会排除小于等于的那一行，另一行必然剩一个以上）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getKthnum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums1.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> m=nums2.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> index1=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(index1==n+<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> nums2[index2+k<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(index2==m+<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> nums1[index1+k<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(k==<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> min(nums1[index1],nums2[index2]);</span><br><span class="line">            <span class="keyword">int</span> newindex1=min(n,index1+k/<span class="number">2</span><span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">int</span> newindex2=min(m,index2+k/<span class="number">2</span><span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span>(nums1[newindex1]&gt;=nums2[newindex2])&#123;</span><br><span class="line">                k-=newindex2-index2+<span class="number">1</span>;</span><br><span class="line">                index2=newindex2+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                k-=newindex1-index1+<span class="number">1</span>;</span><br><span class="line">                index1=newindex1+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=nums1.size()+nums2.size();</span><br><span class="line">        <span class="keyword">if</span>(count%<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> getKthnum(nums1,nums2,count/<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (getKthnum(nums1,nums2,count/<span class="number">2</span>)+getKthnum(nums1,nums2,count/<span class="number">2</span>+<span class="number">1</span>))/<span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h3 id="medium-4"><a href="#medium-4" class="headerlink" title="medium"></a>medium</h3><h4 id="制作-m-束花所需的最少天数"><a href="#制作-m-束花所需的最少天数" class="headerlink" title="制作 m 束花所需的最少天数"></a><a href="https://leetcode-cn.com/problems/minimum-number-of-days-to-make-m-bouquets/">制作 m 束花所需的最少天数</a></h4><p>给你一个整数数组 <code>bloomDay</code>，以及两个整数 <code>m</code> 和 <code>k</code> 。</p>
<p>现需要制作 <code>m</code> 束花。制作花束时，需要使用花园中 <strong>相邻的 <code>k</code> 朵花</strong> 。</p>
<p>花园中有 <code>n</code> 朵花，第 <code>i</code> 朵花会在 <code>bloomDay[i]</code> 时盛开，<strong>恰好</strong> 可以用于 <strong>一束</strong> 花中。</p>
<p>请你返回从花园中摘 <code>m</code> 束花需要等待的最少的天数。如果不能摘到 <code>m</code> 束花则返回 <strong>-1</strong> 。</p>
<p>思路：对bloomDay数组范围二分，寻找满足条件的一个天数。</p>
<p>注意找到可行解后，可能还有更优解。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; bloomDay, <span class="keyword">int</span> m, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> right=*max_element(bloomDay.begin(),bloomDay.end());</span><br><span class="line">        <span class="keyword">int</span> left=*min_element(bloomDay.begin(),bloomDay.end());</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> bloomcount=<span class="number">0</span>,conbloom=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bloomDay.size();++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(bloomDay[i]&lt;=mid)&#123;</span><br><span class="line">                    ++conbloom;</span><br><span class="line">                    <span class="keyword">if</span>(conbloom==k)&#123;</span><br><span class="line">                        conbloom=<span class="number">0</span>;</span><br><span class="line">                        ++bloomcount;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    conbloom=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(bloomcount&gt;=m)&#123;</span><br><span class="line">                ans=mid;</span><br><span class="line">                right=mid<span class="number">-1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bloomcount&lt;m)&#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right=mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="回文"><a href="#回文" class="headerlink" title="回文"></a>回文</h2><h3 id="easy-3"><a href="#easy-3" class="headerlink" title="easy"></a>easy</h3><h4 id="回文数"><a href="#回文数" class="headerlink" title="回文数"></a><a href="https://leetcode-cn.com/problems/palindrome-number/">回文数</a></h4><p>给你一个整数 <code>x</code> ，如果 <code>x</code> 是一个回文整数，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，<code>121</code> 是回文，而 <code>123</code> 不是。</p>
<p> <strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：x &#x3D; 121</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：x &#x3D; -121</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p>思路1：先转字符串，然后前后判断。</p>
<p>思路2：把后面一半的数拿出来倒过来组成新的数，看看是不是与前面半段相等。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>||x%<span class="number">10</span>==<span class="number">0</span>&amp;&amp;x!=<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//非0的末尾位是0的数和负数</span></span><br><span class="line">        <span class="built_in">string</span> str=to_string(x);</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=str.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(;l&lt;r;++l,--r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[l]!=str[r])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>||x%<span class="number">10</span>==<span class="number">0</span>&amp;&amp;x!=<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> reverseNum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(reverseNum&lt;x)&#123;		<span class="comment">//一直判断到中间</span></span><br><span class="line">            reverseNum*=<span class="number">10</span>;			<span class="comment">//先空出个位</span></span><br><span class="line">            reverseNum+=x%<span class="number">10</span>;		<span class="comment">//取x的最后一位</span></span><br><span class="line">            x/=<span class="number">10</span>;					<span class="comment">//去掉x最后一位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reverseNum==x||(reverseNum/<span class="number">10</span>==x);<span class="comment">//偶数和单数个数字</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="验证回文串"><a href="#验证回文串" class="headerlink" title="验证回文串"></a><a href="https://leetcode-cn.com/problems/valid-palindrome/">验证回文串</a></h4><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p>
<p><strong>说明：</strong>本题中，我们将空字符串定义为有效的回文串。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p>思路1：直接存反转后的判断二者是不是相等。</p>
<p>时间复杂度O（N）</p>
<p>空间复杂度O（N）</p>
<p>思路2：双指针</p>
<p>双指针放在前后，往中间判断，不同就返回false。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">       <span class="built_in">string</span> alnumstr=<span class="string">&quot;&quot;</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">auto</span> ch:s)&#123;</span><br><span class="line">           <span class="keyword">if</span>(<span class="built_in">isalnum</span>(ch))</span><br><span class="line">                alnumstr+=<span class="built_in">toupper</span>(ch);</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="comment">/* string str_rev=alnumstr;      </span></span><br><span class="line"><span class="comment">     * reverse(str_rev.begin(),str_rev.end());  //反转</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">str_rev</span><span class="params">(alnumstr.rbegin(), alnumstr.rend())</span></span>; <span class="comment">//反转</span></span><br><span class="line">        <span class="keyword">return</span> str_rev==alnumstr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=s.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r&amp;&amp;!<span class="built_in">isalnum</span>(s[l]))++l;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r&amp;&amp;!<span class="built_in">isalnum</span>(s[r]))--r;</span><br><span class="line">            <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">toupper</span>(s[l])!=<span class="built_in">toupper</span>(s[r]))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                l++;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h2><h3 id="medium-5"><a href="#medium-5" class="headerlink" title="medium"></a>medium</h3><h4 id="解码异或后的排列"><a href="#解码异或后的排列" class="headerlink" title="解码异或后的排列"></a><a href="https://leetcode-cn.com/problems/decode-xored-permutation/">解码异或后的排列</a></h4><p>给你一个整数数组 <code>perm</code> ，它是前 <code>n</code> 个正整数的排列，且 <code>n</code> 是个 <strong>奇数</strong> 。</p>
<p>它被加密成另一个长度为 <code>n - 1</code> 的整数数组 <code>encoded</code> ，满足 <code>encoded[i] = perm[i] XOR perm[i + 1]</code> 。比方说，如果 <code>perm = [1,3,2]</code> ，那么 <code>encoded = [2,1]</code> 。</p>
<p>给你 <code>encoded</code> 数组，请你返回原始数组 <code>perm</code> 。题目保证答案存在且唯一。</p>
<p> <strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：encoded &#x3D; [3,1]</span><br><span class="line">输出：[1,2,3]</span><br><span class="line">解释：如果 perm &#x3D; [1,2,3] ，那么 encoded &#x3D; [1 XOR 2,2 XOR 3] &#x3D; [3,1]</span><br></pre></td></tr></table></figure>
<p>思路：先求出1-n的异或allxor。allxor=encoded[0]^encoded[1]^encoded[2]····^encoded[n-1] ①</p>
<p>perm[0]=encoded[0]^encoded[1]</p>
<p>perm[1]=encoded[1]^encoded[2]  ②</p>
<p>perm[3]=encoded[3]^encoded[4]  ③</p>
<p>perm[5]=encoded[5]^encoded[6]  ④</p>
<p>将②③④等奇数序号perm代入①得</p>
<p>allxor=encoded[0]^perm[1]^perm[3]^perm[5]·······</p>
<p>求出xor1toN=perm[1]^perm[3]^perm[5]·······</p>
<p>那么encoded[0]=xor1toN^allxor</p>
<p>由encoded[0]^encoded[1]=perm[0]得</p>
<p>encoded[1]=encoded[0]^perm[0]。</p>
<p>如此类推。</p>
<p>注意前1-n的异或可以O（1）得出</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(n%<span class="number">4</span>)&#123;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">0</span>:allxor=n+<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">1</span>:allxor=<span class="number">1</span>;  <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">2</span>:allxor=n+<span class="number">2</span>;<span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">3</span>:allxor=<span class="number">0</span>;  <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>拓展：同理 k-n的连续异或(knxor)也可以由1-k的异或(kxor)和1-n(nxor)的异或求出。</p>
<p>knxor=kxor^nxor</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">decode</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; encoded)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> allxor=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// for(int i=1;i&lt;=encoded.size()+1;i++)	</span></span><br><span class="line">        <span class="comment">//     allxor^=i;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n=encoded.size()+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">switch</span>(n%<span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:allxor=n+<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:allxor=<span class="number">1</span>;  <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:allxor=n+<span class="number">2</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:allxor=<span class="number">0</span>;  <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> xor1toN=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;encoded.size();i+=<span class="number">2</span>)</span><br><span class="line">            xor1toN^=encoded[i];</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> tmp=allxor^xor1toN;</span><br><span class="line">        ans.emplace_back(tmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:encoded)</span><br><span class="line">            ans.emplace_back(tmp^=x);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="找出第-K-大的异或坐标值"><a href="#找出第-K-大的异或坐标值" class="headerlink" title="找出第 K 大的异或坐标值"></a><a href="https://leetcode-cn.com/problems/find-kth-largest-xor-coordinate-value/">找出第 K 大的异或坐标值</a></h4><p>给你一个二维矩阵 <code>matrix</code> 和一个整数 <code>k</code> ，矩阵大小为 <code>m x n</code> 由非负整数组成。</p>
<p>矩阵中坐标 <code>(a, b)</code> 的 <strong>值</strong> 可由对所有满足 <code>0 &lt;= i &lt;= a &lt; m</code> 且 <code>0 &lt;= j &lt;= b &lt; n</code> 的元素 <code>matrix[i][j]</code>（<strong>下标从 0 开始计数</strong>）执行异或运算得到。</p>
<p>请你找出 <code>matrix</code> 的所有坐标中第 <code>k</code> 大的值（<strong><code>k</code> 的值从 1 开始计数</strong>）。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[5,2],[1,6]], k &#x3D; 1</span><br><span class="line">输出：7</span><br><span class="line">解释：坐标 (0,1) 的值是 5 XOR 2 &#x3D; 7 ，为最大的值。</span><br></pre></td></tr></table></figure>
<p>思路：要求异或坐标值需要左上角所有的元素（包括自己的行和列和自己）异或和。要求matrix [i] [j]时matrix [i-1] [j-1]和matrix [i-1] [j]和matrix [i] [j-1]都已经求得，而matrix [i] [j-1]和matrix [i-1] [j]区域重合了matrix [i-1] [j-1]的区域，所以要求matrix [i] [j]需要补上matrix [i-1] [j-1]区域所以得出</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">matrix[i][j]=matrix[i][j]^matrix[i<span class="number">-1</span>][j]^matrix[i][j<span class="number">-1</span>]^matrix[i][j]</span><br></pre></td></tr></table></figure>
<p>然后就是求出第k大元素，用堆(nmlogk)或者快速选择算法（nm，最坏nm^2），或者排序（nmlognm）都可以。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthLargestValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m=matrix.size();</span><br><span class="line">        <span class="keyword">int</span> n=matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; helper;</span><br><span class="line">        helper.emplace_back(matrix[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;++i)&#123;		<span class="comment">//求第一列</span></span><br><span class="line">            matrix[i][<span class="number">0</span>]=matrix[i][<span class="number">0</span>]^matrix[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">            helper.emplace_back(matrix[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;		<span class="comment">//求第一行</span></span><br><span class="line">            matrix[<span class="number">0</span>][i]=matrix[<span class="number">0</span>][i]^matrix[<span class="number">0</span>][i<span class="number">-1</span>];</span><br><span class="line">            helper.emplace_back(matrix[<span class="number">0</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;++j)&#123;</span><br><span class="line">                matrix[i][j]^=matrix[i<span class="number">-1</span>][j]^matrix[i][j<span class="number">-1</span>]^matrix[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                helper.emplace_back(matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        nth_element(helper.begin(),helper.begin()+k<span class="number">-1</span>,helper.end(),greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">return</span> helper[k<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="hard-3"><a href="#hard-3" class="headerlink" title="hard"></a>hard</h3><h4 id="与数组中元素的最大异或值"><a href="#与数组中元素的最大异或值" class="headerlink" title="与数组中元素的最大异或值"></a><a href="https://leetcode-cn.com/problems/maximum-xor-with-an-element-from-array/">与数组中元素的最大异或值</a></h4><p>给你一个由非负整数组成的数组 <code>nums</code> 。另有一个查询数组 <code>queries</code> ，其中 <code>queries[i] = [xi, mi]</code> 。</p>
<p>第 <code>i</code> 个查询的答案是 <code>xi</code> 和任何 <code>nums</code> 数组中不超过 <code>mi</code> 的元素按位异或（<code>XOR</code>）得到的最大值。换句话说，答案是 <code>max(nums[j] XOR xi)</code> ，其中所有 <code>j</code> 均满足 <code>nums[j] &lt;= mi</code> 。如果 <code>nums</code> 中的所有元素都大于 <code>mi</code>，最终答案就是 <code>-1</code> 。</p>
<p>返回一个整数数组 <code>answer</code> 作为查询的答案，其中 <code>answer.length == queries.length</code> 且 <code>answer[i]</code> 是第 <code>i</code> 个查询的答案。</p>
<p>思路：用nums中元素二进制构建前缀树，在前缀树中尽可能的找最大异或值，每个节点存放该子树和自身的最小值，寻找的时候需要兼顾找最大异或和保持不大于mi（这个更优先）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> minsonval=INT_MAX;	<span class="comment">//该子树和自身的最小值</span></span><br><span class="line">        <span class="keyword">int</span> index;	<span class="comment">//如果是叶结点，就存放元素在nums的序号</span></span><br><span class="line">        inode* zero,* one;		<span class="comment">//子节点</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">prefixtree</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        inode* head;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        prefixtree()&#123;</span><br><span class="line">            head=<span class="keyword">new</span> inode();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">insertNode</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> index)</span></span>&#123;	<span class="comment">//插入nums[index]</span></span><br><span class="line">            inode* cur=head;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">30</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp=(nums[index]/(<span class="number">1</span>&lt;&lt;i))&amp;<span class="number">1</span>;		<span class="comment">//从最高位依次取位</span></span><br><span class="line">                <span class="keyword">if</span>(tmp==<span class="number">1</span>)&#123;		<span class="comment">//建树</span></span><br><span class="line">                    <span class="keyword">if</span>(!cur-&gt;one)cur-&gt;one=<span class="keyword">new</span> inode();</span><br><span class="line">                    cur-&gt;minsonval=min(cur-&gt;minsonval,nums[index]);</span><br><span class="line">                    cur=cur-&gt;one;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!cur-&gt;zero)cur-&gt;zero=<span class="keyword">new</span> inode();</span><br><span class="line">                    cur-&gt;minsonval=min(cur-&gt;minsonval,nums[index]);</span><br><span class="line">                    cur=cur-&gt;zero;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cur-&gt;minsonval=nums[index]; <span class="comment">//cur==叶结点</span></span><br><span class="line">            cur-&gt;index=index;	<span class="comment">//存放序号</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找x和nums中小于m的元素异或的最大值</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">searchMAXXOR</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> x,<span class="keyword">int</span> m)</span></span>&#123;	</span><br><span class="line">            inode* cur=head;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">30</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp=(x/(<span class="number">1</span>&lt;&lt;i))&amp;<span class="number">1</span>;<span class="comment">//x从最高位依次取位</span></span><br><span class="line">                inode* tmpcur=cur;	<span class="comment">//保存cur指针</span></span><br><span class="line">                <span class="keyword">if</span>(tmp==<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">//先判断是否为空，再判断是否小于m,优先看与tmp相反的zero，下同</span></span><br><span class="line">                    <span class="keyword">if</span>(cur-&gt;zero&amp;&amp;cur-&gt;zero-&gt;minsonval&lt;=m) cur=cur-&gt;zero;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(cur-&gt;one&amp;&amp;cur-&gt;one-&gt;minsonval&lt;=m)cur=cur-&gt;one;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                     <span class="keyword">if</span>(cur-&gt;one&amp;&amp;cur-&gt;one-&gt;minsonval&lt;=m)cur=cur-&gt;one;</span><br><span class="line">                     <span class="keyword">else</span> <span class="keyword">if</span>(cur-&gt;zero&amp;&amp;cur-&gt;zero-&gt;minsonval&lt;=m) cur=cur-&gt;zero;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur==tmpcur) <span class="keyword">return</span> <span class="number">-1</span>;	<span class="comment">//cur没有改变，说明没有满足小于m的数</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> nums[cur-&gt;index]^x;	<span class="comment">//到了叶结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maximizeXor</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        prefixtree tree;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();++i)</span><br><span class="line">            tree.insertNode(nums,i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; query:queries)</span><br><span class="line">            ans.emplace_back(tree.searchMAXXOR(nums,query[<span class="number">0</span>],query[<span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h2><h3 id="medium-6"><a href="#medium-6" class="headerlink" title="medium"></a>medium</h3><h4 id="数组中两个数的最大异或值"><a href="#数组中两个数的最大异或值" class="headerlink" title="数组中两个数的最大异或值"></a><a href="https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/">数组中两个数的最大异或值</a></h4><p>给你一个整数数组 <code>nums</code> ，返回 <code>nums[i] XOR nums[j]</code> 的最大运算结果，其中 <code>0 ≤ i ≤ j &lt; n</code> 。</p>
<p><strong>进阶：</strong>你可以在 <code>O(n)</code> 的时间解决这个问题吗？</p>
<p> <strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [3,10,5,25,2,8]</span><br><span class="line">输出：28</span><br><span class="line">解释：最大运算结果是 5 XOR 25 &#x3D; 28.</span><br></pre></td></tr></table></figure>
<p>思路：由于题目是选两个数异或，而且还可以选自己跟自己异或所以下界是0。</p>
<p>本题可以使用字典树（前缀树）来做。</p>
<p>将每个数字转成字符串然后从最高位开始存。</p>
<p>构造一个32位树高的前缀树(含一个头节点)。</p>
<p>然后遍历数组想办法从树里找到尽可能每一位跟当前遍历到的数（x）相反的数(y)。</p>
<p>比如101要尽力去找010。</p>
<p>然后比较每一个x^y,找出最大值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span>	<span class="comment">//树的节点</span></span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">-1</span>;	<span class="comment">//叶结点会存放在nums数组的序号</span></span><br><span class="line">        node* zero;</span><br><span class="line">        node* one;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">prefixTree</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        node* top;	<span class="comment">//头结点</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        prefixTree()&#123;</span><br><span class="line">            top=<span class="keyword">new</span> node();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> index)</span></span>&#123;<span class="comment">//num加入前缀树，index是num在nums的序号</span></span><br><span class="line">            node* cur=top;			<span class="comment">//当前处理的节点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">30</span>;i&gt;=<span class="number">0</span>;i--)&#123;	.<span class="comment">//从最高位开始找</span></span><br><span class="line">                <span class="keyword">int</span> tmp=(num&gt;&gt;i)&amp;<span class="number">1</span>;	<span class="comment">//找到第i位的数  0或者1</span></span><br><span class="line">                <span class="keyword">if</span>(tmp==<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!cur-&gt;one)cur-&gt;one=<span class="keyword">new</span> node();	<span class="comment">//没有就构造,下面同理</span></span><br><span class="line">                    cur=cur-&gt;one;		<span class="comment">//更新cur</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!cur-&gt;zero)cur-&gt;zero=<span class="keyword">new</span> node();</span><br><span class="line">                    cur=cur-&gt;zero;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cur-&gt;index=index;	<span class="comment">//叶结点存放num在nums的序号。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">findMAXXORnum</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;	<span class="comment">//找到树里尽量每一位和num相反的数</span></span><br><span class="line">            node* cur=top;			<span class="comment">//当前处理的节点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">30</span>;i&gt;=<span class="number">0</span>;i--)&#123;	</span><br><span class="line">                <span class="keyword">int</span> tmp=(num&gt;&gt;i)&amp;<span class="number">1</span>;		<span class="comment">//找到num第i位的数  0或者1</span></span><br><span class="line">                <span class="keyword">if</span>(!cur-&gt;one&amp;&amp;!cur-&gt;zero)	<span class="comment">//叶结点返回找到的数在nums的序号</span></span><br><span class="line">                    <span class="keyword">return</span> cur-&gt;index;</span><br><span class="line">                <span class="keyword">if</span>(tmp==<span class="number">1</span>)&#123;			<span class="comment">//1的话转到0</span></span><br><span class="line">                    <span class="keyword">if</span>(cur-&gt;zero) cur=cur-&gt;zero; </span><br><span class="line">                    <span class="keyword">else</span> cur=cur-&gt;one;	<span class="comment">//没有0只能转1</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;				<span class="comment">//0的话转到1</span></span><br><span class="line">                    <span class="keyword">if</span>(cur-&gt;one)cur=cur-&gt;one;</span><br><span class="line">                    <span class="keyword">else</span> cur=cur-&gt;zero;	<span class="comment">//没有1只能转0</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cur-&gt;index;	<span class="comment">//叶结点返回找到的数在nums的序号</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        prefixTree tree;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)	<span class="comment">//将nums全部加入前缀树</span></span><br><span class="line">            tree.add(nums[i],i);</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;		<span class="comment">//下界是0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">int</span> index=tree.findMAXXORnum(num);<span class="comment">//找到树里尽量每一位和num相反的数</span></span><br><span class="line">            ans=max(ans,nums[index]^num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>思路2：int31位。从最高位开始找，如果可以设置为1就设置为1。</p>
<p>怎么判断可以设置1？</p>
<p>set存放数组里所有数的前K位。示例：xxxxx?????存放xxxxx</p>
<p>首先先设置为1</p>
<p>可以得到xxxx1????(前面是已经找到的最优解)截取前面的得到xxxx1</p>
<p>数组里其他截取前面的得到abcde</p>
<p>二者相与得到一个fghij，如果fghij在set中说明设置1是可行的。</p>
<p>不然只能设置为0</p>
<p>然后继续判断下一位。</p>
<p>为什么fghij在set中就说明设置1是可行的？</p>
<p>因为前面的fghi也可以在前k-1位set也可以找到。</p>
<p>由此类推。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">30</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; st;	<span class="comment">//存放nums中的每一个元素的前30-i位。</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> num:nums)&#123;</span><br><span class="line">                st.insert(num&gt;&gt;i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> tmp_ans=ans*<span class="number">2</span>+<span class="number">1</span>;	<span class="comment">//先设置为1</span></span><br><span class="line">            <span class="keyword">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">                <span class="keyword">if</span>(st.count(tmp_ans^(num&gt;&gt;i)))&#123;		<span class="comment">//找到了</span></span><br><span class="line">                    flag=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag) ans = tmp_ans;</span><br><span class="line">            <span class="keyword">else</span> ans = tmp_ans - <span class="number">1</span>;			<span class="comment">//没找到就取消设置为1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><h3 id="medium-7"><a href="#medium-7" class="headerlink" title="medium"></a>medium</h3><h4 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a><a href="https://leetcode-cn.com/problems/permutations/">全排列</a></h4><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <strong>所有可能的全排列</strong> 。你可以 <strong>按任意顺序</strong> 返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure>
<p>思路：简单的回溯，依次确定第i位的可能值。确定到最后一位就是一种解。</p>
<p>时间复杂度O（nn!）    </p>
<p>空间复杂度O（n）除了答案数组以外。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        len=nums.size();	</span><br><span class="line">        slove(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(len<span class="number">-1</span>==i)&#123;		<span class="comment">//判断到了最后一位</span></span><br><span class="line">            ans.emplace_back(nums);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;len;++j)&#123;</span><br><span class="line">            swap(nums[i],nums[j]);	<span class="comment">//将选中的后面的位跟现在i位交换</span></span><br><span class="line">            slove(nums,i+<span class="number">1</span>);		<span class="comment">//找i+1位后的全排列</span></span><br><span class="line">            swap(nums[i],nums[j]);	<span class="comment">//交换回去</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/">矩阵中的路径</a></h4><p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<p> <strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：board &#x3D; [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word &#x3D; &quot;ABCCED&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p>思路：dfs搜索路径是否等于word，加入剪枝。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">4</span>]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;<span class="comment">//方向数组</span></span><br><span class="line">    <span class="keyword">int</span> dy[<span class="number">4</span>]&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> colsize=<span class="number">0</span>,rowsize=<span class="number">0</span>; 	<span class="comment">//行列数</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board,<span class="built_in">string</span>&amp; word,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> dep)</span></span>&#123;</span><br><span class="line">        <span class="comment">//不满足条件的返回false</span></span><br><span class="line">        <span class="keyword">if</span>(x&gt;=rowsize||x&lt;<span class="number">0</span>||y&gt;=colsize||y&lt;<span class="number">0</span>||board[x][y]!=word[dep])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//已经深搜到最后一个字母，并且满足条件board[x][y]=word[dep]</span></span><br><span class="line">        <span class="keyword">if</span>(dep==word.size()<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        board[x][y]=<span class="string">&#x27;\n&#x27;</span>;	<span class="comment">//把现在走过的字母先修改成不可能的字符</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dfs(board,word,x+dx[i],y+dy[i],dep+<span class="number">1</span>))&#123;<span class="comment">//找到一条就返回</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        board[x][y]=word[dep];	<span class="comment">//把字母恢复，给其他路径走</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">//找不到路径</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        rowsize=board.size();</span><br><span class="line">        colsize=board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rowsize;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;board[<span class="number">0</span>].size();++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(board,word,i,j,<span class="number">0</span>))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h2><h3 id="medium-8"><a href="#medium-8" class="headerlink" title="medium"></a>medium</h3><h4 id="二叉树的锯齿形层序遍历"><a href="#二叉树的锯齿形层序遍历" class="headerlink" title=" 二叉树的锯齿形层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/"> 二叉树的锯齿形层序遍历</a></h4><p>给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>
<p>例如：<br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>返回锯齿形层序遍历如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>思路：进行普通的层次遍历，将每层结果存在deque，若需要倒序的层，则头插，不然就尾插。然后类型转到vector，</p>
<p>空间复杂度O（n）n为树节点个数</p>
<p>时间复杂度O（n）</p>
<p>提交答案</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode *&gt; que;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> ans;</span><br><span class="line">        que.push(root); </span><br><span class="line">        <span class="keyword">int</span> dep = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> len = que.size();</span><br><span class="line">            <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; valque;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                TreeNode* tmp = que.front();</span><br><span class="line">                que.pop();</span><br><span class="line">                <span class="keyword">if</span>(dep%<span class="number">2</span>) <span class="comment">//该层不需要反转</span></span><br><span class="line">                    valque.push_back(tmp-&gt;val);</span><br><span class="line">                <span class="keyword">else</span>	<span class="comment">////该层需要反转</span></span><br><span class="line">                    valque.push_front(tmp-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;left)</span><br><span class="line">                    que.push(tmp-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;right)</span><br><span class="line">                    que.push(tmp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            dep++;</span><br><span class="line">            ans.emplace_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;valque.begin(),valque.end()&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>思路2：将节点存在deque，下一层需反转的，取队头，然后子节点放在队尾，先放左节点，后放右节点。</p>
<p>​                                     下一层不需翻转的，取队尾，子节点插队头，先放右节点，再放左节点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">deque</span>&lt;TreeNode*&gt;que;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> ans;</span><br><span class="line">        que.push_back(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmpv1;</span><br><span class="line">            <span class="keyword">int</span> len=que.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                TreeNode* tmp=que.front();</span><br><span class="line">                que.pop_front();</span><br><span class="line">                tmpv1.emplace_back(tmp-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;left)que.push_back(tmp-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;right)que.push_back(tmp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(tmpv1);</span><br><span class="line">            <span class="keyword">if</span>(que.empty())<span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmpv2;</span><br><span class="line">            len=que.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=len;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">                TreeNode* tmp=que.back();</span><br><span class="line">                que.pop_back();</span><br><span class="line">                tmpv2.emplace_back(tmp-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;right)que.push_front(tmp-&gt;right);</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;left)que.push_front(tmp-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(tmpv2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">机器人的运动范围</a></h4><p>地上有一个m行n列的方格，从坐标 <code>[0,0]</code> 到坐标 <code>[m-1,n-1]</code> 。一个机器人从坐标 <code>[0, 0]</code>的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：m &#x3D; 2, n &#x3D; 3, k &#x3D; 1</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<p>思路：层次遍历，满足条件的可以前进，可以优化前进方向为向右或向下。</p>
<p>时间复杂度O(<script type="math/tex">mn</script>)</p>
<p>空间复杂度O(<script type="math/tex">mn</script>)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x)&#123;</span><br><span class="line">            ans+=x%<span class="number">10</span>;</span><br><span class="line">            x/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; isvisit(m,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n,<span class="literal">false</span>));</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; que;<span class="comment">//分别表示x,y</span></span><br><span class="line">        que.push(&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">int</span> dx[<span class="number">2</span>]&#123;<span class="number">0</span>,<span class="number">1</span>&#125;;<span class="comment">//方向数组</span></span><br><span class="line">        <span class="keyword">int</span> dy[<span class="number">2</span>]&#123;<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        isvisit[<span class="number">0</span>][<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">            <span class="keyword">auto</span> tmp=que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> xx=tmp.first+dx[i];</span><br><span class="line">                <span class="keyword">int</span> yy=tmp.second+dy[i];</span><br><span class="line">                <span class="keyword">if</span>(xx&gt;=<span class="number">0</span>&amp;&amp;xx&lt;m&amp;&amp;yy&gt;=<span class="number">0</span>&amp;&amp;yy&lt;n&amp;&amp;!isvisit[xx][yy]&amp;&amp;getsum(xx)+getsum(yy)&lt;=k)&#123;</span><br><span class="line">                    isvisit[xx][yy]=<span class="literal">true</span>;</span><br><span class="line">                    que.push(<span class="built_in">make_pair</span>(xx,yy));</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="环形回路"><a href="#环形回路" class="headerlink" title="环形回路"></a>环形回路</h2><h3 id="medium-9"><a href="#medium-9" class="headerlink" title="medium"></a>medium</h3><h4 id="环形链表-II"><a href="#环形链表-II" class="headerlink" title="环形链表 II"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">环形链表 II</a></h4><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code>。</p>
<p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意，<code>pos</code> 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</strong></p>
<p><strong>说明：</strong>不允许修改给定的链表。</p>
<p><strong>进阶：</strong></p>
<ul>
<li>你是否可以使用 <code>O(1)</code> 空间解决此题？</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>
<p>判断链表是否有环，用快慢指针。</p>
<p><img src="https://assets.leetcode-cn.com/solution-static/142/142_fig1.png" alt="图"></p>
<script type="math/tex; mode=display">a+(n+1)b+nc=2(a+b)⟹a=c+(n−1)(b+c)</script><p>当n=1时a=c</p>
<p>所以在快慢指针相遇时，新建一个头指针，慢指针和新指针同时走相同的步数时，会在入口处相遇</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast=head;<span class="comment">//head指针充当慢指针</span></span><br><span class="line">        ListNode* ans=head;<span class="comment">//新指针</span></span><br><span class="line">        <span class="keyword">while</span>(fast&amp;&amp;fast-&gt;next)&#123;	<span class="comment">//fast指针判空，由于链表数奇偶的关系，需要判断next和fast，这里退出说明无环</span></span><br><span class="line">            fast=fast-&gt;next-&gt;next;</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(head==fast)&#123;				<span class="comment">//slow和fast相遇</span></span><br><span class="line">                <span class="keyword">while</span>(ans!=head)&#123;		<span class="comment">//slow和新指针同步向前直到相遇</span></span><br><span class="line">                    head=head-&gt;next;</span><br><span class="line">                    ans=ans-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h2><h3 id="esay"><a href="#esay" class="headerlink" title="esay"></a>esay</h3><h4 id="翻转单词顺序"><a href="#翻转单词顺序" class="headerlink" title="翻转单词顺序"></a><a href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/">翻转单词顺序</a></h4><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;the sky is blue&quot;</span><br><span class="line">输出: &quot;blue is sky the&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;  hello world!  &quot;</span><br><span class="line">输出: &quot;world! hello&quot;</span><br><span class="line">解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;a good   example&quot;</span><br><span class="line">输出: &quot;example good a&quot;</span><br><span class="line">解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span><br></pre></td></tr></table></figure>
<p>思路：先全部翻转，然后把每一个单词翻转，然后去掉前面和后面的所有空格和中间的多余空格。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        reverse(s.begin(),s.end());	<span class="comment">//全部翻转</span></span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;s.size())&#123;</span><br><span class="line">            <span class="keyword">while</span>(s[left]==<span class="string">&#x27; &#x27;</span>)	<span class="comment">//跳过空格</span></span><br><span class="line">                ++left;</span><br><span class="line">            right=left;</span><br><span class="line">            <span class="keyword">while</span>(right&lt;s.size()&amp;&amp;s[right]!=<span class="string">&#x27; &#x27;</span>)<span class="comment">//到单词的末尾或者字符末尾</span></span><br><span class="line">                ++right;</span><br><span class="line">            reverse(s.begin()+left,s.begin()+right);<span class="comment">//翻转这个单词</span></span><br><span class="line">            ++right;	<span class="comment">//到下一个位置</span></span><br><span class="line">            left=right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        left=<span class="number">0</span>;</span><br><span class="line">        right=s.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(s[left]==<span class="string">&#x27; &#x27;</span>)<span class="comment">//找最前面不是空格的，这里由于空串s[0]==&#x27;\n&#x27;所有不用判断越界</span></span><br><span class="line">            ++left;</span><br><span class="line">        <span class="keyword">while</span>(right&gt;=<span class="number">0</span>&amp;&amp;s[right]==<span class="string">&#x27; &#x27;</span>)<span class="comment">//找最后面不是空格的字母</span></span><br><span class="line">            --right;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=left;j&lt;=right;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!count)	<span class="comment">//第一次遇到空格</span></span><br><span class="line">                    ans.push_back(s[j]);</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                count=<span class="number">0</span>;	<span class="comment">//遇到非空格清0</span></span><br><span class="line">                ans.push_back(s[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="字符串相加"><a href="#字符串相加" class="headerlink" title="字符串相加"></a><a href="https://leetcode-cn.com/problems/add-strings/">字符串相加</a></h4><p>给定两个字符串形式的非负整数 <code>num1</code> 和<code>num2</code> ，计算它们的和。</p>
<p><strong>提示：</strong></p>
<ol>
<li><code>num1</code> 和<code>num2</code> 的长度都小于 5100</li>
<li><code>num1</code> 和<code>num2</code> 都只包含数字 <code>0-9</code></li>
<li><code>num1</code> 和<code>num2</code> 都不包含任何前导零</li>
<li><strong>你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式</strong></li>
</ol>
<p>思路：将num2加到num1上，模拟加法，双指针指向两个字符串尾部，往前加，维持一个变量pre表示进位。</p>
<p>边界处理：</p>
<p>保证num1长度大于等于num2,注意加完num2可能还有进位。</p>
<p>可能结果大于num1的长度，即最后有进位。举例：99+1=100</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addStrings</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num2.size()&gt;num1.size())<span class="comment">//保证num1长度大于等于num2</span></span><br><span class="line">            num1.swap(num2);</span><br><span class="line">        <span class="comment">//index为指针，指向最后一位数，注意有换行符</span></span><br><span class="line">        <span class="keyword">int</span> index1=num1.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> pre=<span class="number">0</span>,tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> index2=num2.size()<span class="number">-1</span>;index1&gt;=<span class="number">0</span>;index1--,index2--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(index2&gt;=<span class="number">0</span>)		<span class="comment">//处理num1，num2都有的情况</span></span><br><span class="line">                tmp=num1[index1]-<span class="string">&#x27;0&#x27;</span>+num2[index2]-<span class="string">&#x27;0&#x27;</span>+pre;</span><br><span class="line">            <span class="keyword">else</span>&#123;				<span class="comment">//只剩num1</span></span><br><span class="line">                <span class="keyword">if</span>(!pre)<span class="keyword">break</span>;	<span class="comment">//没有进位了可以退出</span></span><br><span class="line">                tmp=num1[index1]-<span class="string">&#x27;0&#x27;</span>+pre;</span><br><span class="line">            &#125;</span><br><span class="line">            num1[index1]=tmp%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            pre=tmp/<span class="number">10</span>;	<span class="comment">//确定是否有进位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pre) num1.insert(num1.begin(),<span class="string">&#x27;1&#x27;</span>) ;<span class="comment">//最后一位没进，补上1在前面</span></span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="medium-10"><a href="#medium-10" class="headerlink" title="medium"></a>medium</h3><h4 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">把数组排成最小的数</a></h4><p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [10,2]</span><br><span class="line">输出: &quot;102&quot;</span><br></pre></td></tr></table></figure>
<p>思路：自定义排序，将两个数拼接在一起，判断哪个数在前面更小。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; strs;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">int</span>&amp; num:nums)</span><br><span class="line">            strs.emplace_back(to_string(num));</span><br><span class="line">        sort(strs.begin(),strs.end(),[](<span class="built_in">string</span>&amp; a,<span class="built_in">string</span>&amp; b)&#123;</span><br><span class="line">            <span class="keyword">return</span> a+b&lt;b+a;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">string</span> ans=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str:strs)</span><br><span class="line">            ans+=str;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="构建乘积数组"><a href="#构建乘积数组" class="headerlink" title="构建乘积数组"></a><a href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/">构建乘积数组</a></h4><p>给定一个数组 <code>A[0,1,…,n-1]</code>，请构建一个数组 <code>B[0,1,…,n-1]</code>，其中 <code>B[i]</code> 的值是数组 <code>A</code> 中除了下标 <code>i</code> 以外的元素的积, 即 <code>B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]</code>。<strong>不能使用除法。</strong></p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: [120,60,40,30,24]</span><br></pre></td></tr></table></figure>
<p>思路：注意不能使用除法，而且就算使用除法也需要判断<code>A[i]</code>是不是等于0，</p>
<p>可以分两次遍历完成，第一遍从前往后遍历把<code>A[0]×A[1]×…×A[i-1]</code>存入<code>B[i]</code></p>
<p>第二遍从后往前遍历把<code>A[n-1]×A[n-2]×…×A[i+1]</code>乘上<code>B[i]</code>放入<code>B[i]</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">constructArr</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(a.size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,base=<span class="number">1</span>;i&lt;a.size();++i)&#123;</span><br><span class="line">            ans[i]=base;</span><br><span class="line">            base*=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=a.size()<span class="number">-1</span>,base=<span class="number">1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">            ans[i]=ans[i]*base;</span><br><span class="line">            base*=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">数值的整数次方</a></h4><p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/">pow(<em>x</em>, <em>n</em>)</a> ，即计算 x 的 n 次幂函数（即，x^n）。不得使用库函数，同时不需要考虑大数问题。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：x &#x3D; 2.00000, n &#x3D; 10</span><br><span class="line">输出：1024.00000</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：x &#x3D; 2.00000, n &#x3D; -2</span><br><span class="line">输出：0.25000</span><br><span class="line">解释：2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">范围：</span><br><span class="line">	-100.0 &lt; x &lt; 100.0</span><br><span class="line">	-2^31 &lt;&#x3D; n &lt;&#x3D; 2^31-1</span><br><span class="line">	-10^4 &lt;&#x3D; x^n &lt;&#x3D; 10^4</span><br></pre></td></tr></table></figure>
<p>思路：考察快速幂x^n</p>
<p>时间复杂度O(<script type="math/tex">log_2(n)</script>)</p>
<p>空间复杂度O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> tmpn=n;<span class="comment">//由于-2^31取相反数时会超过int范围，先将n存放在long类型</span></span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            x=<span class="number">1</span>/x;</span><br><span class="line">            tmpn=-tmpn;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(tmpn)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmpn&amp;<span class="number">1</span>)</span><br><span class="line">                ans*=x;</span><br><span class="line">            x*=x;</span><br><span class="line">            tmpn&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>递归版</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">recurPow</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//处理负数n</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">1</span>/x;</span><br><span class="line">    <span class="keyword">if</span>(n&amp;<span class="number">1</span>) <span class="keyword">return</span> recurPow(x*x,n&gt;&gt;<span class="number">1</span>)*x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> recurPow(x*x,n&gt;&gt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="剪绳子-II"><a href="#剪绳子-II" class="headerlink" title="剪绳子 II"></a><a href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/">剪绳子 II</a></h4><p>给你一根长度为 <code>n</code> 的绳子，请把绳子剪成整数长度的 <code>m</code> 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 <code>k[0],k[1]...k[m - 1]</code> 。请问 <code>k[0]*k[1]*...*k[m - 1]</code> 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<p>思路：数学求导得到每一段都为3时，相乘是最优解。</p>
<p>分为4种情况</p>
<p>2&lt;=n&lt;=3时返回n-1，因为 m&gt;1</p>
<p>当对3求余得到0直接返回3的段数次方</p>
<p>当对3求余得到1返回3的（段数-1）次方乘以4（最后一段长度为3的段取出来，分成2，2）</p>
<p>当对3求余得到2返回3的段数次方*2</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> modnum=<span class="number">1000000007</span>;</span><br><span class="line">    <span class="comment">//快速幂求base^exp%modnum</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">FastPowAndMod</span><span class="params">(<span class="keyword">long</span> base,<span class="keyword">int</span> <span class="built_in">exp</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">exp</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">exp</span>&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                ans*=base;</span><br><span class="line">                ans%=modnum;</span><br><span class="line">            &#125;</span><br><span class="line">            base*=base;</span><br><span class="line">            base%=modnum;</span><br><span class="line">            <span class="built_in">exp</span>&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">3</span>)<span class="keyword">return</span> n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> segnum=n/<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> remain=n%<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">switch</span>(remain)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:<span class="keyword">return</span> FastPowAndMod(<span class="number">3</span>,segnum);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:<span class="keyword">return</span> FastPowAndMod(<span class="number">3</span>,segnum<span class="number">-1</span>)*<span class="number">4</span>%modnum;</span><br><span class="line">            <span class="keyword">default</span>:<span class="keyword">return</span> FastPowAndMod(<span class="number">3</span>,segnum)*<span class="number">2</span>%modnum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>栈</tag>
        <tag>滑动窗口</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
</search>
