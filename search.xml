<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ExpressionToValue</title>
    <url>/2020/05/17/ExpressionToValue.html</url>
    <content><![CDATA[<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">

<h1 id="表达式求值-wpf"><a href="#表达式求值-wpf" class="headerlink" title="表达式求值  wpf"></a>表达式求值  wpf</h1><p>主要思想：表达式递归切割求值。</p>
<p>主要分成三个类。Expression，item和factor。</p>
<p><img src="https://i.loli.net/2020/05/18/D36Pi85OzXsHYqI.png" alt="1589730555323.png"></p>
<h1 id="Expression（-）"><a href="#Expression（-）" class="headerlink" title="Expression（+/-）"></a>Expression（+/-）</h1><p>由divStringExp类的divexp（）方法分割字符串</p>
<p>将表达式中的加法和减法消除。</p>
<p>先用栈找出最外层的括号：</p>
<p><img src="https://i.loli.net/2020/05/18/9yvzgBIKtb4h1Fr.png" alt="1589730585178.png"></p>
<p>然后往括号两端扩展</p>
<p><img src="https://i.loli.net/2020/05/18/wQOiU6col4kmjx2.png" alt="1589730598531.png"></p>
<p>切割加号得到两个items</p>
<h1 id="Item"><a href="#Item" class="headerlink" title="Item"></a>Item</h1><p>把字符串分成被除数和除数</p>
<p>分两种情况：有括号和无括号</p>
<h2 id="有括号的情况："><a href="#有括号的情况：" class="headerlink" title="有括号的情况："></a>有括号的情况：</h2><p>同样是用栈判断最外层的括号</p>
<p><img src="https://i.loli.net/2020/05/18/r9RHuIQCJpPechX.png" alt="1589730611640.png"></p>
<p>把括号内的乘号和除号省略，分割外面的乘号和除号</p>
<p>并把除数之间和被除数之间相连（或者用两个数组将分子和分母保存起来）</p>
<p><img src="https://i.loli.net/2020/05/18/MzuFHbxXe1aEsKC.png" alt="1589730620914.png"></p>
<h2 id="没括号的情况："><a href="#没括号的情况：" class="headerlink" title="没括号的情况："></a>没括号的情况：</h2><p>遇到除号将后面的除数加到除数字符串   </p>
<h1 id="Factor"><a href="#Factor" class="headerlink" title="Factor"></a>Factor</h1><p>拆开最外层括号外的乘号</p>
<p>剩下的元素分成5种情况</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="一元函数"><a href="#一元函数" class="headerlink" title="一元函数"></a>一元函数</h4><p>递归求括号内的值，再代入函数</p>
<p>例如sin(exp)</p>
<h4 id="多元函数（目前只有log（a-b）函数）"><a href="#多元函数（目前只有log（a-b）函数）" class="headerlink" title="多元函数（目前只有log（a,b）函数）"></a>多元函数（目前只有log（a,b）函数）</h4><p>例如log(a,log(b,c))，将括号内提出来“a,log(b,c)”</p>
<p>将没在括号内的，分割</p>
<p>分成“a“和”log(b,c)”再分别递归求值。</p>
<h3 id="次方"><a href="#次方" class="headerlink" title="次方"></a>次方</h3><p>求最外层括号外的次方</p>
<p>最外层是括号：</p>
<p>拆括号后递归求值</p>
<p><strong>注意：次方内可能也有多个表达式</strong></p>
<p>例如:2^sin(a)</p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>找coefficient类将值返回</p>
<h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><p>用table.Compute（）方法转化</p>
<h1 id="参数（Coefficient）类"><a href="#参数（Coefficient）类" class="headerlink" title="参数（Coefficient）类"></a>参数（Coefficient）类</h1><p>正则表达式找变量并忽略掉所有的函数名，并初始赋值1</p>
<h1 id="tool类"><a href="#tool类" class="headerlink" title="tool类"></a>tool类</h1><p>装有静态的函数名对象，方便外界访问</p>
<h1 id="界面设计"><a href="#界面设计" class="headerlink" title="界面设计"></a>界面设计</h1><p>Stackpanel中嵌套三个Grid布局</p>
<p><img src="https://i.loli.net/2020/05/18/wpmizh45WgBr3GL.png" alt="1589730840570.png"></p>
<h2 id="Grid布局1"><a href="#Grid布局1" class="headerlink" title="Grid布局1"></a>Grid布局1</h2><p>计算结果用label显示</p>
<h2 id="Grid布局2"><a href="#Grid布局2" class="headerlink" title="Grid布局2"></a>Grid布局2</h2><p>四个listbox分别显示变量名，范围，滑块，变量值</p>
<h2 id="Grid布局3"><a href="#Grid布局3" class="headerlink" title="Grid布局3"></a>Grid布局3</h2><p>输入栏和确定按钮</p>
<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h5 id="确定按钮click事件"><a href="#确定按钮click事件" class="headerlink" title="确定按钮click事件"></a>确定按钮click事件</h5><p>初始化动态添加元素到四个listbox</p>
<h5 id="变量范围keydown事件"><a href="#变量范围keydown事件" class="headerlink" title="变量范围keydown事件"></a>变量范围keydown事件</h5><p>判断输入是否是数字</p>
<h5 id="四个listbox滑动条同步事件"><a href="#四个listbox滑动条同步事件" class="headerlink" title="四个listbox滑动条同步事件"></a>四个listbox滑动条同步事件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VisualTreeHelper.GetChild(VisualTreeHelper.GetChild(this.listBox4, 0), 0) as ScrollViewer;&#x2F;&#x2F;找到scrollviewer对象</span><br><span class="line">		sv4.ScrollChanged +&#x3D; newScrollChangedEventHandler(listBox4_ScrollChanged);</span><br><span class="line">&#x2F;&#x2F;添加事件</span><br><span class="line">        private void listBox4_ScrollChanged(object sender, ScrollChangedEventArgs e)</span><br><span class="line">        &#123;</span><br><span class="line">        if (sv4 !&#x3D; null)</span><br><span class="line">        &#123;</span><br><span class="line">            sv3.ScrollToVerticalOffset(sv4.VerticalOffset);</span><br><span class="line">            sv2.ScrollToVerticalOffset(sv4.VerticalOffset);</span><br><span class="line">            sv1.ScrollToVerticalOffset(sv4.VerticalOffset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="双击变量名产生滑块动画事件"><a href="#双击变量名产生滑块动画事件" class="headerlink" title="双击变量名产生滑块动画事件"></a>双击变量名产生滑块动画事件</h5><p>System.Windows.Threading.DispatcherTimer类用于动画制作</p>
<p>该类用Interval方法设置事件的发生间隔</p>
<p>tmr.Interval = TimeSpan.FromSeconds(0.01);</p>
<p>给他的tick事件添加委托threads方法</p>
<p>start方法启用</p>
<p>判断条件满足后停止</p>
<p>end方法终止</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void animation(object sender, RoutedEventArgs e)</span><br><span class="line">        &#123;</span><br><span class="line">            Label label &#x3D; sender as Label;</span><br><span class="line">            int count &#x3D; 0;</span><br><span class="line">            foreach(Label l1 in listBox1.Items)</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">                if (l1 &#x3D;&#x3D; label)</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            ProcessToanimation &#x3D; 0;</span><br><span class="line">            CountToAnimation &#x3D; count;</span><br><span class="line">            System.Windows.Threading.DispatcherTimer tmr &#x3D; new System.Windows.Threading.DispatcherTimer();</span><br><span class="line">            tmr.Interval &#x3D; TimeSpan.FromSeconds(0.01);</span><br><span class="line">            tmr.Tick +&#x3D; new EventHandler(threads);</span><br><span class="line">            tmr.Start();</span><br><span class="line">        &#125;</span><br><span class="line">private void threads(object c,EventArgs e)</span><br><span class="line">    &#123;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            int count &#x3D; CountToAnimation;</span><br><span class="line">            slidersList[count-1].Value &#x3D; ProcessToanimation;</span><br><span class="line">            double td &#x3D; (slidersList[count - 1].Value - 5) * Convert.ToDouble(rangesList[count - 1].Text);</span><br><span class="line">            td &#x3D; td &#x2F; 5;</span><br><span class="line">            valuesList[count - 1].Content &#x3D; td;</span><br><span class="line">            variableCollection.vlist[count - 1].value &#x3D; td;</span><br><span class="line">            exp.setVariables(variableCollection);</span><br><span class="line">            result.Content &#x3D; exp.getValue();</span><br><span class="line">            ProcessToanimation +&#x3D; 0.025;</span><br><span class="line">            if (ProcessToanimation &gt;&#x3D; 10)</span><br><span class="line">            &#123;</span><br><span class="line">                slidersList[count-1].Value &#x3D; 6;</span><br><span class="line">                double ts &#x3D; (slidersList[count - 1].Value - 5) * Convert.ToDouble(rangesList[count - 1].Text)&#x2F;5;</span><br><span class="line">                valuesList[count - 1].Content &#x3D; ts;</span><br><span class="line">                variableCollection.vlist[count - 1].value &#x3D; ts;</span><br><span class="line">                exp.setVariables(variableCollection);</span><br><span class="line">                result.Content &#x3D; exp.getValue();</span><br><span class="line">                (c as System.Windows.Threading.DispatcherTimer).Stop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception e1)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>程序</category>
      </categories>
      <tags>
        <tag>WPF</tag>
        <tag>表达式求值</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ - 1611-day3-F</title>
    <url>/2019/09/01/POJ-1611-day3-F.html</url>
    <content><![CDATA[<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">

<h1 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h1><p><a href="http://poj.org/problem?id=1611" target="_blank" rel="noopener">POJ - 1611</a></p>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>Severe acute respiratory syndrome (SARS), an atypical pneumonia of unknown aetiology, was recognized as a global threat in mid-March 2003. To minimize transmission to others, the best strategy is to separate the suspects from others.<br>In the Not-Spreading-Your-Sickness University (NSYSU), there are many student groups. Students in the same group intercommunicate with each other frequently, and a student may join several groups. To prevent the possible transmissions of SARS, the NSYSU collects the member lists of all student groups, and makes the following rule in their standard operation procedure (SOP).<br>Once a member in a group is a suspect, all members in the group are suspects.<br>However, they find that it is not easy to identify all the suspects when a student is recognized as a suspect. Your job is to write a program which finds all the suspects.</p>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><p>The input file contains several cases. Each test case begins with two integers n and m in a line, where n is the number of students, and m is the number of groups. You may assume that 0 &lt; n &lt;= 30000 and 0 &lt;= m &lt;= 500. Every student is numbered by a unique integer between 0 and n−1, and initially student 0 is recognized as a suspect in all the cases. This line is followed by m member lists of the groups, one line per group. Each line begins with an integer k by itself representing the number of members in the group. Following the number of members, there are k integers representing the students in this group. All the integers in a line are separated by at least one space.<br>A case with n = 0 and m = 0 indicates the end of the input, and need not be processed.</p>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><p>For each case, output the number of suspects in one line.</p>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>input</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">100 4</span><br><span class="line">2 1 2</span><br><span class="line">5 10 13 11 12 14</span><br><span class="line">2 0 1</span><br><span class="line">2 99 2</span><br><span class="line">200 2</span><br><span class="line">1 5</span><br><span class="line">5 1 2 3 4 5</span><br><span class="line">1 0</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure>

<p>output</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>并查集，找与0有关的所有人，用bb数组来存放头目有关的人数，最后找0的头目，就能在数组里找到所有与他有关的人。</p>
<h1 id="AC的代码"><a href="#AC的代码" class="headerlink" title="AC的代码"></a>AC的代码</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> gro,s,aa[<span class="number">30005</span>],bb[<span class="number">30005</span>],cc[<span class="number">30005</span>];    <span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span>                 <span class="comment">//寻找根节点的函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (aa[x] == x)</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		aa[x] = <span class="built_in">find</span>(aa[x]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x1 = <span class="built_in">find</span>(x);</span><br><span class="line">	<span class="keyword">int</span> y1 = <span class="built_in">find</span>(y);</span><br><span class="line">	<span class="keyword">if</span> (x1 != y1)            <span class="comment">//根节点不同连接</span></span><br><span class="line">	&#123;</span><br><span class="line">		aa[x1] = y1;</span><br><span class="line">		bb[y1] = bb[x1] + bb[y1];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s &gt;&gt; gro)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (s == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; <span class="number">30005</span>; r++)</span><br><span class="line">		&#123;</span><br><span class="line">			aa[r] = r;</span><br><span class="line">			bb[r] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> f = <span class="number">0</span>; f &lt; gro; f++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> p;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;p);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> q = <span class="number">0</span>; q &lt; p; q++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;cc[q]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; p - <span class="number">1</span>; x++)</span><br><span class="line">			&#123;</span><br><span class="line">				join(cc[x], cc[x + <span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> k = <span class="built_in">find</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; bb[k] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>Summer Pockets -REFLECTION BLUE- 玩后感</title>
    <url>/2020/08/20/Summer-Pockets-REFLECTION-BLUE-%E7%8E%A9%E5%90%8E%E6%84%9F.html</url>
    <content><![CDATA[<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
![封面图.png](https://i.loli.net/2020/08/20/CRWvjmlENbABp7F.png)

<h5 id="先来说点个人感想"><a href="#先来说点个人感想" class="headerlink" title="先来说点个人感想"></a>先来说点个人感想</h5><p>为什么选择玩这个游戏？</p>
<p>​    近几年的Bangumi高分gal作品，画风不会太老（个人很纠结这点），人设看起来比较舒服，玩了废萌作之后，调节一下口味。也是没玩过长作gal，填补一下感受吧。</p>
<p>​    刚玩这个游戏，我感觉它很强，很无敌。（本人纯gal萌新）为什么这么说（&lt;-废话），点开游戏立刻就开始了，没有需要任何其他多余的操作，这点小细节，就足以看到制作人的诚意，这点我就很喜欢。点开成就直接吓一跳，250个（后来直接放弃了，只完成了45%）。看看攻略，几千字的攻略直接看傻了眼。序章的乒乓球直接打我个措手不及，手残的锅。总之就这样，渐渐地开始了解。。。</p>
<p>​    系统ui来说，除了没有章节回顾，其他都挺好，还可以在右侧快速存档，每推完一个人之后，标题页面就少一个，这点细节不错的。（推完一条线之后，想再看看那个人，发现没了，感觉很伤心，很难受，哈哈哈）</p>
<h5 id="游戏流程"><a href="#游戏流程" class="headerlink" title="游戏流程"></a>游戏流程</h5><h6 id="普通线："><a href="#普通线：" class="headerlink" title="普通线："></a>普通线：</h6><p>这个游戏首先是序章（7月25日-7月28日）（15个选项）-&gt;每天上下午在地图选择一个事件（7月29-8月7日）-&gt;进线</p>
<h6 id="ALKA线和pockets线"><a href="#ALKA线和pockets线" class="headerlink" title="ALKA线和pockets线"></a>ALKA线和pockets线</h6><p>直接通关8线后，从标题页面进入。</p>
<p>这里说一下我推的流程顺序以及推荐流程顺序</p>
<p>我的顺序（纯给自己写的）：羽未-紬-苍-鸥-白-久-美希-识</p>
<p>年少不懂事，不看攻略花心进了羽未线，后面就开始看攻略了。</p>
<p>先了解世界观顺序：苍-白-识这几个都介绍了一些世界观之后可以随意选择。</p>
<h3 id="剧透模式启动-biubiubiu"><a href="#剧透模式启动-biubiubiu" class="headerlink" title="剧透模式启动~biubiubiu"></a>剧透模式启动~biubiubiu</h3><p><img src="https://i.loli.net/2020/08/20/f2Z8yGWTuphE9oM.png" alt="全角色.png"></p>
<h5 id="序章"><a href="#序章" class="headerlink" title="序章"></a>序章</h5><p>男主来到鸟白岛的船上，看到白羽在瞭望蓝天的落队的一对燕子，然后和老婆婆聊了一波自己，搞了四个形容男主现在的选项（不会唱歌的金丝雀，弄坏拳头的拳击手啥的），这个上来就一头雾水，但是这玩意决定了你以后拿什么系列的奇怪成就。而且这玩意会成为中期男主的中二笑柄。这里就不详细展开了。一个个的角色介绍吧。</p>
<p>鹰原 羽依里：游泳受挫逃到岛上的美男子。</p>
<p>鸣濑 白羽：在学校泳池偶遇的超绝内向美少女。</p>
<p>久岛 鸥：来岛上寻找冒险的人，推着行李箱到处跑。</p>
<p>空门 苍：随处乱睡的点心店打工的lsp。</p>
<p>紬 文德斯：在废弃灯塔的寻找自己和要做的事的蠢萌少女。</p>
<p>野村 美希：岛上青年团的持高能水枪维持治安的小女孩。</p>
<p>水织 静久：在海滩上的欧派？</p>
<p>鹰原 羽未：和男主一起来收拾遗物的堂妹。</p>
<p>（神山）识：饿倒在路边吃野草的自称要成为鬼的小女孩。</p>
<p>三谷 良一：到处脱衣的变态裸男。</p>
<p>加纳 天善：沉迷乒乓球的体育白痴。</p>
<p>岬 镜子：温油的爱好收藏的料理白痴阿姨。</p>
<h5 id="各线路"><a href="#各线路" class="headerlink" title="各线路"></a>各线路</h5><p><img src="https://i.loli.net/2020/08/20/UkPH4Gl1sQxN5Ew.png" alt="羽未线.png"></p>
<h6 id="羽未线"><a href="#羽未线" class="headerlink" title="羽未线"></a>羽未线</h6><p>这条线讲了羽未和男主之间生活的小插曲吧，核心是羽未想念父母和男主正视自己。这条线我是最开始就玩了我认为在ALKA线之后游玩会有别一般的感受，可惜这是不可能的。总体上不是一条催泪线，但是也体现了一波亲子教育的哲学。</p>
<p><img src="https://i.loli.net/2020/08/20/BEqpa8i1D27ylnK.png" alt="ADC_8`_R25YEAIHJ_TRR`ST.png"></p>
<h6 id="紬线"><a href="#紬线" class="headerlink" title="紬线"></a>紬线</h6><p>这条线讲了紬的身世，在日常上下了很大的功夫。以紬要回去的问题展开。男主与她和静久不断挣扎，最后开花结果。其实我认为这条线虽然甜，但是并不是做的很好，首先就是静久在这条线的存在价值，我认为是有煞风景的。作为一个女强人，她也没有起到给主意的作用，也不能是她起作用。多了一些女生之间的友谊，我觉得用处不是很大。总体来说，这条线恋爱气氛很浓，但是只是依附在这个世界观的一个小支线，结局也是很虚幻的happy end。</p>
<p><img src="https://i.loli.net/2020/08/20/JcirohVmsepMnNd.png" alt="鸥线.png"></p>
<h6 id="鸥线"><a href="#鸥线" class="headerlink" title="鸥线"></a>鸥线</h6><p>这条线我是比较有惊喜的，首先是开篇找回四把钥匙，打开藏宝图宝箱，准备好野营，兴奋得睡不着，大家齐心协力去寻找海盗船的冒险。这里就很有童年夏日的浪漫。找到船后发现只是普通的帆船，也是很有过山车的感觉。而且确实如其他人所说，我也被蒙骗在男主是冒险团的一员的氛围里，最后解释不是的时候令我大跌眼镜。这个结局我是看不懂的，鸥最后给男主印有万国印章的情信，说明鸥还是在带领着各个胡子猫团来到了这里，男主是要去见她的留下的幻影？还是暗喻了鸥已经醒来？</p>
<h6 id="苍线"><a href="#苍线" class="headerlink" title="苍线"></a>苍线</h6><p><img src="https://i.loli.net/2020/08/20/H2jwg56ZrqUpAxz.png" alt="苍线.png"></p>
<p>这条线很多人都说是工具线，确实这条线交代了很多的世界观设定，但是也展现了苍的人物魅力，前面到处睡觉的伏笔也得以回收。苍在寻找七影碟的过程中也展现了担当，没有像共通线一样单纯是个lsp。单纯的性格虽然没有什么代入感，但是很有亲切感。虽然白给了男主，男主也最后展现了他的行动力，找回她的蝴蝶。整条线感觉很完满。</p>
<h6 id="白线"><a href="#白线" class="headerlink" title="白线"></a>白线</h6><p><img src="/2020/08/20/E:%5Chexo%5Csource_posts%5CSummer-Pockets-REFLECTION-BLUE-%E7%8E%A9%E5%90%8E%E6%84%9F%5C%E7%99%BD%E7%BA%BF.png" alt="白线"></p>
<p>这条线感觉大多都是日常，为了切合最后的两线做的铺垫。羽白这种高冷女神确实给人一种难以接近的感觉。话说她也应该是公认最漂亮的女生吧（引战），其他线都是男主夸，这个还有侧面烘托。她的cg也是非常的好看。这条线解释了为什么她要离大家这么远，男主把她从预知的危机中拯救出来，说她的预知是为了避免危机的发生，虽说有点牵强，但是也是可以接受，也算是一种救赎吧。最后青涩的恋爱告白很甜。作为一条铺垫线的话是相当可以的了。</p>
<h6 id="美希线"><a href="#美希线" class="headerlink" title="美希线"></a>美希线</h6><p><img src="https://i.loli.net/2020/08/20/9PKnzUt5wvSkV4x.png" alt="美希线.png"></p>
<p>我认为观感最差的线，也应该是做得最不用心的线了吧，cg数量是最少的，衣服也就加多了一件很土的黄色家居装。优点嘛，更体现了岛民的善良，把她抚养到了这么大，解释了为什么她这么尽心尽力的为岛民服务。剧情梳理起来，感觉就比较矫情。明明都有这么多美好，却困在双亲丢弃的牢笼里不愿出来，解决问题和爱上男主的转折太快了，几乎都是同时解决。最后在空中时停说了一大堆话，我觉得很尬，但是cg却是最好看的几张&lt;(￣-￣！)&gt;。可能也是有点男人婆的感觉，导致好感不怎么高，不过是辛苦裸男了，提供了不少笑点。 </p>
<h6 id="静久线"><a href="#静久线" class="headerlink" title="静久线"></a>静久线</h6><p><img src="https://i.loli.net/2020/08/20/5Fendy9pNMT3gHh.png" alt="静久线.png"></p>
<p>这条线里紬放弃了灯塔来海之家搞百合，虽然还是那句话不怎么需要紬来推动剧情，但是最后的静久和紬的告别确实是比较感人，声优十分地卖力，在这条线男女主都解决了自己的心理问题，这样看倒是觉得男主和静久都很优秀啊，都有自己特长之处，重新在这个夏天找回真正的自己剧情看起来也比较浪漫，最后的分别（分手）也是气氛渲染得很好。整体感情过渡还算自然。虽然静久妈妈只对自己女儿发大火确实有点扯。</p>
<h6 id="识线"><a href="#识线" class="headerlink" title="识线"></a>识线</h6><p><img src="https://i.loli.net/2020/08/20/AjskMIzby68Oae1.png" alt="识线.png"></p>
<p>这个我也比较意外的线，思路比较创新，虽然把所有人赶到上山避难的方法是化身恶鬼海盗确实是比较蠢，前期白开水，中期往鬼的方向前行，最后回到过去救下了这个岛。结局也是十分悲壮，不过男主居然能回到过去，并把识救了上来，而且识还可以说话。这种情况下还把识写死。我觉得有点强行了。最后也没有写神山一族的留存，和识的转生啥的。总之还是搞了个be。但是气氛渲染得很好，最后的捉迷藏离别很能体现。但是14岁女孩肩负这重任着实离谱。</p>
<h6 id="ALKA线"><a href="#ALKA线" class="headerlink" title="ALKA线"></a>ALKA线</h6><p><img src="https://i.loli.net/2020/08/20/25rdQGFtYWiClV6.png" alt="三人照.png"></p>
<p>这个无疑是写得最好的一线了，点开一看是羽未线，我惊呆了。前期羽未突然变幼，我相当迷惑，但是在蝴蝶的画本出来后我就明白了事情的不对劲。这个轮回的故事，说惊艳也说不上，算是比较老套了，但是日常写父母和孩子的快乐时光确实是令人感到幸福，幸福中也埋藏这预知天气这条线的危机。很能抓住玩家的心情。最后慢慢忘却了羽未，感觉心情确实是闷闷的，最后绝望的无限轮回。更添一笔。</p>
<h6 id="Pocket线"><a href="#Pocket线" class="headerlink" title="Pocket线"></a>Pocket线</h6><p><img src="https://i.loli.net/2020/08/20/pHZIjhN4RrBqWnz.png" alt="消失之际.png"></p>
<p>这条线明显用来救局的，我玩的时候没注意影法师什么的，还以为这是男主转成七海拯救白羽，但是男主并没有这个能力，羽未也是的强，最后让白羽放弃自己的能力往前走，消除了拥有羽未的未来，母女抱在一起痛哭，场面也是很唯美凄凉。从根本上拯救了鸣濑一族，虽然没有男主的登场（去收拾仓库吧你），但是最后合家团圆令人感慨万千。（这么懂事的女儿那里领？？？？）</p>
<h6 id="乒乓球线"><a href="#乒乓球线" class="headerlink" title="乒乓球线"></a>乒乓球线</h6><p>好家伙，打得我热血沸腾，不到残血不会玩，每一局都是要残血反杀，没到残血就刮痧。离谱，打了一个半小时终于通关了，为了这个还把窗口都缩小了，方便打。打的时候台词也是热血得很。（天善，天善，天善！！。 takahala haili！！！）</p>
<h6 id="宝可梦"><a href="#宝可梦" class="headerlink" title="宝可梦"></a>宝可梦</h6><p>非洲人不玩的，别搞我。</p>
<h4 id="整点碎碎念总结"><a href="#整点碎碎念总结" class="headerlink" title="整点碎碎念总结"></a>整点碎碎念总结</h4><p>​    嘛，男主也是特别的牛，进那个线都有着极大的作用，虽然有点杠，但是还是想说，没了男主，这个岛恐怕人都没得了。</p>
<p>​    summer pockets嘛夏日的口袋，特别适合夏天玩。口袋里收藏不少好玩的故事，我也想在这个暑假体验一波夏日风情。那就玩呗。有人说，玩gal就是浪费时间，但是玩其他游戏就不浪费了？刷首页视频就不浪费了？在哪里能学到多少东西呢，娱乐嘛，能收获到自己想要的欢乐就很不错了，不需要强行搞什么性价比的。总之这个游戏也算是我暑假的一段小插曲吧。</p>
]]></content>
  </entry>
  <entry>
    <title>TSPppt</title>
    <url>/2019/09/23/TSPppt.html</url>
    <content><![CDATA[<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">

<h1 id="TSP的几个算法"><a href="#TSP的几个算法" class="headerlink" title="TSP的几个算法"></a>TSP的几个算法</h1><p>这是一个自己做的ppt的记录。</p>
<h2 id="TSP实例"><a href="#TSP实例" class="headerlink" title="TSP实例"></a>TSP实例</h2><p>有一位商人，他想访问德国的某些城市，要求：</p>
<ol>
<li>所走路程最短；</li>
<li>每个城市只能访问一次；</li>
<li>从某城市出发，最后回到该城市。</li>
</ol>
<p><img src="https://i.loli.net/2019/09/23/ivBU6RxodJYnZKr.png" alt="1568996702133 - 副本.png"></p>
<p>让我们看一下为什么要学这个问题，主要来看一下tsp到底有什么用。</p>
<p><img src="https://i.loli.net/2019/09/23/ouY7XfMKmTSia8p.png" alt="1568997255774 - 副本.png"></p>
<p>看完了应用，我们来看一下怎么去解决这个问题吧</p>
<p>首先先任意选一个点作为起点，然后开始连接就可以看到有n！种情况</p>
<p><img src="https://i.loli.net/2019/09/23/iCTeADruUnYm9Ia.png" alt="1569036262994 - 副本.png"></p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>我们尝试优化一下，目前最好的优化是通过动态规划去解决，复杂度为o（2^n*n^2）</p>
<p>首先得懂得为什么可以使用动态规划，<strong>动态规划就是在求解一个复杂问题时，将其分解为若干个简单问题。通过求解简单问题的最优解，来找到目标问题的最优解。</strong></p>
<p><strong>使用动态规划，需要问题本身有最优子结构</strong>，我们需要找到要解决的问题的子问题。</p>
<p>现在找一下tsp的最优子结构</p>
<p><img src="https://i.loli.net/2019/09/23/WFVGmarTHC384hi.png" alt="1569036739438 - 副本.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">从0出发，经过[1,2,3]这几个城市，然后回到0，使得花费最少。要实现这个要求，需要从下面三个实现方案中选择花费最少的方案。</span><br></pre></td></tr></table></figure>

<p>　　　　1、 从0出发，到1，然后再从1出发，经过[2,3]这几个城市，然后回到0，使得花费最少。</p>
<p>　　　　2、 从0出发，到2，然后再从2出发，经过[1,3]这几个城市，然后回到0，使得花费最少。</p>
<p>　　　　3、 从0出发，到3，然后再从3出发，经过[1,2]这几个城市，然后回到0，使得花费最少。<br>  可以发现，三个小的解决方案的最优解，构成了大的解决方案，所以这个问题具有最优子结构，可以用动态规划来实现。</p>
<p><img src="https://i.loli.net/2019/09/23/qcUid3omRzaVG59.png" alt="1569036847226.png"></p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>这个算法由于空间复杂度有o(n*2^n)，所以做一般的算法题要用到状态压缩，用0代表没有到达该城市，1代表去过该城市。例如：11011代表1-5个城市只有第三个城市没去过。上述的S集合就是通过状压保存。</p>
<p><img src="https://i.loli.net/2019/09/23/vxHhVn84XWAS1Pp.png" alt="1569036878291.png"></p>
<p>说了这么多，看一下怎么解决，主要分为4个步骤。</p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>（1）选择G的任意一个顶点r作为根节点(出发/结束点)</p>
<p>（2）用Prim算法找出G的一棵以r为根的最小生成树T</p>
<p>（3）前序遍历访问树T，得到遍历顺序组成的顶点表L</p>
<p>（4）将r加到顶点表L的末尾，按L中顶点的次序组成哈密顿回路H</p>
<p>简单的解释一下其中的名词，有需要自己了解</p>
<h4 id="prim算法"><a href="#prim算法" class="headerlink" title="prim算法"></a>prim算法</h4><p>Prim算法如何进行计算？<br>①选定一个起点做为一个集合 a ，剩下的点为另一个集合 b</p>
<p>②将横跨两个集合且权重在其中最小的边加入最小生成树</p>
<p>③将刚刚加入最小生成树的边中不在集合 a 中的点加入集合 a，直到所有的点加入集合 a</p>
<h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><p>首先访问根节点，然后遍历左子树，最后遍历右子树。</p>
<p><img src="https://i.loli.net/2019/09/23/qZefMb7NgIaR1AY.gif" alt="GIF.gif"></p>
<h2 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法"></a>遗传算法</h2><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>遗传算法（Genetic Algorithm, GA）是模拟达尔文生物进化论的自然选择和遗传学机理的生物进化过程的计算模型，是一种通过模拟自然进化过程搜索最优解的方法。</p>
<h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h4><p><img src="https://i.loli.net/2019/09/23/H8VtSwGa3Ax42TJ.png" alt="1569037387267.png"></p>
<p>这里补充一下细节：</p>
<ol>
<li>交叉操作：随机挑取在染色体（路径）上的一个序号（2-n-1）交换两条染色体序号后面的（基因），这里需要进行基因冲突处理，即交换后要检查是否交换过来了已有的基因，如果是则和另一条的重复基因交换。</li>
<li>变异操作，对一条基因选出i，j（0&lt;i&lt;j&lt;=n）将其中的基因交换。</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>TSP</tag>
        <tag>遗传算法</tag>
        <tag>动态规划</tag>
        <tag>Prim</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/08/30/hello-world.html</url>
    <content><![CDATA[<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">

<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment<img src="/2019/08/30/QQ%E6%88%AA%E5%9B%BE20190815084633.png" alt="QQ截图20190815084633"></a></p>
]]></content>
  </entry>
  <entry>
    <title>天国旅立</title>
    <url>/2019/09/09/%E5%A4%A9%E5%9B%BD%E6%97%85%E7%AB%8B.html</url>
    <content><![CDATA[<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">

<p><img src="https://i.loli.net/2019/09/09/IcUw5WsjhbGYmlT.png" alt="Saved_Memory2.png"></p>
<p><img src="https://i.loli.net/2019/09/09/XDAKdzLsoYnP3HF.png" alt="Saved_Memory8.png"><br><img src="https://i.loli.net/2019/09/09/KtRvuZnfELqWC9k.png" alt="Saved_Memory9.png"><br><img src="https://i.loli.net/2019/09/09/QCnb92H8UfmLEkO.png" alt="Saved_Memory10.png"><br><img src="https://i.loli.net/2019/09/09/WYmx4RS1ebr6DIF.png" alt="Saved_Memory3.png"><br><img src="https://i.loli.net/2019/09/09/BV2Fr1oiyPvDxqd.png" alt="Saved_Memory4.png"><br><img src="https://i.loli.net/2019/09/09/ihdkgzsEnYFUTN7.png" alt="Saved_Memory6.png"><br><img src="https://i.loli.net/2019/09/09/YJrthXoDLxFyTGq.png" alt="Saved_Memory1.png"><br><img src="https://i.loli.net/2019/09/09/PlLtiIhN3yRA4ns.png" alt="Saved_Memory5.png"><br><img src="https://i.loli.net/2019/09/09/nz9eSMLa5yUxvfK.png" alt="Saved_Memory7.png"><br><img src="https://i.loli.net/2019/09/09/xagRIqXjJKv2ny7.png" alt="Saved_Memory11.png"><br><img src="https://i.loli.net/2019/09/09/tT4IaXVMRHxGJsS.png" alt="Saved_Memory14.png"><br><img src="https://i.loli.net/2019/09/09/pDMBcbTXQK1Asg5.png" alt="Saved_Memory12.png"><br><img src="https://i.loli.net/2019/09/09/b3wZcoDHPxG21dm.png" alt="Saved_Memory13.png"><br><img src="https://p.pstatp.com/origin/fe8f000115e907fd41cd" alt="Saved_Memory15.png"></p>
]]></content>
      <tags>
        <tag>Gallery</tag>
      </tags>
  </entry>
  <entry>
    <title>test_pic</title>
    <url>/2019/09/01/test-pic.html</url>
    <content><![CDATA[<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">

<p>微博的图床：<a href="https://pic.lizenghai.com/#" target="_blank" rel="noopener">https://pic.lizenghai.com/#</a><br>每日最多上传100张。还可能会失败？<br><img src="http://wx3.sinaimg.cn/large/9cd3e769gy1g6kg8jv0uwj20gi0jyh1c.jpg" alt="aaa"></p>
<p>github图：<br>可能dns污染上不去。<br><img src="/2019/09/01/test-pic%5Caaa.jpg" alt="testgithub图"></p>
<p>sm.ms图床：官网地址：<a href="https://sm.ms" target="_blank" rel="noopener">https://sm.ms</a><br>特点：永久存储免注册，图片链接支持https，可以删除上传的图片，提供多种图片链接格式<br>图片上传限制：每个图片最大5M，每次最多上传10张<br><img src="https://i.loli.net/2019/09/01/himBgnrRaPVld1T.png" alt="20190815084633.png"></p>
<p>聚合图床：官网地址： <a href="https://www.superbed.cn/" target="_blank" rel="noopener">https://www.superbed.cn/</a><br>特点：将图片分发到多处备份，借助其本身的CDN加速功能，节省服务器流量，不用担心图片被删除。<br><img src="https://ae01.alicdn.com/kf/H95cba61bf4a14818b70ccb89894b900ci.png" alt="aaa"></p>
]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构题目</title>
    <url>/2020/06/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E7%9B%AE.html</url>
    <content><![CDATA[<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
# [面试题59 - I. 滑动窗口的最大值](https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/)（LeetCode）（单调队列）

<p>给定一个数组 <code>nums</code> 和滑动窗口的大小 <code>k</code>，请找出所有滑动窗口里的最大值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [1,3,-1,-3,5,3,6,7], 和 k &#x3D; 3</span><br><span class="line">输出: [3,3,5,5,6,7] </span><br><span class="line">在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; r;</span><br><span class="line">        <span class="keyword">if</span>(!nums.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">max</span>=nums[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> maxindex=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+k&lt;=nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(maxindex==i<span class="number">-1</span>||i==<span class="number">0</span>)&#123;	<span class="comment">//第一个窗口或者是前一个窗口最大值已不在当前窗口</span></span><br><span class="line">                    <span class="built_in">max</span>=nums[i];</span><br><span class="line">                    maxindex=i;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k;j++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(<span class="built_in">max</span>&lt;nums[i+j])&#123;</span><br><span class="line">                            <span class="built_in">max</span>=nums[i+j];</span><br><span class="line">                            maxindex=i+j;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;						<span class="comment">//前一个窗口最大值还在当前窗口</span></span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">max</span>&lt;nums[i+k<span class="number">-1</span>])&#123;</span><br><span class="line">                        <span class="built_in">max</span>=nums[i+k<span class="number">-1</span>];</span><br><span class="line">                        maxindex=i+k<span class="number">-1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                r.push_back(<span class="built_in">max</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>思路：滑动窗口就是在前面加一个元素，后面减去一个元素，这里考虑了减去的元素是不是等于最大的元素，如果是，就找当前的窗口的最大元素，不是的话，说明前一窗口的最大元素仍在窗口，就将前一个窗口最大元素跟新加的元素比较，以确定当前窗口最大元素。</p>
<p>执行用时 :28 ms, 在所有 C++ 提交中击败了89.08%的用户</p>
<p>内存消耗 :15.7 MB, 在所有 C++ 提交中击败了100.00%的用户</p>
<p>缺点：在最大值在现有窗口被去除后找最大值的时间复杂度为O(k）</p>
<p>改进版本</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">       <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; deq;</span><br><span class="line">       <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">           <span class="keyword">while</span>(!deq.empty() &amp;&amp; nums[i] &gt; nums[deq.back()])&#123;</span><br><span class="line">               deq.pop_back();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (!deq.empty() &amp;&amp; deq.front() &lt; i - k + <span class="number">1</span>) deq.pop_front();</span><br><span class="line">           deq.push_back(i);</span><br><span class="line">           <span class="keyword">if</span> (i &gt;= k <span class="number">-1</span>) ans.push_back(nums[deq.front()]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br></pre></td></tr></table></figure>

<p>思路：维护一个单调队列，满足头为最大值，队列里的元素都为窗口元素。每次移动，检查添加元素是否大于尾元素，大于则去除，直到队列里只有比添加元素大的元素。之后检查头元素是不是不在当前窗口，不在则去除。最后头元素就是当前窗口最大的元素。</p>
<p>在窗口数大的时候优化明显,总体的时间复杂度是O(n)。</p>
<p>执行用时 :36 ms, 在所有 C++ 提交中击败了80.64%的用户</p>
<p>内存消耗 :16.3 MB, 在所有 C++ 提交中击败了100.00%的用户</p>
]]></content>
      <tags>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络运输层笔记</title>
    <url>/2020/06/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82%E7%AC%94%E8%AE%B0.html</url>
    <content><![CDATA[<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">

<p>`<strong>运输层</strong></p>
<p> <img src="https://i.loli.net/2020/06/11/8uy5a2vfp1lMSNx.png" alt="运输层.png"></p>
<h1 id="运输层协议概述"><a href="#运输层协议概述" class="headerlink" title="运输层协议概述"></a>运输层协议概述</h1><h2 id="进程之间端到端的逻辑通信"><a href="#进程之间端到端的逻辑通信" class="headerlink" title="进程之间端到端的逻辑通信"></a>进程之间端到端的逻辑通信</h2><h3 id="复用"><a href="#复用" class="headerlink" title="复用"></a>复用</h3><p>·        发送方不同的应用进程都可以使用同一个运输层协议传送数据</p>
<h3 id="分用"><a href="#分用" class="headerlink" title="分用"></a>分用</h3><p>·        是指接收方的运输层在剥去报文的首部后能够把这些数据正确交付目的应用进程。</p>
<h2 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h2><h2 id="运输层的端口"><a href="#运输层的端口" class="headerlink" title="运输层的端口"></a>运输层的端口</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>·        软件端口</p>
<p>·        16位65535</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>·        服务端端口</p>
<p>•      熟知端口号（0-1023）</p>
<p>•      登记端口号（1024-49151）</p>
<p>·        客户端端口（短暂端口号）（49152-65535）</p>
<h1 id="UDP-User-Datagram-Protocol）用户数据报协议"><a href="#UDP-User-Datagram-Protocol）用户数据报协议" class="headerlink" title="UDP(User Datagram Protocol）用户数据报协议"></a>UDP(User Datagram Protocol）用户数据报协议</h1><h2 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h2><p>不需要先建立连接（不可靠）</p>
<p>相比ip数据报增加的功能</p>
<p>·        复用和分用</p>
<p>·        差错检测</p>
<p>面向报文（直接使用应用层报文）</p>
<p>没有拥塞控制（用于多媒体通信）</p>
<p>n对n通信（n=1或多）</p>
<p>首部（8字节）开销小</p>
<p>不用套接字</p>
<h2 id="首部"><a href="#首部" class="headerlink" title="首部"></a>首部</h2><p>源端口2位</p>
<p>目的端口2位</p>
<p>长度2位</p>
<p>校验和2位</p>
<p>·        首部和数据部分一起校验</p>
<p>伪首部12位</p>
<p>·        计算校验和</p>
<p>·        不传输</p>
<h1 id="TCP（Transmission-Control-Protocol）-传输控制协议"><a href="#TCP（Transmission-Control-Protocol）-传输控制协议" class="headerlink" title="TCP（Transmission Control Protocol） 传输控制协议"></a>TCP（Transmission Control Protocol） 传输控制协议</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>提供面向连接的服务（不多播或广播）</p>
<p>·        只能点对点</p>
<p>可靠交付的服务</p>
<p>全双工通信</p>
<p>面向字节流</p>
<p>·        随时截断发送给上层</p>
<p>•      根据拥塞情况和窗口值决定发送大小</p>
<h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><h3 id="连接的端点：套接字socket"><a href="#连接的端点：套接字socket" class="headerlink" title="连接的端点：套接字socket"></a>连接的端点：套接字socket</h3><p>·        TCP 连接 ：：= {socket1, socket2} = {(IP1: port1), (IP2: port2)}</p>
<h2 id="可靠传输的工作原理（使用协议降低出错）"><a href="#可靠传输的工作原理（使用协议降低出错）" class="headerlink" title="可靠传输的工作原理（使用协议降低出错）"></a>可靠传输的工作原理（使用协议降低出错）</h2><h3 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h3><p>·        每发送完一个分组就停止发送， 等待对方的确认。 在收到确认后再发送下一个分组。</p>
<p>·        情况</p>
<p>•      </p>
<p><img src="https://i.loli.net/2020/06/11/gGUXlkcuzNnqeAm.png" alt="clip_image002.png"></p>
<p>•      </p>
<p><img src="https://i.loli.net/2020/06/11/dZvIzsNBw2q8liR.png" alt="clip_image004.png"></p>
<p>•      A只要超过了一段时间（超时计时器）仍然没有收到确认， 就认为刚才发送的分组丢失了，因而重传前面发送过的分组 。 这就叫做超时重传。</p>
<p>•      注意事项</p>
<p>•      发送方暂存已发送分组</p>
<p>•      分组标号</p>
<p>•      设计重传时间长于往返时间</p>
<p>•      确认丢失和确认迟到</p>
<p>•      重复的确认收下就丢弃</p>
<p>•      重复的分组收到后丢弃，然后发送确认</p>
<p>·        信道利用率</p>
<p>•      </p>
<p><img src="https://i.loli.net/2020/06/11/mPD2n7856eWlc4O.png" alt="clip_image006.png"></p>
<p>•      </p>
<p><img src="https://i.loli.net/2020/06/11/gbGycatLwp6K4ov.png" alt="clip_image008.png"></p>
<h3 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h3><p>·         </p>
<p><img src="https://i.loli.net/2020/06/11/EV6JAHmnpouwtIv.png" alt="clip_image010.png"></p>
<p>•      累积确认</p>
<p>•      接收方不必对收到的分组逐个发送确认， 而是在收到几个分组后， 对按序到达的最后一个分组发送确认</p>
<p>•      缺点</p>
<p>•      不能向发送方反映出接收方已经正确收到的所有分组的信息。</p>
<p>•      go-back-N</p>
<p>•      优点</p>
<p>•      容易实现， 即使确认丢失也不必重传。</p>
<h2 id="TCP报文段的首部格式"><a href="#TCP报文段的首部格式" class="headerlink" title="TCP报文段的首部格式"></a>TCP报文段的首部格式</h2><h3 id="报文段"><a href="#报文段" class="headerlink" title="报文段"></a>报文段</h3><p>·        TCP报文段首部的前20个字节是固定的（图5-14), 后面有4n字节是根据需要而增加<br> 的选项(n是整数）。 因此TCP首部的最小长度是20字节。</p>
<p>·         </p>
<p><img src="https://i.loli.net/2020/06/11/pVDPEubF5m1RL7Y.png" alt="clip_image012.png"></p>
<p>•      源端口和目的端口 各占 2 个字节，</p>
<p>•      序号 占 4 字节。</p>
<p>•      确认号 占 4 字节=序号+长度+1</p>
<p>•      希望下一个发送分组的序号</p>
<p>•      数据偏移 占 4 位（0-15）可加长到60字节</p>
<p>•      首部长度</p>
<p>•      保留 占 6 位， 保留为今后使用， 但目前应置0。</p>
<p>•      紧急 URG</p>
<p>•      当 URG 置 l 时， 发送应用进程就告诉发送方的 TCP 有紧急数据要传送。 千是发送方TCP 就把紧急数据插入到本报文段数据的最前面， 而在紧急数据后面的数据仍是普通数据。 这时要与首部中紧急指针(Urgent Pointer)字段配合使用。</p>
<p>•      确认 ACK (ACKnowledgment) 仅当 ACK= 1 确认号字段才有效。 当 ACK=0时， 确认号无效。</p>
<p>•      推送PSH (PuSH)</p>
<p>•      不等缓存满直接向上交付</p>
<p>•      复位RST ( ReSeT)</p>
<p>•      当RST= 1时， 表明 TCP连接中出现严重差错（如由于主机崩溃或其他原因）， 必须释放连接， 然后再重新建立运输连接。RST置l还用拒绝一个非法的报文段或拒绝打开一个连接。RST 也可称为重建位或重置位 。</p>
<p>•      同步SYN</p>
<p>•      同步SYN ( SYNchron ization) 在连接建立时用来同步序号。 当SYN = 1 而 ACK= 0 时， 表明这是一个连接请求报文段。 对方若同意建立连接， 则应在响应的报文段中使SYN= 1 和ACK= 1。 </p>
<p>•      终止FIN</p>
<p>•      终止连接</p>
<p>•      窗口 占2字节</p>
<p>•      窗口字段明确指出了现在允许对方发送的数据量</p>
<p>•      检验和</p>
<p>•      跟udp的伪首部一样</p>
<p>•      伪首部第4 个字段中的 17 改为6<br> (TCP 的协议号是 6),</p>
<p>•      紧急指针 占2字节</p>
<p>•      紧急指针仅在URG= 1时才有意义， 它指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据）。无视窗口</p>
<p>•      选项 最长40字节</p>
<p>•      TCP 最初只规定了一种选项， 即最大报文段长度MSS (Maximum Segment Size)</p>
<p>•      窗口扩大选项 3字节 （16+s）偏移量</p>
<p>•      时间戳选项 10字节</p>
<p>•      计算往返时间RTT</p>
<p>•      防止序号绕回(处理序号超过2^32的情况)</p>
<p>•      选择确认选项</p>
<p>•      待续</p>
<h2 id="TCP-可靠传输的实现"><a href="#TCP-可靠传输的实现" class="headerlink" title="TCP 可靠传输的实现"></a>TCP 可靠传输的实现</h2><h3 id="以字节为单位的滑动窗口"><a href="#以字节为单位的滑动窗口" class="headerlink" title="以字节为单位的滑动窗口"></a>以字节为单位的滑动窗口</h3><p>·        根据窗口值构造发送窗口</p>
<p>•      </p>
<p><img src="https://i.loli.net/2020/06/11/jVUJ6yrOawzovEm.png" alt="clip_image014.png"></p>
<p>•      P3 -P1 =A 的发送窗口<br> P2 -P1 =已发送但尚未收到确认的字节数<br> P3 -P2 =允许发送但当前尚未发送的字节数（又称为可用窗口或有效窗口）</p>
<p>•      时延影响，发送窗口一般小于窗口值</p>
<p>•      对于不按序到达的数据应如何处理， TCP 标准并无明确规定，若丢弃，增加网络负担</p>
<p>•      第三， TCP 要求接收方必须有累积确认的功能， 这样可以减小传输开销，可以将要发送的数据合并确认信息，但不应推迟太久</p>
<h3 id="超时重传时间的选择"><a href="#超时重传时间的选择" class="headerlink" title="超时重传时间的选择"></a>超时重传时间的选择</h3><p>·        自适应算法</p>
<p>•      TCP保留了RTT的一 个加权平均往返<br> 时间RTTs( 这又称为平滑的往返时间，</p>
<p>•      新的RTTs = (1 -a) x (旧的RTTs) + a x ( 新的RTT样本）0&lt;=a&lt; 1</p>
<p>•      报文段的往返时间RTT</p>
<p>•      超时重传时间RTO</p>
<p>•      RTO = RTTs + 4 x RTTD</p>
<p>•      RTTD 是RTT 的偏差的加权平均值</p>
<p>•      新的RTTD = (1 - β) x (旧的RTTo)+βx|RTTs-新的RTT样本|<br> 这里β是个小于 1 的系数， 它的推荐值是1/4</p>
<p>•      往返时间的测量</p>
<p>•      Kam算法</p>
<p>•      在计算加权平均 RTTS时， 只要报文段重传了，就不采用其往返时间样本。 这样得出的加权平均RTTS和RTO就较准确。</p>
<p>•      修正</p>
<p>•      文段每重传一次， 就把超时重传时间RTO增大一些。 典型的做法是取新的重传时间为旧的重传时间的 2 倍。 当不再发生报文段的重传时，才计算超时重传时间。</p>
<h3 id="选择确认SACK"><a href="#选择确认SACK" class="headerlink" title="选择确认SACK"></a>选择确认SACK</h3><p>·        解决接收到的字节流序号不连续的问题</p>
<p>·         如果要使用选择确认 SACK, 那么在建立 TCP 连接时， 就要在 TCP 首部的选项中加上“ 允许 SACK” 的选项</p>
<p>·         由千首部选项的长度最多只有 40 字节， 而指明一个边界就要用掉4字节（因为序号有 32 位， 需要使用4个字节表示）， 因此在选项中最多只能指明 4 个字节块的边界信息。 这是因为 4 个字节块共有 8 个边界， 因而需要用 32 个字节来描述。 另外还需要两个字节。一个字节用来指明是 SACK 选项， 另一个字节是指明这个选项要占用多少字节。 如果要报告五个字节块的边界信息</p>
<p>·        4个边界，两个块 用了4*4字节+2字节（sack+sack长度）</p>
<h2 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h2><p> 发送方的发送速率不要太快，要让接收方来得及接收。</p>
<h3 id="利用滑动窗口实现流量控制"><a href="#利用滑动窗口实现流量控制" class="headerlink" title="利用滑动窗口实现流量控制"></a>利用滑动窗口实现流量控制</h3><p>·        通过控制窗口值控制速率</p>
<p>·        发送方的发送窗口不能超过接收方给出的接收窗口的数值。 请注意， TCP 的窗口单位是字节， 不是报文段。</p>
<p>·        为了防止0窗口后的新窗口丢失</p>
<p>•      发送方 持续计时器</p>
<p>•      发送一个零窗口探测报文段</p>
<p>•      若为窗口仍为0</p>
<p>•      持续探测</p>
<p>•      若为窗口不为0</p>
<p>•      继续传输</p>
<h3 id="TCP-的传输效率"><a href="#TCP-的传输效率" class="headerlink" title="TCP 的传输效率"></a>TCP 的传输效率</h3><p>·        发送时机机制</p>
<p>•      第一种机制是TCP维持一个变量， 它等于最大报文段长度MSS。 只要缓存中存放的数据达到MSS 字节时， 就组装成一个TCP 报文段发送出去。 </p>
<p>•      第二种机制是由发送方的应用进程指明要求发送报文段，即TCP支持的推送(push)操作。 </p>
<p>•       第三种机制是发送方的一个计时器期限到了， 这时就把当前已有的缓存数据装入报文段（但长度不能超过MSS) 发送出去。</p>
<p>·        Nagle 算法</p>
<p>•      若发送应用进程把要发送的数据逐个字节地送到 TCP 的发送缓存， 则发送方就把第一个数据字节先发送出去， 把后面到达的数据字节都缓存起来。 当发送方收到对第一个数据字符的确认后， 再把发送缓存中的所有数据组装成一个报文段发送出去， 同时继续对随后到达的数据进行缓存。 只有在收到对前一个报文段的确认后才继续发送下一个报文段</p>
<p>•      规定： 当到达的数据已达到发送窗口大小的一半或已达到报文段的最大长度时， 就立即发送一个报文段。 这样做， 就可以有效地提高网络的吞吐量。</p>
<p>·        糊涂窗口综合征</p>
<p>•      现象</p>
<p>•      TCP 接收方的缓存已满， 而交互式的应用进程一次只从接收缓存中读取1个字节（这样就使接收缓存空间仅腾出1个字节）， 然后向发送方发送确认，把窗口设置为1个字节（但发送的数据报是40字节长）。 接着， 发送方又发来l个字节的数<br> 据（请注意， 发送方发送的IP数据报是41字节长）。 接收方发回确认， 仍然将窗口设置为<br> l 个字节。 这样进行下去， 使网络的效率很低。</p>
<p>•      解决</p>
<p>•      接收方等待一段时间， 使得或者接收缓存已有足够空间容纳一个最长的报文段， 或者等到接收缓存已有一半空闲的空间。 只要出现这两种情况之一， 接收方就发出确认报文， 并向发送方通知当前的窗口大小。 此外， 发送方也不要发送太小的报文段而是把数据积累成足够大的报文段， 或达到接收方缓存的空间的一半大小。</p>
<h2 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h2><h3 id="拥塞控制的一般原理"><a href="#拥塞控制的一般原理" class="headerlink" title="拥塞控制的一般原理"></a>拥塞控制的一般原理</h3><p>·        拥塞</p>
<p>•      定义</p>
<p>•      在某段时间， 若对网络中某一资源的需求超过了该资源所能提供的可用部分， 网络的性能<br> 就要变坏。 这种情况就叫做拥塞(congestion)。</p>
<p>•      任意增加一些资源不但不能解决拥塞问题， 而且还可能使网络的性能更坏。拥塞常常趋千恶化。</p>
<p>•      原因</p>
<p>•      复杂</p>
<p>•      某个结点缓存的容量太小时， 到达该结<br> 点的分组因无存储空间暂存而不得不被丢弃。</p>
<p>•      理机处理的速率太慢可能引起网络的拥塞。 简单地将处理机的速率提高， 可能会使上述情况缓解一些， 但往往又会将瓶颈转移到其他地方。</p>
<p>·        拥塞控制</p>
<p>•      定义</p>
<p>•      防止过多的数据注入到网络中， 这样可以使网络中的路由器或链路不致过载。</p>
<p>•      是一个全局性的过程</p>
<p>•      拥塞控制与流量控制的关系</p>
<p>•      关系密切</p>
<p>•      流量控制往往是指点对点通信量的控制， 是个端到端的问题</p>
<p>•      </p>
<p><img src="https://i.loli.net/2020/06/11/Rw6FqG42QnVoJLN.png" alt="clip_image016.png"></p>
<p>•      方法</p>
<p>•      开环控制</p>
<p>•      在设计网络时事先将有关发生拥塞的因素考虑周到， 力求网络在工作时不产生拥塞。</p>
<p>•      闭环控制</p>
<p>•      监测网络系统以便检测到拥塞在何时、 何处发生。</p>
<p>•      把拥塞发生的信息传送到可采取行动的地方。</p>
<p>•      调整网络系统的运行以解决出现的问题。</p>
<h3 id="TCP的拥塞控制方法"><a href="#TCP的拥塞控制方法" class="headerlink" title="TCP的拥塞控制方法"></a>TCP的拥塞控制方法</h3><p>·        四种方法共同使用</p>
<p>•      慢开始(slow-start)</p>
<p>•      由小到大逐渐增大发送窗口（指数增加）</p>
<p>•      拥塞窗口cwnd每次的增加量=min (N, SMSS )</p>
<p>•      N 是原先未被确认的、 但现在被刚收到的确认报文段所确认的字节数。</p>
<p>•      拥 塞 避 免(congestion avoidance)</p>
<p>•      拥塞避免算法的思路是让拥塞窗口cwnd缓慢地增大， 即每经过一个往返时间RTT就把发送方的拥塞窗口 cwnd 加1,而不是像慢开始阶段那样加倍增长。 因此 在拥塞避免阶段就有“加法增大” AI (Additive Increase)的 特点。 这表明在拥塞避免阶段，拥塞窗口cwnd按线性规律缓慢增长， 比慢开始算法的拥塞窗口增长速率缓慢得多。</p>
<p>•       快重传(fast retransmit)</p>
<p>•      发送方只要一连收到3个重复确认， 就知道接收方确实没有收到报文段M3, 因而应当立即进行重传</p>
<p>•      </p>
<p><img src="https://i.loli.net/2020/06/11/84hODIkWaSi6LZR.png" alt="clip_image018.png"></p>
<p>•      快重传可以使整个网络的吞吐量提高约20%。</p>
<p>•      快恢复(fast recovery)</p>
<p>•      发送方调整门限值ssthresh = cwnd / 2</p>
<p>•      拥塞窗口cwnd= ssthresh</p>
<p>•      开始执行拥塞避免算法</p>
<p>•      概要发送方控制拥塞窗口的原则 是：只要网络没有出现拥塞，拥塞窗口就可以再增大一些， 以便把更多的分组发送出去， 这样就可以提高网络的利用率。 但只要网络出现拥塞或有可能出现拥塞，就必须把拥塞窗口减小一些， 以减少注入到网络中的分组数， 以便缓解网络出现的拥塞。</p>
<p>•      发送方又是如何知道网络发生了拥塞</p>
<p>•      判断网络拥塞的依据就是出现了超时。</p>
<p>•      慢开始门限 ssthresh</p>
<p>•      cwnd&lt; ssthresh时， 使用上述的慢开始算法。</p>
<p>•      cwnd&gt; ssthresh时， 停止使用慢开始算法而改用拥塞避免算法。</p>
<p>•      cwnd= ssthresh时， 既可使用慢开始算法， 也可使用拥塞避免算法。</p>
<p>•      </p>
<p><img src="https://i.loli.net/2020/06/11/ACFKPpbcMh4TLUu.png" alt="clip_image019.png"></p>
<p>·        流程图</p>
<p>•      </p>
<p><img src="https://i.loli.net/2020/06/11/mwjQfucqle7pkgP.png" alt="clip_image021.png"></p>
<h3 id="主动队列管理AQM"><a href="#主动队列管理AQM" class="headerlink" title="主动队列管理AQM"></a>主动队列管理AQM</h3><p>·        略</p>
<h2 id="TCP的运输连接管理"><a href="#TCP的运输连接管理" class="headerlink" title="TCP的运输连接管理"></a>TCP的运输连接管理</h2><h3 id="运输连接"><a href="#运输连接" class="headerlink" title="运输连接"></a>运输连接</h3><p>·        连接建立</p>
<p>•      要解决的问题</p>
<p>•      要使每一方能够确知对方的存在</p>
<p>•      要允许双方协商 一些参数</p>
<p>•      能够对运输实体资源</p>
<p>•      主动发起连接建立的应用进程叫做客户(client),<br> 而被动等待连接建立的应用进程叫做服务器(server)。</p>
<p>•      过程</p>
<p>•      三次握手</p>
<p><img src="https://i.loli.net/2020/06/11/lED46Aticw5K71x.png" alt="clip_image022.png"></p>
<p>·        数据传送</p>
<p>·        连接释放</p>
<p>•      过程</p>
<p>•      四报文握手</p>
<p><img src="https://i.loli.net/2020/06/11/hjVpKM3yqG9RFmZ.png" alt="clip_image023.png"></p>
<p>•      A必须等待2MSL的时间</p>
<p>•      为了保证A发送的最后一一个ACK报文段能够到达B。</p>
<p>•      防止已失效的连接请求报文段” 出现在本连接中。</p>
<p>•      数据传输结束后，通信的双方都可释放连接。</p>
<h3 id="TCP的有限状态机"><a href="#TCP的有限状态机" class="headerlink" title="TCP的有限状态机"></a>TCP的有限状态机</h3><p>·         </p>
<p><img src="https://i.loli.net/2020/06/11/5jDLVlCMArvtFca.png" alt="clip_image024.png"></p>
<p>•      粗实线箭头表示对客户进程的正常变迁。<br> 粗虚线箭头表示对服务器进程的正常变迁。<br> 另一种细线箭头表示异常变迁。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>计网笔记</tag>
        <tag>运输层</tag>
      </tags>
  </entry>
</search>
