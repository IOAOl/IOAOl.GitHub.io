<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>POJ - 1611-day3-F</title>
    <url>/2019/09/01/POJ-1611-day3-F.html</url>
    <content><![CDATA[<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">

<h1 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h1><p><a href="http://poj.org/problem?id=1611" target="_blank" rel="noopener">POJ - 1611</a></p>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>Severe acute respiratory syndrome (SARS), an atypical pneumonia of unknown aetiology, was recognized as a global threat in mid-March 2003. To minimize transmission to others, the best strategy is to separate the suspects from others.<br>In the Not-Spreading-Your-Sickness University (NSYSU), there are many student groups. Students in the same group intercommunicate with each other frequently, and a student may join several groups. To prevent the possible transmissions of SARS, the NSYSU collects the member lists of all student groups, and makes the following rule in their standard operation procedure (SOP).<br>Once a member in a group is a suspect, all members in the group are suspects.<br>However, they find that it is not easy to identify all the suspects when a student is recognized as a suspect. Your job is to write a program which finds all the suspects.</p>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><p>The input file contains several cases. Each test case begins with two integers n and m in a line, where n is the number of students, and m is the number of groups. You may assume that 0 &lt; n &lt;= 30000 and 0 &lt;= m &lt;= 500. Every student is numbered by a unique integer between 0 and n−1, and initially student 0 is recognized as a suspect in all the cases. This line is followed by m member lists of the groups, one line per group. Each line begins with an integer k by itself representing the number of members in the group. Following the number of members, there are k integers representing the students in this group. All the integers in a line are separated by at least one space.<br>A case with n = 0 and m = 0 indicates the end of the input, and need not be processed.</p>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><p>For each case, output the number of suspects in one line.</p>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>input</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">100 4</span><br><span class="line">2 1 2</span><br><span class="line">5 10 13 11 12 14</span><br><span class="line">2 0 1</span><br><span class="line">2 99 2</span><br><span class="line">200 2</span><br><span class="line">1 5</span><br><span class="line">5 1 2 3 4 5</span><br><span class="line">1 0</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure>

<p>output</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>并查集，找与0有关的所有人，用bb数组来存放头目有关的人数，最后找0的头目，就能在数组里找到所有与他有关的人。</p>
<h1 id="AC的代码"><a href="#AC的代码" class="headerlink" title="AC的代码"></a>AC的代码</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> gro,s,aa[<span class="number">30005</span>],bb[<span class="number">30005</span>],cc[<span class="number">30005</span>];    <span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span>                 <span class="comment">//寻找根节点的函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (aa[x] == x)</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		aa[x] = <span class="built_in">find</span>(aa[x]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x1 = <span class="built_in">find</span>(x);</span><br><span class="line">	<span class="keyword">int</span> y1 = <span class="built_in">find</span>(y);</span><br><span class="line">	<span class="keyword">if</span> (x1 != y1)            <span class="comment">//根节点不同连接</span></span><br><span class="line">	&#123;</span><br><span class="line">		aa[x1] = y1;</span><br><span class="line">		bb[y1] = bb[x1] + bb[y1];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s &gt;&gt; gro)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (s == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; <span class="number">30005</span>; r++)</span><br><span class="line">		&#123;</span><br><span class="line">			aa[r] = r;</span><br><span class="line">			bb[r] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> f = <span class="number">0</span>; f &lt; gro; f++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> p;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;p);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> q = <span class="number">0</span>; q &lt; p; q++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;cc[q]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; p - <span class="number">1</span>; x++)</span><br><span class="line">			&#123;</span><br><span class="line">				join(cc[x], cc[x + <span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> k = <span class="built_in">find</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; bb[k] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>ExpressionToValue</title>
    <url>/2020/05/17/ExpressionToValue.html</url>
    <content><![CDATA[<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">

<h1 id="表达式求值-wpf"><a href="#表达式求值-wpf" class="headerlink" title="表达式求值  wpf"></a>表达式求值  wpf</h1><p>主要思想：表达式递归切割求值。</p>
<p>主要分成三个类。Expression，item和factor。</p>
<p><img src="https://i.loli.net/2020/05/18/D36Pi85OzXsHYqI.png" alt="1589730555323.png"></p>
<h1 id="Expression（-）"><a href="#Expression（-）" class="headerlink" title="Expression（+/-）"></a>Expression（+/-）</h1><p>由divStringExp类的divexp（）方法分割字符串</p>
<p>将表达式中的加法和减法消除。</p>
<p>先用栈找出最外层的括号：</p>
<p><img src="https://i.loli.net/2020/05/18/9yvzgBIKtb4h1Fr.png" alt="1589730585178.png"></p>
<p>然后往括号两端扩展</p>
<p><img src="https://i.loli.net/2020/05/18/wQOiU6col4kmjx2.png" alt="1589730598531.png"></p>
<p>切割加号得到两个items</p>
<h1 id="Item"><a href="#Item" class="headerlink" title="Item"></a>Item</h1><p>把字符串分成被除数和除数</p>
<p>分两种情况：有括号和无括号</p>
<h2 id="有括号的情况："><a href="#有括号的情况：" class="headerlink" title="有括号的情况："></a>有括号的情况：</h2><p>同样是用栈判断最外层的括号</p>
<p><img src="https://i.loli.net/2020/05/18/r9RHuIQCJpPechX.png" alt="1589730611640.png"></p>
<p>把括号内的乘号和除号省略，分割外面的乘号和除号</p>
<p>并把除数之间和被除数之间相连（或者用两个数组将分子和分母保存起来）</p>
<p><img src="https://i.loli.net/2020/05/18/MzuFHbxXe1aEsKC.png" alt="1589730620914.png"></p>
<h2 id="没括号的情况："><a href="#没括号的情况：" class="headerlink" title="没括号的情况："></a>没括号的情况：</h2><p>遇到除号将后面的除数加到除数字符串   </p>
<h1 id="Factor"><a href="#Factor" class="headerlink" title="Factor"></a>Factor</h1><p>拆开最外层括号外的乘号</p>
<p>剩下的元素分成5种情况</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="一元函数"><a href="#一元函数" class="headerlink" title="一元函数"></a>一元函数</h4><p>递归求括号内的值，再代入函数</p>
<p>例如sin(exp)</p>
<h4 id="多元函数（目前只有log（a-b）函数）"><a href="#多元函数（目前只有log（a-b）函数）" class="headerlink" title="多元函数（目前只有log（a,b）函数）"></a>多元函数（目前只有log（a,b）函数）</h4><p>例如log(a,log(b,c))，将括号内提出来“a,log(b,c)”</p>
<p>将没在括号内的，分割</p>
<p>分成“a“和”log(b,c)”再分别递归求值。</p>
<h3 id="次方"><a href="#次方" class="headerlink" title="次方"></a>次方</h3><p>求最外层括号外的次方</p>
<p>最外层是括号：</p>
<p>拆括号后递归求值</p>
<p><strong>注意：次方内可能也有多个表达式</strong></p>
<p>例如:2^sin(a)</p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>找coefficient类将值返回</p>
<h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><p>用table.Compute（）方法转化</p>
<h1 id="参数（Coefficient）类"><a href="#参数（Coefficient）类" class="headerlink" title="参数（Coefficient）类"></a>参数（Coefficient）类</h1><p>正则表达式找变量并忽略掉所有的函数名，并初始赋值1</p>
<h1 id="tool类"><a href="#tool类" class="headerlink" title="tool类"></a>tool类</h1><p>装有静态的函数名对象，方便外界访问</p>
<h1 id="界面设计"><a href="#界面设计" class="headerlink" title="界面设计"></a>界面设计</h1><p>Stackpanel中嵌套三个Grid布局</p>
<p><img src="https://i.loli.net/2020/05/18/wpmizh45WgBr3GL.png" alt="1589730840570.png"></p>
<h2 id="Grid布局1"><a href="#Grid布局1" class="headerlink" title="Grid布局1"></a>Grid布局1</h2><p>计算结果用label显示</p>
<h2 id="Grid布局2"><a href="#Grid布局2" class="headerlink" title="Grid布局2"></a>Grid布局2</h2><p>四个listbox分别显示变量名，范围，滑块，变量值</p>
<h2 id="Grid布局3"><a href="#Grid布局3" class="headerlink" title="Grid布局3"></a>Grid布局3</h2><p>输入栏和确定按钮</p>
<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h5 id="确定按钮click事件"><a href="#确定按钮click事件" class="headerlink" title="确定按钮click事件"></a>确定按钮click事件</h5><p>初始化动态添加元素到四个listbox</p>
<h5 id="变量范围keydown事件"><a href="#变量范围keydown事件" class="headerlink" title="变量范围keydown事件"></a>变量范围keydown事件</h5><p>判断输入是否是数字</p>
<h5 id="四个listbox滑动条同步事件"><a href="#四个listbox滑动条同步事件" class="headerlink" title="四个listbox滑动条同步事件"></a>四个listbox滑动条同步事件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VisualTreeHelper.GetChild(VisualTreeHelper.GetChild(this.listBox4, 0), 0) as ScrollViewer;&#x2F;&#x2F;找到scrollviewer对象</span><br><span class="line">		sv4.ScrollChanged +&#x3D; newScrollChangedEventHandler(listBox4_ScrollChanged);</span><br><span class="line">&#x2F;&#x2F;添加事件</span><br><span class="line">        private void listBox4_ScrollChanged(object sender, ScrollChangedEventArgs e)</span><br><span class="line">        &#123;</span><br><span class="line">        if (sv4 !&#x3D; null)</span><br><span class="line">        &#123;</span><br><span class="line">            sv3.ScrollToVerticalOffset(sv4.VerticalOffset);</span><br><span class="line">            sv2.ScrollToVerticalOffset(sv4.VerticalOffset);</span><br><span class="line">            sv1.ScrollToVerticalOffset(sv4.VerticalOffset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="双击变量名产生滑块动画事件"><a href="#双击变量名产生滑块动画事件" class="headerlink" title="双击变量名产生滑块动画事件"></a>双击变量名产生滑块动画事件</h5><p>System.Windows.Threading.DispatcherTimer类用于动画制作</p>
<p>该类用Interval方法设置事件的发生间隔</p>
<p>tmr.Interval = TimeSpan.FromSeconds(0.01);</p>
<p>给他的tick事件添加委托threads方法</p>
<p>start方法启用</p>
<p>判断条件满足后停止</p>
<p>end方法终止</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void animation(object sender, RoutedEventArgs e)</span><br><span class="line">        &#123;</span><br><span class="line">            Label label &#x3D; sender as Label;</span><br><span class="line">            int count &#x3D; 0;</span><br><span class="line">            foreach(Label l1 in listBox1.Items)</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">                if (l1 &#x3D;&#x3D; label)</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            ProcessToanimation &#x3D; 0;</span><br><span class="line">            CountToAnimation &#x3D; count;</span><br><span class="line">            System.Windows.Threading.DispatcherTimer tmr &#x3D; new System.Windows.Threading.DispatcherTimer();</span><br><span class="line">            tmr.Interval &#x3D; TimeSpan.FromSeconds(0.01);</span><br><span class="line">            tmr.Tick +&#x3D; new EventHandler(threads);</span><br><span class="line">            tmr.Start();</span><br><span class="line">        &#125;</span><br><span class="line">private void threads(object c,EventArgs e)</span><br><span class="line">    &#123;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            int count &#x3D; CountToAnimation;</span><br><span class="line">            slidersList[count-1].Value &#x3D; ProcessToanimation;</span><br><span class="line">            double td &#x3D; (slidersList[count - 1].Value - 5) * Convert.ToDouble(rangesList[count - 1].Text);</span><br><span class="line">            td &#x3D; td &#x2F; 5;</span><br><span class="line">            valuesList[count - 1].Content &#x3D; td;</span><br><span class="line">            variableCollection.vlist[count - 1].value &#x3D; td;</span><br><span class="line">            exp.setVariables(variableCollection);</span><br><span class="line">            result.Content &#x3D; exp.getValue();</span><br><span class="line">            ProcessToanimation +&#x3D; 0.025;</span><br><span class="line">            if (ProcessToanimation &gt;&#x3D; 10)</span><br><span class="line">            &#123;</span><br><span class="line">                slidersList[count-1].Value &#x3D; 6;</span><br><span class="line">                double ts &#x3D; (slidersList[count - 1].Value - 5) * Convert.ToDouble(rangesList[count - 1].Text)&#x2F;5;</span><br><span class="line">                valuesList[count - 1].Content &#x3D; ts;</span><br><span class="line">                variableCollection.vlist[count - 1].value &#x3D; ts;</span><br><span class="line">                exp.setVariables(variableCollection);</span><br><span class="line">                result.Content &#x3D; exp.getValue();</span><br><span class="line">                (c as System.Windows.Threading.DispatcherTimer).Stop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception e1)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>程序</category>
      </categories>
      <tags>
        <tag>WPF</tag>
        <tag>表达式求值</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/08/30/hello-world.html</url>
    <content><![CDATA[<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">

<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment<img src="/2019/08/30/QQ%E6%88%AA%E5%9B%BE20190815084633.png" alt="QQ截图20190815084633"></a></p>
]]></content>
  </entry>
  <entry>
    <title>TSPppt</title>
    <url>/2019/09/23/TSPppt.html</url>
    <content><![CDATA[<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">

<h1 id="TSP的几个算法"><a href="#TSP的几个算法" class="headerlink" title="TSP的几个算法"></a>TSP的几个算法</h1><p>这是一个自己做的ppt的记录。</p>
<h2 id="TSP实例"><a href="#TSP实例" class="headerlink" title="TSP实例"></a>TSP实例</h2><p>有一位商人，他想访问德国的某些城市，要求：</p>
<ol>
<li>所走路程最短；</li>
<li>每个城市只能访问一次；</li>
<li>从某城市出发，最后回到该城市。</li>
</ol>
<p><img src="https://i.loli.net/2019/09/23/ivBU6RxodJYnZKr.png" alt="1568996702133 - 副本.png"></p>
<p>让我们看一下为什么要学这个问题，主要来看一下tsp到底有什么用。</p>
<p><img src="https://i.loli.net/2019/09/23/ouY7XfMKmTSia8p.png" alt="1568997255774 - 副本.png"></p>
<p>看完了应用，我们来看一下怎么去解决这个问题吧</p>
<p>首先先任意选一个点作为起点，然后开始连接就可以看到有n！种情况</p>
<p><img src="https://i.loli.net/2019/09/23/iCTeADruUnYm9Ia.png" alt="1569036262994 - 副本.png"></p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>我们尝试优化一下，目前最好的优化是通过动态规划去解决，复杂度为o（2^n*n^2）</p>
<p>首先得懂得为什么可以使用动态规划，<strong>动态规划就是在求解一个复杂问题时，将其分解为若干个简单问题。通过求解简单问题的最优解，来找到目标问题的最优解。</strong></p>
<p><strong>使用动态规划，需要问题本身有最优子结构</strong>，我们需要找到要解决的问题的子问题。</p>
<p>现在找一下tsp的最优子结构</p>
<p><img src="https://i.loli.net/2019/09/23/WFVGmarTHC384hi.png" alt="1569036739438 - 副本.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">从0出发，经过[1,2,3]这几个城市，然后回到0，使得花费最少。要实现这个要求，需要从下面三个实现方案中选择花费最少的方案。</span><br></pre></td></tr></table></figure>

<p>　　　　1、 从0出发，到1，然后再从1出发，经过[2,3]这几个城市，然后回到0，使得花费最少。</p>
<p>　　　　2、 从0出发，到2，然后再从2出发，经过[1,3]这几个城市，然后回到0，使得花费最少。</p>
<p>　　　　3、 从0出发，到3，然后再从3出发，经过[1,2]这几个城市，然后回到0，使得花费最少。<br>  可以发现，三个小的解决方案的最优解，构成了大的解决方案，所以这个问题具有最优子结构，可以用动态规划来实现。</p>
<p><img src="https://i.loli.net/2019/09/23/qcUid3omRzaVG59.png" alt="1569036847226.png"></p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>这个算法由于空间复杂度有o(n*2^n)，所以做一般的算法题要用到状态压缩，用0代表没有到达该城市，1代表去过该城市。例如：11011代表1-5个城市只有第三个城市没去过。上述的S集合就是通过状压保存。</p>
<p><img src="https://i.loli.net/2019/09/23/vxHhVn84XWAS1Pp.png" alt="1569036878291.png"></p>
<p>说了这么多，看一下怎么解决，主要分为4个步骤。</p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>（1）选择G的任意一个顶点r作为根节点(出发/结束点)</p>
<p>（2）用Prim算法找出G的一棵以r为根的最小生成树T</p>
<p>（3）前序遍历访问树T，得到遍历顺序组成的顶点表L</p>
<p>（4）将r加到顶点表L的末尾，按L中顶点的次序组成哈密顿回路H</p>
<p>简单的解释一下其中的名词，有需要自己了解</p>
<h4 id="prim算法"><a href="#prim算法" class="headerlink" title="prim算法"></a>prim算法</h4><p>Prim算法如何进行计算？<br>①选定一个起点做为一个集合 a ，剩下的点为另一个集合 b</p>
<p>②将横跨两个集合且权重在其中最小的边加入最小生成树</p>
<p>③将刚刚加入最小生成树的边中不在集合 a 中的点加入集合 a，直到所有的点加入集合 a</p>
<h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><p>首先访问根节点，然后遍历左子树，最后遍历右子树。</p>
<p><img src="https://i.loli.net/2019/09/23/qZefMb7NgIaR1AY.gif" alt="GIF.gif"></p>
<h2 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法"></a>遗传算法</h2><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>遗传算法（Genetic Algorithm, GA）是模拟达尔文生物进化论的自然选择和遗传学机理的生物进化过程的计算模型，是一种通过模拟自然进化过程搜索最优解的方法。</p>
<h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h4><p><img src="https://i.loli.net/2019/09/23/H8VtSwGa3Ax42TJ.png" alt="1569037387267.png"></p>
<p>这里补充一下细节：</p>
<ol>
<li>交叉操作：随机挑取在染色体（路径）上的一个序号（2-n-1）交换两条染色体序号后面的（基因），这里需要进行基因冲突处理，即交换后要检查是否交换过来了已有的基因，如果是则和另一条的重复基因交换。</li>
<li>变异操作，对一条基因选出i，j（0&lt;i&lt;j&lt;=n）将其中的基因交换。</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>TSP</tag>
        <tag>遗传算法</tag>
        <tag>动态规划</tag>
        <tag>Prim</tag>
      </tags>
  </entry>
  <entry>
    <title>test_pic</title>
    <url>/2019/09/01/test-pic.html</url>
    <content><![CDATA[<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">

<p>微博的图床：<a href="https://pic.lizenghai.com/#" target="_blank" rel="noopener">https://pic.lizenghai.com/#</a><br>每日最多上传100张。还可能会失败？<br><img src="http://wx3.sinaimg.cn/large/9cd3e769gy1g6kg8jv0uwj20gi0jyh1c.jpg" alt="aaa"></p>
<p>github图：<br>可能dns污染上不去。<br><img src="/2019/09/01/test-pic%5Caaa.jpg" alt="testgithub图"></p>
<p>sm.ms图床：官网地址：<a href="https://sm.ms" target="_blank" rel="noopener">https://sm.ms</a><br>特点：永久存储免注册，图片链接支持https，可以删除上传的图片，提供多种图片链接格式<br>图片上传限制：每个图片最大5M，每次最多上传10张<br><img src="https://i.loli.net/2019/09/01/himBgnrRaPVld1T.png" alt="20190815084633.png"></p>
<p>聚合图床：官网地址： <a href="https://www.superbed.cn/" target="_blank" rel="noopener">https://www.superbed.cn/</a><br>特点：将图片分发到多处备份，借助其本身的CDN加速功能，节省服务器流量，不用担心图片被删除。<br><img src="https://ae01.alicdn.com/kf/H95cba61bf4a14818b70ccb89894b900ci.png" alt="aaa"></p>
]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>天国旅立</title>
    <url>/2019/09/09/%E5%A4%A9%E5%9B%BD%E6%97%85%E7%AB%8B.html</url>
    <content><![CDATA[<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">

<p><img src="https://i.loli.net/2019/09/09/IcUw5WsjhbGYmlT.png" alt="Saved_Memory2.png"></p>
<p><img src="https://i.loli.net/2019/09/09/XDAKdzLsoYnP3HF.png" alt="Saved_Memory8.png"><br><img src="https://i.loli.net/2019/09/09/KtRvuZnfELqWC9k.png" alt="Saved_Memory9.png"><br><img src="https://i.loli.net/2019/09/09/QCnb92H8UfmLEkO.png" alt="Saved_Memory10.png"><br><img src="https://i.loli.net/2019/09/09/WYmx4RS1ebr6DIF.png" alt="Saved_Memory3.png"><br><img src="https://i.loli.net/2019/09/09/BV2Fr1oiyPvDxqd.png" alt="Saved_Memory4.png"><br><img src="https://i.loli.net/2019/09/09/ihdkgzsEnYFUTN7.png" alt="Saved_Memory6.png"><br><img src="https://i.loli.net/2019/09/09/YJrthXoDLxFyTGq.png" alt="Saved_Memory1.png"><br><img src="https://i.loli.net/2019/09/09/PlLtiIhN3yRA4ns.png" alt="Saved_Memory5.png"><br><img src="https://i.loli.net/2019/09/09/nz9eSMLa5yUxvfK.png" alt="Saved_Memory7.png"><br><img src="https://i.loli.net/2019/09/09/xagRIqXjJKv2ny7.png" alt="Saved_Memory11.png"><br><img src="https://i.loli.net/2019/09/09/tT4IaXVMRHxGJsS.png" alt="Saved_Memory14.png"><br><img src="https://i.loli.net/2019/09/09/pDMBcbTXQK1Asg5.png" alt="Saved_Memory12.png"><br><img src="https://i.loli.net/2019/09/09/b3wZcoDHPxG21dm.png" alt="Saved_Memory13.png"><br><img src="https://p.pstatp.com/origin/fe8f000115e907fd41cd" alt="Saved_Memory15.png"></p>
]]></content>
      <tags>
        <tag>Gallery</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络运输层笔记</title>
    <url>/2020/06/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82%E7%AC%94%E8%AE%B0.html</url>
    <content><![CDATA[<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">

<p>`<strong>运输层</strong></p>
<p> <img src="https://i.loli.net/2020/06/11/8uy5a2vfp1lMSNx.png" alt="运输层.png"></p>
<h1 id="运输层协议概述"><a href="#运输层协议概述" class="headerlink" title="运输层协议概述"></a>运输层协议概述</h1><h2 id="进程之间端到端的逻辑通信"><a href="#进程之间端到端的逻辑通信" class="headerlink" title="进程之间端到端的逻辑通信"></a>进程之间端到端的逻辑通信</h2><h3 id="复用"><a href="#复用" class="headerlink" title="复用"></a>复用</h3><p>·        发送方不同的应用进程都可以使用同一个运输层协议传送数据</p>
<h3 id="分用"><a href="#分用" class="headerlink" title="分用"></a>分用</h3><p>·        是指接收方的运输层在剥去报文的首部后能够把这些数据正确交付目的应用进程。</p>
<h2 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h2><h2 id="运输层的端口"><a href="#运输层的端口" class="headerlink" title="运输层的端口"></a>运输层的端口</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>·        软件端口</p>
<p>·        16位65535</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>·        服务端端口</p>
<p>•      熟知端口号（0-1023）</p>
<p>•      登记端口号（1024-49151）</p>
<p>·        客户端端口（短暂端口号）（49152-65535）</p>
<h1 id="UDP-User-Datagram-Protocol）用户数据报协议"><a href="#UDP-User-Datagram-Protocol）用户数据报协议" class="headerlink" title="UDP(User Datagram Protocol）用户数据报协议"></a>UDP(User Datagram Protocol）用户数据报协议</h1><h2 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h2><p>不需要先建立连接（不可靠）</p>
<p>相比ip数据报增加的功能</p>
<p>·        复用和分用</p>
<p>·        差错检测</p>
<p>面向报文（直接使用应用层报文）</p>
<p>没有拥塞控制（用于多媒体通信）</p>
<p>n对n通信（n=1或多）</p>
<p>首部（8字节）开销小</p>
<p>不用套接字</p>
<h2 id="首部"><a href="#首部" class="headerlink" title="首部"></a>首部</h2><p>源端口2位</p>
<p>目的端口2位</p>
<p>长度2位</p>
<p>校验和2位</p>
<p>·        首部和数据部分一起校验</p>
<p>伪首部12位</p>
<p>·        计算校验和</p>
<p>·        不传输</p>
<h1 id="TCP（Transmission-Control-Protocol）-传输控制协议"><a href="#TCP（Transmission-Control-Protocol）-传输控制协议" class="headerlink" title="TCP（Transmission Control Protocol） 传输控制协议"></a>TCP（Transmission Control Protocol） 传输控制协议</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>提供面向连接的服务（不多播或广播）</p>
<p>·        只能点对点</p>
<p>可靠交付的服务</p>
<p>全双工通信</p>
<p>面向字节流</p>
<p>·        随时截断发送给上层</p>
<p>•      根据拥塞情况和窗口值决定发送大小</p>
<h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><h3 id="连接的端点：套接字socket"><a href="#连接的端点：套接字socket" class="headerlink" title="连接的端点：套接字socket"></a>连接的端点：套接字socket</h3><p>·        TCP 连接 ：：= {socket1, socket2} = {(IP1: port1), (IP2: port2)}</p>
<h2 id="可靠传输的工作原理（使用协议降低出错）"><a href="#可靠传输的工作原理（使用协议降低出错）" class="headerlink" title="可靠传输的工作原理（使用协议降低出错）"></a>可靠传输的工作原理（使用协议降低出错）</h2><h3 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h3><p>·        每发送完一个分组就停止发送， 等待对方的确认。 在收到确认后再发送下一个分组。</p>
<p>·        情况</p>
<p>•      </p>
<p><img src="https://i.loli.net/2020/06/11/gGUXlkcuzNnqeAm.png" alt="clip_image002.png"></p>
<p>•      </p>
<p><img src="https://i.loli.net/2020/06/11/dZvIzsNBw2q8liR.png" alt="clip_image004.png"></p>
<p>•      A只要超过了一段时间（超时计时器）仍然没有收到确认， 就认为刚才发送的分组丢失了，因而重传前面发送过的分组 。 这就叫做超时重传。</p>
<p>•      注意事项</p>
<p>•      发送方暂存已发送分组</p>
<p>•      分组标号</p>
<p>•      设计重传时间长于往返时间</p>
<p>•      确认丢失和确认迟到</p>
<p>•      重复的确认收下就丢弃</p>
<p>•      重复的分组收到后丢弃，然后发送确认</p>
<p>·        信道利用率</p>
<p>•      </p>
<p><img src="https://i.loli.net/2020/06/11/mPD2n7856eWlc4O.png" alt="clip_image006.png"></p>
<p>•      </p>
<p><img src="https://i.loli.net/2020/06/11/gbGycatLwp6K4ov.png" alt="clip_image008.png"></p>
<h3 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h3><p>·         </p>
<p><img src="https://i.loli.net/2020/06/11/EV6JAHmnpouwtIv.png" alt="clip_image010.png"></p>
<p>•      累积确认</p>
<p>•      接收方不必对收到的分组逐个发送确认， 而是在收到几个分组后， 对按序到达的最后一个分组发送确认</p>
<p>•      缺点</p>
<p>•      不能向发送方反映出接收方已经正确收到的所有分组的信息。</p>
<p>•      go-back-N</p>
<p>•      优点</p>
<p>•      容易实现， 即使确认丢失也不必重传。</p>
<h2 id="TCP报文段的首部格式"><a href="#TCP报文段的首部格式" class="headerlink" title="TCP报文段的首部格式"></a>TCP报文段的首部格式</h2><h3 id="报文段"><a href="#报文段" class="headerlink" title="报文段"></a>报文段</h3><p>·        TCP报文段首部的前20个字节是固定的（图5-14), 后面有4n字节是根据需要而增加<br> 的选项(n是整数）。 因此TCP首部的最小长度是20字节。</p>
<p>·         </p>
<p><img src="https://i.loli.net/2020/06/11/pVDPEubF5m1RL7Y.png" alt="clip_image012.png"></p>
<p>•      源端口和目的端口 各占 2 个字节，</p>
<p>•      序号 占 4 字节。</p>
<p>•      确认号 占 4 字节=序号+长度+1</p>
<p>•      希望下一个发送分组的序号</p>
<p>•      数据偏移 占 4 位（0-15）可加长到60字节</p>
<p>•      首部长度</p>
<p>•      保留 占 6 位， 保留为今后使用， 但目前应置0。</p>
<p>•      紧急 URG</p>
<p>•      当 URG 置 l 时， 发送应用进程就告诉发送方的 TCP 有紧急数据要传送。 千是发送方TCP 就把紧急数据插入到本报文段数据的最前面， 而在紧急数据后面的数据仍是普通数据。 这时要与首部中紧急指针(Urgent Pointer)字段配合使用。</p>
<p>•      确认 ACK (ACKnowledgment) 仅当 ACK= 1 确认号字段才有效。 当 ACK=0时， 确认号无效。</p>
<p>•      推送PSH (PuSH)</p>
<p>•      不等缓存满直接向上交付</p>
<p>•      复位RST ( ReSeT)</p>
<p>•      当RST= 1时， 表明 TCP连接中出现严重差错（如由于主机崩溃或其他原因）， 必须释放连接， 然后再重新建立运输连接。RST置l还用拒绝一个非法的报文段或拒绝打开一个连接。RST 也可称为重建位或重置位 。</p>
<p>•      同步SYN</p>
<p>•      同步SYN ( SYNchron ization) 在连接建立时用来同步序号。 当SYN = 1 而 ACK= 0 时， 表明这是一个连接请求报文段。 对方若同意建立连接， 则应在响应的报文段中使SYN= 1 和ACK= 1。 </p>
<p>•      终止FIN</p>
<p>•      终止连接</p>
<p>•      窗口 占2字节</p>
<p>•      窗口字段明确指出了现在允许对方发送的数据量</p>
<p>•      检验和</p>
<p>•      跟udp的伪首部一样</p>
<p>•      伪首部第4 个字段中的 17 改为6<br> (TCP 的协议号是 6),</p>
<p>•      紧急指针 占2字节</p>
<p>•      紧急指针仅在URG= 1时才有意义， 它指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据）。无视窗口</p>
<p>•      选项 最长40字节</p>
<p>•      TCP 最初只规定了一种选项， 即最大报文段长度MSS (Maximum Segment Size)</p>
<p>•      窗口扩大选项 3字节 （16+s）偏移量</p>
<p>•      时间戳选项 10字节</p>
<p>•      计算往返时间RTT</p>
<p>•      防止序号绕回(处理序号超过2^32的情况)</p>
<p>•      选择确认选项</p>
<p>•      待续</p>
<h2 id="TCP-可靠传输的实现"><a href="#TCP-可靠传输的实现" class="headerlink" title="TCP 可靠传输的实现"></a>TCP 可靠传输的实现</h2><h3 id="以字节为单位的滑动窗口"><a href="#以字节为单位的滑动窗口" class="headerlink" title="以字节为单位的滑动窗口"></a>以字节为单位的滑动窗口</h3><p>·        根据窗口值构造发送窗口</p>
<p>•      </p>
<p><img src="https://i.loli.net/2020/06/11/jVUJ6yrOawzovEm.png" alt="clip_image014.png"></p>
<p>•      P3 -P1 =A 的发送窗口<br> P2 -P1 =已发送但尚未收到确认的字节数<br> P3 -P2 =允许发送但当前尚未发送的字节数（又称为可用窗口或有效窗口）</p>
<p>•      时延影响，发送窗口一般小于窗口值</p>
<p>•      对于不按序到达的数据应如何处理， TCP 标准并无明确规定，若丢弃，增加网络负担</p>
<p>•      第三， TCP 要求接收方必须有累积确认的功能， 这样可以减小传输开销，可以将要发送的数据合并确认信息，但不应推迟太久</p>
<h3 id="超时重传时间的选择"><a href="#超时重传时间的选择" class="headerlink" title="超时重传时间的选择"></a>超时重传时间的选择</h3><p>·        自适应算法</p>
<p>•      TCP保留了RTT的一 个加权平均往返<br> 时间RTTs( 这又称为平滑的往返时间，</p>
<p>•      新的RTTs = (1 -a) x (旧的RTTs) + a x ( 新的RTT样本）0&lt;=a&lt; 1</p>
<p>•      报文段的往返时间RTT</p>
<p>•      超时重传时间RTO</p>
<p>•      RTO = RTTs + 4 x RTTD</p>
<p>•      RTTD 是RTT 的偏差的加权平均值</p>
<p>•      新的RTTD = (1 - β) x (旧的RTTo)+βx|RTTs-新的RTT样本|<br> 这里β是个小于 1 的系数， 它的推荐值是1/4</p>
<p>•      往返时间的测量</p>
<p>•      Kam算法</p>
<p>•      在计算加权平均 RTTS时， 只要报文段重传了，就不采用其往返时间样本。 这样得出的加权平均RTTS和RTO就较准确。</p>
<p>•      修正</p>
<p>•      文段每重传一次， 就把超时重传时间RTO增大一些。 典型的做法是取新的重传时间为旧的重传时间的 2 倍。 当不再发生报文段的重传时，才计算超时重传时间。</p>
<h3 id="选择确认SACK"><a href="#选择确认SACK" class="headerlink" title="选择确认SACK"></a>选择确认SACK</h3><p>·        解决接收到的字节流序号不连续的问题</p>
<p>·         如果要使用选择确认 SACK, 那么在建立 TCP 连接时， 就要在 TCP 首部的选项中加上“ 允许 SACK” 的选项</p>
<p>·         由千首部选项的长度最多只有 40 字节， 而指明一个边界就要用掉4字节（因为序号有 32 位， 需要使用4个字节表示）， 因此在选项中最多只能指明 4 个字节块的边界信息。 这是因为 4 个字节块共有 8 个边界， 因而需要用 32 个字节来描述。 另外还需要两个字节。一个字节用来指明是 SACK 选项， 另一个字节是指明这个选项要占用多少字节。 如果要报告五个字节块的边界信息</p>
<p>·        4个边界，两个块 用了4*4字节+2字节（sack+sack长度）</p>
<h2 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h2><p> 发送方的发送速率不要太快，要让接收方来得及接收。</p>
<h3 id="利用滑动窗口实现流量控制"><a href="#利用滑动窗口实现流量控制" class="headerlink" title="利用滑动窗口实现流量控制"></a>利用滑动窗口实现流量控制</h3><p>·        通过控制窗口值控制速率</p>
<p>·        发送方的发送窗口不能超过接收方给出的接收窗口的数值。 请注意， TCP 的窗口单位是字节， 不是报文段。</p>
<p>·        为了防止0窗口后的新窗口丢失</p>
<p>•      发送方 持续计时器</p>
<p>•      发送一个零窗口探测报文段</p>
<p>•      若为窗口仍为0</p>
<p>•      持续探测</p>
<p>•      若为窗口不为0</p>
<p>•      继续传输</p>
<h3 id="TCP-的传输效率"><a href="#TCP-的传输效率" class="headerlink" title="TCP 的传输效率"></a>TCP 的传输效率</h3><p>·        发送时机机制</p>
<p>•      第一种机制是TCP维持一个变量， 它等于最大报文段长度MSS。 只要缓存中存放的数据达到MSS 字节时， 就组装成一个TCP 报文段发送出去。 </p>
<p>•      第二种机制是由发送方的应用进程指明要求发送报文段，即TCP支持的推送(push)操作。 </p>
<p>•       第三种机制是发送方的一个计时器期限到了， 这时就把当前已有的缓存数据装入报文段（但长度不能超过MSS) 发送出去。</p>
<p>·        Nagle 算法</p>
<p>•      若发送应用进程把要发送的数据逐个字节地送到 TCP 的发送缓存， 则发送方就把第一个数据字节先发送出去， 把后面到达的数据字节都缓存起来。 当发送方收到对第一个数据字符的确认后， 再把发送缓存中的所有数据组装成一个报文段发送出去， 同时继续对随后到达的数据进行缓存。 只有在收到对前一个报文段的确认后才继续发送下一个报文段</p>
<p>•      规定： 当到达的数据已达到发送窗口大小的一半或已达到报文段的最大长度时， 就立即发送一个报文段。 这样做， 就可以有效地提高网络的吞吐量。</p>
<p>·        糊涂窗口综合征</p>
<p>•      现象</p>
<p>•      TCP 接收方的缓存已满， 而交互式的应用进程一次只从接收缓存中读取1个字节（这样就使接收缓存空间仅腾出1个字节）， 然后向发送方发送确认，把窗口设置为1个字节（但发送的数据报是40字节长）。 接着， 发送方又发来l个字节的数<br> 据（请注意， 发送方发送的IP数据报是41字节长）。 接收方发回确认， 仍然将窗口设置为<br> l 个字节。 这样进行下去， 使网络的效率很低。</p>
<p>•      解决</p>
<p>•      接收方等待一段时间， 使得或者接收缓存已有足够空间容纳一个最长的报文段， 或者等到接收缓存已有一半空闲的空间。 只要出现这两种情况之一， 接收方就发出确认报文， 并向发送方通知当前的窗口大小。 此外， 发送方也不要发送太小的报文段而是把数据积累成足够大的报文段， 或达到接收方缓存的空间的一半大小。</p>
<h2 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h2><h3 id="拥塞控制的一般原理"><a href="#拥塞控制的一般原理" class="headerlink" title="拥塞控制的一般原理"></a>拥塞控制的一般原理</h3><p>·        拥塞</p>
<p>•      定义</p>
<p>•      在某段时间， 若对网络中某一资源的需求超过了该资源所能提供的可用部分， 网络的性能<br> 就要变坏。 这种情况就叫做拥塞(congestion)。</p>
<p>•      任意增加一些资源不但不能解决拥塞问题， 而且还可能使网络的性能更坏。拥塞常常趋千恶化。</p>
<p>•      原因</p>
<p>•      复杂</p>
<p>•      某个结点缓存的容量太小时， 到达该结<br> 点的分组因无存储空间暂存而不得不被丢弃。</p>
<p>•      理机处理的速率太慢可能引起网络的拥塞。 简单地将处理机的速率提高， 可能会使上述情况缓解一些， 但往往又会将瓶颈转移到其他地方。</p>
<p>·        拥塞控制</p>
<p>•      定义</p>
<p>•      防止过多的数据注入到网络中， 这样可以使网络中的路由器或链路不致过载。</p>
<p>•      是一个全局性的过程</p>
<p>•      拥塞控制与流量控制的关系</p>
<p>•      关系密切</p>
<p>•      流量控制往往是指点对点通信量的控制， 是个端到端的问题</p>
<p>•      </p>
<p><img src="https://i.loli.net/2020/06/11/Rw6FqG42QnVoJLN.png" alt="clip_image016.png"></p>
<p>•      方法</p>
<p>•      开环控制</p>
<p>•      在设计网络时事先将有关发生拥塞的因素考虑周到， 力求网络在工作时不产生拥塞。</p>
<p>•      闭环控制</p>
<p>•      监测网络系统以便检测到拥塞在何时、 何处发生。</p>
<p>•      把拥塞发生的信息传送到可采取行动的地方。</p>
<p>•      调整网络系统的运行以解决出现的问题。</p>
<h3 id="TCP的拥塞控制方法"><a href="#TCP的拥塞控制方法" class="headerlink" title="TCP的拥塞控制方法"></a>TCP的拥塞控制方法</h3><p>·        四种方法共同使用</p>
<p>•      慢开始(slow-start)</p>
<p>•      由小到大逐渐增大发送窗口（指数增加）</p>
<p>•      拥塞窗口cwnd每次的增加量=min (N, SMSS )</p>
<p>•      N 是原先未被确认的、 但现在被刚收到的确认报文段所确认的字节数。</p>
<p>•      拥 塞 避 免(congestion avoidance)</p>
<p>•      拥塞避免算法的思路是让拥塞窗口cwnd缓慢地增大， 即每经过一个往返时间RTT就把发送方的拥塞窗口 cwnd 加1,而不是像慢开始阶段那样加倍增长。 因此 在拥塞避免阶段就有“加法增大” AI (Additive Increase)的 特点。 这表明在拥塞避免阶段，拥塞窗口cwnd按线性规律缓慢增长， 比慢开始算法的拥塞窗口增长速率缓慢得多。</p>
<p>•       快重传(fast retransmit)</p>
<p>•      发送方只要一连收到3个重复确认， 就知道接收方确实没有收到报文段M3, 因而应当立即进行重传</p>
<p>•      </p>
<p><img src="https://i.loli.net/2020/06/11/84hODIkWaSi6LZR.png" alt="clip_image018.png"></p>
<p>•      快重传可以使整个网络的吞吐量提高约20%。</p>
<p>•      快恢复(fast recovery)</p>
<p>•      发送方调整门限值ssthresh = cwnd / 2</p>
<p>•      拥塞窗口cwnd= ssthresh</p>
<p>•      开始执行拥塞避免算法</p>
<p>•      概要发送方控制拥塞窗口的原则 是：只要网络没有出现拥塞，拥塞窗口就可以再增大一些， 以便把更多的分组发送出去， 这样就可以提高网络的利用率。 但只要网络出现拥塞或有可能出现拥塞，就必须把拥塞窗口减小一些， 以减少注入到网络中的分组数， 以便缓解网络出现的拥塞。</p>
<p>•      发送方又是如何知道网络发生了拥塞</p>
<p>•      判断网络拥塞的依据就是出现了超时。</p>
<p>•      慢开始门限 ssthresh</p>
<p>•      cwnd&lt; ssthresh时， 使用上述的慢开始算法。</p>
<p>•      cwnd&gt; ssthresh时， 停止使用慢开始算法而改用拥塞避免算法。</p>
<p>•      cwnd= ssthresh时， 既可使用慢开始算法， 也可使用拥塞避免算法。</p>
<p>•      </p>
<p><img src="https://i.loli.net/2020/06/11/ACFKPpbcMh4TLUu.png" alt="clip_image019.png"></p>
<p>·        流程图</p>
<p>•      </p>
<p><img src="https://i.loli.net/2020/06/11/mwjQfucqle7pkgP.png" alt="clip_image021.png"></p>
<h3 id="主动队列管理AQM"><a href="#主动队列管理AQM" class="headerlink" title="主动队列管理AQM"></a>主动队列管理AQM</h3><p>·        略</p>
<h2 id="TCP的运输连接管理"><a href="#TCP的运输连接管理" class="headerlink" title="TCP的运输连接管理"></a>TCP的运输连接管理</h2><h3 id="运输连接"><a href="#运输连接" class="headerlink" title="运输连接"></a>运输连接</h3><p>·        连接建立</p>
<p>•      要解决的问题</p>
<p>•      要使每一方能够确知对方的存在</p>
<p>•      要允许双方协商 一些参数</p>
<p>•      能够对运输实体资源</p>
<p>•      主动发起连接建立的应用进程叫做客户(client),<br> 而被动等待连接建立的应用进程叫做服务器(server)。</p>
<p>•      过程</p>
<p>•      三次握手</p>
<p><img src="https://i.loli.net/2020/06/11/lED46Aticw5K71x.png" alt="clip_image022.png"></p>
<p>·        数据传送</p>
<p>·        连接释放</p>
<p>•      过程</p>
<p>•      四报文握手</p>
<p><img src="https://i.loli.net/2020/06/11/hjVpKM3yqG9RFmZ.png" alt="clip_image023.png"></p>
<p>•      A必须等待2MSL的时间</p>
<p>•      为了保证A发送的最后一一个ACK报文段能够到达B。</p>
<p>•      防止已失效的连接请求报文段” 出现在本连接中。</p>
<p>•      数据传输结束后，通信的双方都可释放连接。</p>
<h3 id="TCP的有限状态机"><a href="#TCP的有限状态机" class="headerlink" title="TCP的有限状态机"></a>TCP的有限状态机</h3><p>·         </p>
<p><img src="https://i.loli.net/2020/06/11/5jDLVlCMArvtFca.png" alt="clip_image024.png"></p>
<p>•      粗实线箭头表示对客户进程的正常变迁。<br> 粗虚线箭头表示对服务器进程的正常变迁。<br> 另一种细线箭头表示异常变迁。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>计网笔记</tag>
        <tag>运输层</tag>
      </tags>
  </entry>
</search>
